diff -ruNp srclimpio/etc/system.conf proj/etc/system.conf
--- srclimpio/etc/system.conf	Thu Oct 29 20:46:30 2015
+++ proj/etc/system.conf	Thu Oct 29 22:38:42 2015
@@ -69,6 +69,20 @@ service pm
 	quantum	       500;	# default server quantum
 };
 
+service syncvar
+{
+        uid     0;
+        ipc     ALL;            # ALL ipc targets allowed
+        system  ALL;            # ALL kernel calls allowed
+        io      NONE;           # No I/O range allowed
+        irq     NONE;           # No IRQ allowed
+        sigmgr          rs;     # Signal manager is RS
+        scheduler   KERNEL;     # Scheduler is KERNEL
+        priority         4;     # priority queue 4
+        quantum        500;     # default server quantum
+};
+
+
 service sched
 {
 	uid     0;
diff -ruNp srclimpio/minix/include/minix/Makefile proj/minix/include/minix/Makefile
--- srclimpio/minix/include/minix/Makefile	Thu Oct 29 20:46:53 2015
+++ proj/minix/include/minix/Makefile	Fri Oct 30 12:56:09 2015
@@ -22,6 +22,6 @@ INCS+=	acpi.h audio_fw.h bitmap.h \
 	u64.h usb.h usb_ch9.h vbox.h \
 	vboxfs.h vboxif.h vboxtype.h vm.h \
 	vfsif.h vtreefs.h libminixfs.h netsock.h \
-	virtio.h
+	virtio.h syncvar.h
 
 .include <bsd.kinc.mk>
diff -ruNp srclimpio/minix/include/minix/callnr.h proj/minix/include/minix/callnr.h
--- srclimpio/minix/include/minix/callnr.h	Thu Oct 29 20:46:53 2015
+++ proj/minix/include/minix/callnr.h	Thu Oct 29 22:36:33 2015
@@ -58,9 +58,20 @@
 #define PM_GETEPINFO		(PM_BASE + 45)
 #define PM_GETPROCNR		(PM_BASE + 46)
 #define PM_GETSYSINFO		(PM_BASE + 47)
+#define PM_MYCALL               (PM_BASE + 48)
+#define PM_MYCALLS              (PM_BASE + 49)
+#define PM_MUTEX_INIT		(PM_BASE + 50)
+#define PM_MUTEX_DESTROY	(PM_BASE + 51)
+#define PM_MUTEX_LOCK		(PM_BASE + 52)
+#define PM_MUTEX_UNLOCK		(PM_BASE + 53)
+#define PM_CV_INIT		(PM_BASE + 54)
+#define PM_CV_DESTROY		(PM_BASE + 55)
+#define PM_CV_WAIT		(PM_BASE + 56)
+#define PM_CV_SIGNAL		(PM_BASE + 57)
+#define PM_CV_BROADCAST		(PM_BASE + 58)
+ 
+#define NR_PM_CALLS		59	/* highest number from base plus one */
 
-#define NR_PM_CALLS		48	/* highest number from base plus one */
-
 /*===========================================================================*
  *				Calls to VFS				     *
  *===========================================================================*/
@@ -120,5 +131,27 @@
 #define VFS_GETSYSINFO		(VFS_BASE + 48)
 
 #define NR_VFS_CALLS		49	/* highest number from base plus one */
+
+/*===========================================================================*
+ *                              Calls to SYNC                                 
+* 
+*===========================================================================*/
+
+#define SYNC_BASE                0x1700
+
+#define IS_SYNC_CALL(type)       (((type) & ~0xff) == SYNC_BASE)
+
+#define SYNC_MUTEX_INIT         (SYNC_BASE + 0)
+#define SYNC_MUTEX_DESTROY      (SYNC_BASE + 1)
+#define SYNC_MUTEX_LOCK         (SYNC_BASE + 2)
+#define SYNC_MUTEX_UNLOCK	(SYNC_BASE + 3)
+#define SYNC_CV_INIT	        (SYNC_BASE + 4)
+#define SYNC_CV_DESTROY		(SYNC_BASE + 5)
+#define SYNC_CV_WAIT		(SYNC_BASE + 6)
+#define SYNC_CV_SIGNAL		(SYNC_BASE + 7)
+#define SYNC_CV_BROADCAST	(SYNC_BASE + 8)
+
+#define NR_SYNC_CALLS            9      /* highest number from base plus one */
+
 
 #endif /* !_MINIX_CALLNR_H */
diff -ruNp srclimpio/minix/include/minix/com.h proj/minix/include/minix/com.h
--- srclimpio/minix/include/minix/com.h	Thu Oct 29 20:46:53 2015
+++ proj/minix/include/minix/com.h	Thu Oct 29 22:35:18 2015
@@ -28,6 +28,7 @@
  *   0x1400 - 0x14FF	Real Time Clock requests and responses
  *   0x1500 - 0x15FF	Input server messages
  *   0x1600 - 0x16FF	VirtualBox (VBOX) requests (see vboxif.h)
+ *   0x1700 - 0x17FF	Variables de sincronizacion
  *
  * Zero and negative values are widely used for OK and error responses.
  */
@@ -62,8 +63,10 @@
 #define MFS_PROC_NR  ((endpoint_t) 7)   /* minix root filesystem */
 #define VM_PROC_NR   ((endpoint_t) 8)   /* memory server */
 #define PFS_PROC_NR  ((endpoint_t) 9)  /* pipe filesystem */
-#define LAST_SPECIAL_PROC_NR	10	/* An untyped version for
-                                           computation in macros.*/
+#define SYNC_PROC_NR ((endpoint_t) 10)  /* syncvar */
+
+#define LAST_SPECIAL_PROC_NR	11	/* An untyped version for computation in macros.*/
+
 #define INIT_PROC_NR ((endpoint_t) LAST_SPECIAL_PROC_NR)  /* init
                                                         -- goes multiuser */
 #define NR_BOOT_MODULES (INIT_PROC_NR+1)
@@ -262,9 +265,10 @@
 #  define SYS_SAFEMEMSET (KERNEL_CALL + 56)	/* sys_safememset() */
 
 #  define SYS_PADCONF (KERNEL_CALL + 57)	/* sys_padconf() */
+#  define SYS_SAMPLE    (KERNEL_CALL + 58)      /* sys_sample() */
 
 /* Total */
-#define NR_SYS_CALLS	58	/* number of kernel calls */
+#define NR_SYS_CALLS	59	/* number of kernel calls */
 
 #define SYS_CALL_MASK_SIZE BITMAP_CHUNKS(NR_SYS_CALLS)
 
diff -ruNp srclimpio/minix/include/minix/minix/Makefile proj/minix/include/minix/minix/Makefile
--- srclimpio/minix/include/minix/minix/Makefile	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/Makefile	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,27 @@
+.include <bsd.own.mk>
+
+INCSDIR= /usr/include/minix
+
+INCS+=	paths.h param.h
+INCS+=	acpi.h audio_fw.h bitmap.h \
+	bdev.h blockdriver.h blockdriver_mt.h \
+	board.h btrace.h \
+	callnr.h chardriver.h clkconf.h com.h \
+	config.h const.h cpufeature.h \
+	debug.h devio.h devman.h dmap.h \
+	driver.h drivers.h drvlib.h ds.h \
+	endpoint.h fb.h fslib.h gpio.h gcov.h hash.h \
+	hgfs.h i2c.h i2cdriver.h ioctl.h input.h \
+	inputdriver.h ipc.h ipcconst.h \
+	keymap.h log.h mmio.h mthread.h minlib.h \
+	netdriver.h optset.h padconf.h partition.h portio.h \
+	priv.h procfs.h profile.h queryparam.h \
+	rs.h safecopies.h sched.h sef.h sffs.h \
+	sound.h spin.h sys_config.h sysinfo.h \
+	syslib.h sysutil.h timers.h type.h \
+	u64.h usb.h usb_ch9.h vbox.h \
+	vboxfs.h vboxif.h vboxtype.h vm.h \
+	vfsif.h vtreefs.h libminixfs.h netsock.h \
+	virtio.h
+
+.include <bsd.kinc.mk>
diff -ruNp srclimpio/minix/include/minix/minix/acpi.h proj/minix/include/minix/minix/acpi.h
--- srclimpio/minix/include/minix/minix/acpi.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/acpi.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,44 @@
+#include <sys/types.h>
+#include <minix/ipc.h>
+
+#define ACPI_REQ_GET_IRQ	1
+#define ACPI_REQ_MAP_BRIDGE	2
+
+struct acpi_request_hdr {
+	endpoint_t 	m_source; /* message header */
+	u32_t		request;
+};
+
+/* 
+ * Message to request dev/pin translation to IRQ by acpi using the acpi routing
+ * tables
+ */
+struct acpi_get_irq_req {
+	struct acpi_request_hdr	hdr;
+	u32_t			bus;
+	u32_t			dev;
+	u32_t			pin;
+	u32_t			__padding[4];
+};
+
+/* response from acpi to acpi_get_irq_req */
+struct acpi_get_irq_resp {
+	endpoint_t 	m_source; /* message header */
+	i32_t		irq;
+	u32_t		__padding[7];
+};
+
+/* message format for pci bridge mappings to acpi */
+struct acpi_map_bridge_req {
+	struct acpi_request_hdr	hdr;
+	u32_t	primary_bus;
+	u32_t	secondary_bus;
+	u32_t	device;
+	u32_t	__padding[4];
+};
+
+struct acpi_map_bridge_resp {
+	endpoint_t 	m_source; /* message header */
+	int		err;
+	u32_t		__padding[7];
+};
diff -ruNp srclimpio/minix/include/minix/minix/audio_fw.h proj/minix/include/minix/minix/audio_fw.h
--- srclimpio/minix/include/minix/minix/audio_fw.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/audio_fw.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,87 @@
+#ifndef AUDIO_FW_H
+#define AUDIO_FW_H
+
+#include <minix/drivers.h>
+#include <minix/chardriver.h>
+#include <sys/ioc_sound.h>
+
+
+int drv_init(void);
+int drv_init_hw(void);
+int drv_reset(void);
+int drv_start(int sub_dev, int DmaMode);
+int drv_stop(int sub_dev);
+int drv_set_dma(u32_t dma, u32_t length, int chan);
+int drv_reenable_int(int chan);
+int drv_int_sum(void);
+int drv_int(int sub_dev);
+int drv_pause(int chan);
+int drv_resume(int chan);
+int drv_io_ctl(unsigned long request, void * val, int * len, int sub_dev);
+int drv_get_irq(char *irq);
+int drv_get_frag_size(u32_t *frag_size, int sub_dev);
+
+
+
+/* runtime status fields */
+typedef struct {
+	int readable;
+	int writable;
+	int DmaSize;
+	int NrOfDmaFragments;
+	int MinFragmentSize;
+	int NrOfExtraBuffers;
+	int Nr;                                   /* sub device number */
+	int Opened;                               /* sub device opened */
+	int DmaBusy;                              /* is dma busy? */
+	int DmaMode;                              /* DEV_WRITE / DEV_READ */
+	int DmaReadNext;                          /* current dma buffer */
+	int DmaFillNext;                          /* next dma buffer to fill */
+	int DmaLength;
+	int BufReadNext;                          /* start of extra circular buffer */
+	int BufFillNext;                          /* end of extra circular buffer */
+	int BufLength;
+	int RevivePending;                        /* process waiting for this dev? */
+	endpoint_t ReviveProcNr;                  /* the process to unblock */
+	cdev_id_t ReviveId;                       /* request ID */
+	cp_grant_id_t ReviveGrant;		  /* grant id associated with io */
+	endpoint_t SourceProcNr;                  /* process to send notify to (FS) */
+	u32_t FragSize;                           /* dma fragment size */
+	char *DmaBuf;        /* the dma buffer; extra space for 
+												  page alignment */
+	phys_bytes DmaPhys;                       /* physical address of dma buffer */
+	char* DmaPtr;                             /* pointer to aligned dma buffer */
+	int OutOfData;                            /* all buffers empty? */
+	char *ExtraBuf;                           /* don't use extra buffer;just 
+											   declare a pointer to supress
+											   error messages */
+} sub_dev_t;
+
+typedef struct {
+	int minor_dev_nr;
+	int read_chan;
+	int write_chan;
+	int io_ctl;
+} special_file_t;
+
+typedef struct {
+	char* DriverName;
+	int NrOfSubDevices;
+	int NrOfSpecialFiles;
+} drv_t;
+
+EXTERN drv_t drv;
+EXTERN sub_dev_t sub_dev[];
+EXTERN special_file_t special_file[];
+
+/* Number of bytes you can DMA before hitting a 64K boundary: */
+#define dma_bytes_left(phys)    \
+   ((unsigned) (sizeof(int) == 2 ? 0 : 0x10000) - (unsigned) ((phys) & 0xFFFF))
+
+#define NO_CHANNEL -1
+
+#define NO_DMA 0
+#define READ_DMA 1
+#define WRITE_DMA 2
+
+#endif /* AUDIO_FW_H */
diff -ruNp srclimpio/minix/include/minix/minix/bdev.h proj/minix/include/minix/minix/bdev.h
--- srclimpio/minix/include/minix/minix/bdev.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/bdev.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,46 @@
+#ifndef _MINIX_BDEV_H
+#define _MINIX_BDEV_H
+
+/* Common API. */
+extern void bdev_driver(dev_t dev, char *label);
+
+/* Synchronous API. */
+extern int bdev_open(dev_t dev, int access);
+extern int bdev_close(dev_t dev);
+
+extern ssize_t bdev_read(dev_t dev, u64_t pos, char *buf, size_t count,
+	int flags);
+extern ssize_t bdev_write(dev_t dev, u64_t pos, char *buf, size_t count,
+	int flags);
+extern ssize_t bdev_gather(dev_t dev, u64_t pos, iovec_t *vec, int count,
+	int flags);
+extern ssize_t bdev_scatter(dev_t dev, u64_t pos, iovec_t *vec, int count,
+	int flags);
+extern int bdev_ioctl(dev_t dev, int request, void *buf,
+	endpoint_t user_endpt);
+
+/* Asynchronous API. */
+typedef int bdev_id_t;
+typedef void *bdev_param_t;
+
+typedef void (*bdev_callback_t)(dev_t dev, bdev_id_t id, bdev_param_t param,
+	int result);
+
+extern void bdev_flush_asyn(dev_t dev);
+
+extern bdev_id_t bdev_read_asyn(dev_t dev, u64_t pos, char *buf, size_t count,
+	int flags, bdev_callback_t callback, bdev_param_t param);
+extern bdev_id_t bdev_write_asyn(dev_t dev, u64_t pos, char *buf, size_t count,
+	int flags, bdev_callback_t callback, bdev_param_t param);
+extern bdev_id_t bdev_gather_asyn(dev_t dev, u64_t pos, iovec_t *vec,
+	int count, int flags, bdev_callback_t callback, bdev_param_t param);
+extern bdev_id_t bdev_scatter_asyn(dev_t dev, u64_t pos, iovec_t *vec,
+	int count, int flags, bdev_callback_t callback, bdev_param_t param);
+extern bdev_id_t bdev_ioctl_asyn(dev_t dev, int request, void *buf,
+	endpoint_t user_endpt, bdev_callback_t callback, bdev_param_t param);
+
+extern int bdev_wait_asyn(bdev_id_t id);
+
+extern void bdev_reply_asyn(message *m);
+
+#endif /* _MINIX_BDEV_H */
diff -ruNp srclimpio/minix/include/minix/minix/bitmap.h proj/minix/include/minix/minix/bitmap.h
--- srclimpio/minix/include/minix/minix/bitmap.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/bitmap.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,34 @@
+#ifndef _BITMAP_H
+#define _BITMAP_H
+
+/* Bit map operations to manipulate bits of a simple mask variable. */
+#define bit_set(mask, n)	((mask) |= (1 << (n)))
+#define bit_unset(mask, n)	((mask) &= ~(1 << (n)))
+#define bit_isset(mask, n)	((mask) & (1 << (n)))
+#define bit_empty(mask)		((mask) = 0)
+#define bit_fill(mask)		((mask) = ~0)
+
+/* Definitions previously in kernel/const.h */
+#define BITCHUNK_BITS   (sizeof(bitchunk_t) * CHAR_BIT)
+#define BITMAP_CHUNKS(nr_bits) (((nr_bits)+BITCHUNK_BITS-1)/BITCHUNK_BITS)
+#define MAP_CHUNK(map,bit) (map)[((bit)/BITCHUNK_BITS)]
+#define CHUNK_OFFSET(bit) ((bit)%BITCHUNK_BITS)
+#define GET_BIT(map,bit) ( MAP_CHUNK(map,bit) & (1 << CHUNK_OFFSET(bit) ))
+#define SET_BIT(map,bit) ( MAP_CHUNK(map,bit) |= (1 << CHUNK_OFFSET(bit) ))
+#define UNSET_BIT(map,bit) ( MAP_CHUNK(map,bit) &= ~(1 << CHUNK_OFFSET(bit) ))
+
+#if defined(CONFIG_SMP) && defined(__GNUC__)
+#ifndef __ASSEMBLY__
+static inline void bits_fill(bitchunk_t * chunks, unsigned bits)
+{
+	unsigned c, cnt;
+
+	cnt = BITMAP_CHUNKS(bits);
+	for (c = 0; c < cnt; c++)
+		bit_fill(chunks[c]);
+}
+#endif
+#endif
+
+
+#endif	/* _BITMAP_H */
diff -ruNp srclimpio/minix/include/minix/minix/blockdriver.h proj/minix/include/minix/minix/blockdriver.h
--- srclimpio/minix/include/minix/minix/blockdriver.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/blockdriver.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,62 @@
+#ifndef _MINIX_BLOCKDRIVER_H
+#define _MINIX_BLOCKDRIVER_H
+
+#include <minix/driver.h>
+
+typedef int device_id_t;
+typedef int thread_id_t;
+
+/* Types supported for the 'type' field of struct blockdriver. */
+typedef enum {
+  BLOCKDRIVER_TYPE_DISK,		/* handle partition requests */
+  BLOCKDRIVER_TYPE_OTHER		/* do not handle partition requests */
+} blockdriver_type_t;
+
+/* Entry points into the device dependent code of block drivers. */
+struct blockdriver {
+  blockdriver_type_t bdr_type;
+  int (*bdr_open)(devminor_t minor, int access);
+  int (*bdr_close)(devminor_t minor);
+  ssize_t (*bdr_transfer)(devminor_t minor, int do_write, u64_t pos,
+	  endpoint_t endpt, iovec_t *iov, unsigned int count, int flags);
+  int (*bdr_ioctl)(devminor_t minor, unsigned long request, endpoint_t endpt,
+	  cp_grant_id_t grant, endpoint_t user_endpt);
+  void (*bdr_cleanup)(void);
+  struct device *(*bdr_part)(devminor_t minor);
+  void (*bdr_geometry)(devminor_t minor, struct part_geom *part);
+  void (*bdr_intr)(unsigned int mask);
+  void (*bdr_alarm)(clock_t stamp);
+  void (*bdr_other)(message *m_ptr, int ipc_status);
+  int (*bdr_device)(devminor_t minor, device_id_t *id);
+};
+
+/* Functions defined by libblockdriver. These can be used for both
+ * singlethreaded and multithreaded drivers.
+ */
+void blockdriver_announce(int type);
+
+#ifndef _BLOCKDRIVER_MT_API
+/* Additional functions for the singlethreaded version. These allow the driver
+ * to either use the stock driver_task(), or implement its own message loop.
+ * To avoid accidents, these functions are not exposed when minix/driver_mt.h
+ * has been included previously.
+ */
+int blockdriver_receive_mq(message *m_ptr, int *status_ptr);
+void blockdriver_process(struct blockdriver *dp, message *m_ptr, int
+	ipc_status);
+void blockdriver_terminate(void);
+void blockdriver_task(struct blockdriver *bdp);
+int blockdriver_mq_queue(message *m_ptr, int status);
+#endif /* !_BLOCKDRIVER_MT_API */
+
+/* Parameters for the disk drive. */
+#define SECTOR_SIZE      512	/* physical sector size in bytes */
+#define SECTOR_SHIFT       9	/* for division */
+#define SECTOR_MASK      511	/* and remainder */
+
+#define CD_SECTOR_SIZE  2048	/* sector size of a CD-ROM in bytes */
+
+/* Size of the DMA buffer buffer in bytes. */
+#define DMA_BUF_SIZE	(DMA_SECTORS * SECTOR_SIZE)
+
+#endif /* _MINIX_BLOCKDRIVER_H */
diff -ruNp srclimpio/minix/include/minix/minix/blockdriver_mt.h proj/minix/include/minix/minix/blockdriver_mt.h
--- srclimpio/minix/include/minix/minix/blockdriver_mt.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/blockdriver_mt.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,16 @@
+#ifndef _MINIX_BLOCKDRIVER_MT_H
+#define _MINIX_BLOCKDRIVER_MT_H
+
+#define BLOCKDRIVER_MT_API 1	/* do not expose the singlethreaded API */
+#include <minix/blockdriver.h>
+
+#define BLOCKDRIVER_MAX_DEVICES		32
+
+void blockdriver_mt_task(struct blockdriver *driver_tab);
+void blockdriver_mt_sleep(void);
+void blockdriver_mt_wakeup(thread_id_t id);
+void blockdriver_mt_terminate(void);
+void blockdriver_mt_set_workers(device_id_t id, int workers);
+thread_id_t blockdriver_mt_get_tid(void);
+
+#endif /* _MINIX_BLOCKDRIVER_MT_H */
diff -ruNp srclimpio/minix/include/minix/minix/board.h proj/minix/include/minix/minix/board.h
--- srclimpio/minix/include/minix/minix/board.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/board.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,232 @@
+#ifndef __BOARD_H__
+#define __BOARD_H__
+#include <string.h>
+/* 
+  Utility functions to access/parse the board_id defined in the machine
+  struct in include/minix/type.h.
+
+   Identifier for the board 
+     [31:28] Architecture.  (MINIX_BOARD_ARCH)
+     [27:24] Architecture variant (MINIX_BOARD_ARCH_VARIANT) VERSION e.g. ARMV7 
+     [23:16] Vendor/Soc (EG TI )  (MINIX_BOARD_VENDOR) 
+     [15:8]  Board      (EG Beagle bone , beagle board ) (MINIX_BOARD)
+     [7:0]   Board variant (EG BealgeBone white v.s. BeagleBone black ) (MINIX_BOARD_VARIANT)
+*/
+
+#define MINIX_BOARD_ARCH_SHIFT         (28)
+#define MINIX_BOARD_ARCH_VARIANT_SHIFT (24)
+#define MINIX_BOARD_VENDOR_SHIFT       (16)
+#define MINIX_BOARD_SHIFT              (8)
+#define MINIX_BOARD_VARIANT_SHIFT      (0)
+
+/* 4 bits */
+#define MINIX_BOARD_ARCH_MASK \
+	(0XF << MINIX_BOARD_ARCH_SHIFT)
+/* 4 bits */
+#define MINIX_BOARD_ARCH_VARIANT_MASK \
+	(0XF << MINIX_BOARD_ARCH_VARIANT_SHIFT)
+/* 8 bits */
+#define MINIX_BOARD_VENDOR_MASK \
+	(0XFF << MINIX_BOARD_VENDOR_SHIFT)
+/* 8 bits */
+#define MINIX_BOARD_MASK \
+	(0XFF << MINIX_BOARD_SHIFT)
+/* 8 bits */
+#define MINIX_BOARD_VARIANT_MASK \
+	(0XFF << MINIX_BOARD_VARIANT_SHIFT)
+
+#define MINIX_MK_BOARD_ARCH(v) \
+	((v << MINIX_BOARD_ARCH_SHIFT ) & MINIX_BOARD_ARCH_MASK)
+#define MINIX_MK_BOARD_ARCH_VARIANT(v) \
+	(( v << MINIX_BOARD_ARCH_VARIANT_SHIFT) & MINIX_BOARD_ARCH_VARIANT_MASK )
+#define MINIX_MK_BOARD_VENDOR(v) \
+	(( v << MINIX_BOARD_VENDOR_SHIFT) & MINIX_BOARD_VENDOR_MASK )
+#define MINIX_MK_BOARD(v) \
+	(( v << MINIX_BOARD_SHIFT) & MINIX_BOARD_MASK )
+#define MINIX_MK_BOARD_VARIANT(v) \
+	(( v << MINIX_BOARD_VARIANT_SHIFT) & MINIX_BOARD_VARIANT_MASK )
+
+#define MINIX_BOARD_ARCH(v) \
+	((v & MINIX_BOARD_ARCH_MASK) >> MINIX_BOARD_ARCH_SHIFT )
+#define MINIX_BOARD_ARCH_VARIANT(v) \
+	(( v & MINIX_BOARD_ARCH_VARIANT_MASK) >> MINIX_BOARD_ARCH_VARIANT_SHIFT)
+#define MINIX_BOARD_VENDOR(v) \
+	(( v & MINIX_BOARD_VENDOR_MASK) >> MINIX_BOARD_VENDOR_SHIFT)
+#define MINIX_BOARD(v) \
+	(( v & MINIX_BOARD_MASK) >> MINIX_BOARD_SHIFT)
+#define MINIX_BOARD_VARIANT(v) \
+	(( v & MINIX_BOARD_VARIANT_MASK) >> MINIX_BOARD_VARIANT_SHIFT)
+
+/* We want to make it possible to use masks and therefore only try to use bits */
+#define MINIX_BOARD_ARCH_X86 MINIX_MK_BOARD_ARCH(1 << 0)
+#define MINIX_BOARD_ARCH_ARM MINIX_MK_BOARD_ARCH(1 << 1)
+
+#define MINIX_BOARD_ARCH_VARIANT_X86_GENERIC MINIX_MK_BOARD_ARCH_VARIANT(1<<0)
+#define MINIX_BOARD_ARCH_VARIANT_ARM_ARMV6 MINIX_MK_BOARD_ARCH_VARIANT(1<<1)
+#define MINIX_BOARD_ARCH_VARIANT_ARM_ARMV7 MINIX_MK_BOARD_ARCH_VARIANT(1<<2)
+
+#define MINIX_BOARD_VENDOR_INTEL MINIX_MK_BOARD_VENDOR(1<<0)
+#define MINIX_BOARD_VENDOR_TI MINIX_MK_BOARD_VENDOR(1<<1)
+
+#define MINIX_BOARD_GENERIC MINIX_MK_BOARD(1<<0)
+/* BeagleBoard XM */
+#define MINIX_BOARD_BBXM MINIX_MK_BOARD(1<<1)
+/* BeagleBone (Black and* white) */
+#define MINIX_BOARD_BB MINIX_MK_BOARD(1<<2)
+
+/* Only  one  of a kind */
+#define MINIX_BOARD_VARIANT_GENERIC MINIX_MK_BOARD_VARIANT(1<<0)
+/* BeagleBone White */
+#define MINIX_BOARD_VARIANT_BBW MINIX_MK_BOARD_VARIANT(1<<1)
+/* BeagleBone Black */
+#define MINIX_BOARD_VARIANT_BBB MINIX_MK_BOARD_VARIANT(1<<2)
+
+#define BOARD_ID_INTEL \
+	( MINIX_BOARD_ARCH_X86 \
+	| MINIX_BOARD_ARCH_VARIANT_X86_GENERIC \
+	| MINIX_BOARD_VENDOR_INTEL \
+	| MINIX_BOARD_GENERIC \
+	| MINIX_BOARD_VARIANT_GENERIC\
+	)
+
+#define BOARD_ID_BBXM \
+	( MINIX_BOARD_ARCH_ARM \
+	| MINIX_BOARD_ARCH_VARIANT_ARM_ARMV7 \
+	| MINIX_BOARD_VENDOR_TI \
+	| MINIX_BOARD_BBXM \
+	| MINIX_BOARD_VARIANT_GENERIC\
+	)
+
+#define BOARD_ID_BBW \
+	( MINIX_BOARD_ARCH_ARM \
+	| MINIX_BOARD_ARCH_VARIANT_ARM_ARMV7 \
+	| MINIX_BOARD_VENDOR_TI \
+	| MINIX_BOARD_BB \
+	| MINIX_BOARD_VARIANT_BBW\
+	)
+
+#define BOARD_ID_BBB \
+	( MINIX_BOARD_ARCH_ARM \
+	| MINIX_BOARD_ARCH_VARIANT_ARM_ARMV7 \
+	| MINIX_BOARD_VENDOR_TI \
+	| MINIX_BOARD_BB \
+	| MINIX_BOARD_VARIANT_BBB\
+	)
+
+#define BOARD_IS_BBXM(v) \
+		( (BOARD_ID_BBXM & ~MINIX_BOARD_VARIANT_MASK) == (v & ~MINIX_BOARD_VARIANT_MASK))
+/* Either one of the known BeagleBones */
+#define BOARD_IS_BB(v)   \
+		( (BOARD_ID_BBW & ~MINIX_BOARD_VARIANT_MASK) == (v & ~MINIX_BOARD_VARIANT_MASK))
+#define BOARD_IS_BBW(v)  ( v == BOARD_ID_BBW)
+#define BOARD_IS_BBB(v)  ( v == BOARD_ID_BBB)
+
+#define BOARD_FILTER_BBXM_VALUE (BOARD_ID_BBXM)
+#define BOARD_FILTER_BBXM_MASK  \
+		(MINIX_BOARD_ARCH_MASK \
+		| MINIX_BOARD_ARCH_VARIANT_MASK \
+		| MINIX_BOARD_VENDOR_MASK \
+		| MINIX_BOARD_MASK \
+		| MINIX_BOARD_VARIANT_MASK)
+
+#define BOARD_FILTER_BB_VALUE   (BOARD_ID_BBW & ~MINIX_BOARD_VARIANT_MASK)
+#define BOARD_FILTER_BB_MASK    \
+		(MINIX_BOARD_ARCH_MASK \
+		| MINIX_BOARD_ARCH_VARIANT_MASK \
+		| MINIX_BOARD_VENDOR_MASK \
+		| MINIX_BOARD_MASK )
+
+struct shortname2id
+{
+	const char name[15];
+	unsigned int id;
+};
+
+
+/* mapping from fields given by the bootloader to board id's */
+static struct shortname2id shortname2id[] = {
+	{.name = "BBXM",.id = BOARD_ID_BBXM},
+	{.name = "A335BONE",.id = BOARD_ID_BBW},
+	{.name = "A335BNLT",.id = BOARD_ID_BBB},
+};
+
+struct board_id2name
+{
+	unsigned int id;
+	const char name[40];
+};
+
+/* how to convert a BOARD id to a board name */
+static struct board_id2name board_id2name[] = {
+	{.id = BOARD_ID_INTEL,.name = "X86-I586-GENERIC-GENERIC-GENERIC"},
+	{.id = BOARD_ID_BBXM,.name = "ARM-ARMV7-TI-BBXM-GENERIC"},
+	{.id = BOARD_ID_BBW,.name = "ARM-ARMV7-TI-BB-WHITE"},
+	{.id = BOARD_ID_BBB,.name = "ARM-ARMV7-TI-BB-BLACK"},
+};
+
+struct board_arch2arch
+{
+	unsigned int board_arch;
+	const char arch[40];
+};
+/* Mapping from board_arch to arch */
+static struct board_arch2arch board_arch2arch[] = {
+	{.board_arch = MINIX_BOARD_ARCH_ARM ,.arch = "earm"},
+	{.board_arch = MINIX_BOARD_ARCH_X86 ,.arch = "i386"},
+};
+
+/* returns 0 if no board was found that match that id */
+static int
+get_board_id_by_short_name(const char *name)
+{
+	int x;
+	for (x = 0; x < sizeof(shortname2id) / sizeof(shortname2id[0]); x++) {
+		if (strncmp(name, shortname2id[x].name, 15) == 0) {
+			return shortname2id[x].id;
+		}
+	}
+	return 0;
+}
+
+/* returns 0 if no board was found that match that id */
+static int
+get_board_id_by_name(const char *name)
+{
+	int x;
+	for (x = 0; x < sizeof(board_id2name) / sizeof(board_id2name[0]); x++) {
+		if (strncmp(name, board_id2name[x].name, 40) == 0) {
+			return board_id2name[x].id;
+		}
+	}
+	return 0;
+}
+
+/* convert a board id to a board name to use later 
+   returns NULL if no board was found that match that id */
+static const char *
+get_board_name(unsigned int id)
+{
+	int x;
+	for (x = 0; x < sizeof(board_id2name) / sizeof(board_id2name[0]); x++) {
+		if (board_id2name[x].id == id) {
+			return board_id2name[x].name;
+		}
+	}
+	return NULL;
+}
+
+/* convert a board id to a board name to use later 
+   returns NULL if no board was found that match that id */
+static const char *
+get_board_arch_name(unsigned int id)
+{
+	int x;
+	for (x = 0; x < sizeof(board_arch2arch) / sizeof(board_arch2arch[0]); x++) {
+		if (board_arch2arch[x].board_arch == (id & MINIX_BOARD_ARCH_MASK) ) {
+			return board_arch2arch[x].arch;
+		}
+	}
+	return NULL;
+}
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/btrace.h proj/minix/include/minix/minix/btrace.h
--- srclimpio/minix/include/minix/minix/btrace.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/btrace.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,40 @@
+#ifndef _MINIX_BTRACE_H
+#define _MINIX_BTRACE_H
+
+/* Control directives. */
+enum {
+  BTCTL_START,
+  BTCTL_STOP
+};
+
+/* Request codes. */
+enum {
+  BTREQ_OPEN,
+  BTREQ_CLOSE,
+  BTREQ_READ,
+  BTREQ_WRITE,
+  BTREQ_GATHER,
+  BTREQ_SCATTER,
+  BTREQ_IOCTL
+};
+
+/* Special result codes. */
+#define BTRES_INPROGRESS	(-997)
+
+/* Block trace entry. */
+typedef struct {
+  u32_t request;		/* request code; one of BTR_xxx */
+  u32_t size;			/* request size, ioctl request, or access */
+  u64_t position;		/* starting disk position */
+  u32_t flags;			/* transfer flags */
+  i32_t result;			/* request result; OK, bytes, or error */
+  u32_t start_time;		/* request service start time (us) */
+  u32_t finish_time;		/* request service completion time (us) */
+} btrace_entry;			/* (32 bytes) */
+
+/* This is the number of btrace_entry structures copied out at once using the
+ * BIOCTRACEGET ioctl call.
+ */
+#define BTBUF_SIZE	1024
+
+#endif /* _MINIX_BTRACE_H */
diff -ruNp srclimpio/minix/include/minix/minix/callnr.h proj/minix/include/minix/minix/callnr.h
--- srclimpio/minix/include/minix/minix/callnr.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/callnr.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,157 @@
+/* This header file defines the calls to PM and VFS. */
+#ifndef _MINIX_CALLNR_H
+#define _MINIX_CALLNR_H
+
+/*===========================================================================*
+ *				Calls to PM				     *
+ *===========================================================================*/
+
+#define PM_BASE			0x000
+
+#define IS_PM_CALL(type)	(((type) & ~0xff) == PM_BASE)
+
+/* Message type 0 is traditionally reserved. */
+#define PM_EXIT			(PM_BASE + 1)
+#define PM_FORK			(PM_BASE + 2)
+#define PM_WAITPID		(PM_BASE + 3)
+#define PM_GETPID		(PM_BASE + 4)
+#define PM_SETUID		(PM_BASE + 5)
+#define PM_GETUID		(PM_BASE + 6)
+#define PM_STIME		(PM_BASE + 7)
+#define PM_PTRACE		(PM_BASE + 8)
+#define PM_SETGROUPS		(PM_BASE + 9)
+#define PM_GETGROUPS		(PM_BASE + 10)
+#define PM_KILL			(PM_BASE + 11)
+#define PM_SETGID		(PM_BASE + 12)
+#define PM_GETGID		(PM_BASE + 13)
+#define PM_EXEC			(PM_BASE + 14)
+#define PM_SETSID		(PM_BASE + 15)
+#define PM_GETPGRP		(PM_BASE + 16)
+#define PM_ITIMER		(PM_BASE + 17)
+#define PM_GETMCONTEXT		(PM_BASE + 18)
+#define PM_SETMCONTEXT		(PM_BASE + 19)
+#define PM_SIGACTION		(PM_BASE + 20)
+#define PM_SIGSUSPEND		(PM_BASE + 21)
+#define PM_SIGPENDING		(PM_BASE + 22)
+#define PM_SIGPROCMASK		(PM_BASE + 23)
+#define PM_SIGRETURN		(PM_BASE + 24)
+#define PM_SYSUNAME		(PM_BASE + 25)
+#define PM_GETPRIORITY		(PM_BASE + 26)
+#define PM_SETPRIORITY		(PM_BASE + 27)
+#define PM_GETTIMEOFDAY		(PM_BASE + 28)
+#define PM_SETEUID		(PM_BASE + 29)
+#define PM_SETEGID		(PM_BASE + 30)
+#define PM_ISSETUGID		(PM_BASE + 31)
+#define PM_GETSID		(PM_BASE + 32)
+#define PM_CLOCK_GETRES		(PM_BASE + 33)
+#define PM_CLOCK_GETTIME	(PM_BASE + 34)
+#define PM_CLOCK_SETTIME	(PM_BASE + 35)
+#define PM_GETRUSAGE		(PM_BASE + 36)
+#define PM_REBOOT		(PM_BASE + 37)
+#define PM_SVRCTL		(PM_BASE + 38)
+#define PM_SPROF		(PM_BASE + 39)
+#define PM_CPROF		(PM_BASE + 40)
+#define PM_SRV_FORK		(PM_BASE + 41)
+#define PM_SRV_KILL		(PM_BASE + 42)
+#define PM_EXEC_NEW		(PM_BASE + 43)
+#define PM_EXEC_RESTART		(PM_BASE + 44)
+#define PM_GETEPINFO		(PM_BASE + 45)
+#define PM_GETPROCNR		(PM_BASE + 46)
+#define PM_GETSYSINFO		(PM_BASE + 47)
+#define PM_MYCALL               (PM_BASE + 48)
+#define PM_MYCALLS              (PM_BASE + 49)
+#define PM_MUTEX_INIT		(PM_BASE + 50)
+#define PM_MUTEX_DESTROY	(PM_BASE + 51)
+#define PM_MUTEX_LOCK		(PM_BASE + 52)
+#define PM_MUTEX_UNLOCK		(PM_BASE + 53)
+#define PM_CV_INIT		(PM_BASE + 54)
+#define PM_CV_DESTROY		(PM_BASE + 55)
+#define PM_CV_WAIT		(PM_BASE + 56)
+#define PM_CV_SIGNAL		(PM_BASE + 57)
+#define PM_CV_BROADCAST		(PM_BASE + 58)
+ 
+#define NR_PM_CALLS		59	/* highest number from base plus one */
+
+/*===========================================================================*
+ *				Calls to VFS				     *
+ *===========================================================================*/
+
+#define VFS_BASE		0x100
+
+#define IS_VFS_CALL(type)	(((type) & ~0xff) == VFS_BASE)
+
+#define VFS_READ		(VFS_BASE + 0)
+#define VFS_WRITE		(VFS_BASE + 1)
+#define VFS_LSEEK		(VFS_BASE + 2)
+#define VFS_OPEN		(VFS_BASE + 3)
+#define VFS_CREAT		(VFS_BASE + 4)
+#define VFS_CLOSE		(VFS_BASE + 5)
+#define VFS_LINK		(VFS_BASE + 6)
+#define VFS_UNLINK		(VFS_BASE + 7)
+#define VFS_CHDIR		(VFS_BASE + 8)
+#define VFS_MKDIR		(VFS_BASE + 9)
+#define VFS_MKNOD		(VFS_BASE + 10)
+#define VFS_CHMOD		(VFS_BASE + 11)
+#define VFS_CHOWN		(VFS_BASE + 12)
+#define VFS_MOUNT		(VFS_BASE + 13)
+#define VFS_UMOUNT		(VFS_BASE + 14)
+#define VFS_ACCESS		(VFS_BASE + 15)
+#define VFS_SYNC		(VFS_BASE + 16)
+#define VFS_RENAME		(VFS_BASE + 17)
+#define VFS_RMDIR		(VFS_BASE + 18)
+#define VFS_SYMLINK		(VFS_BASE + 19)
+#define VFS_READLINK		(VFS_BASE + 20)
+#define VFS_STAT		(VFS_BASE + 21)
+#define VFS_FSTAT		(VFS_BASE + 22)
+#define VFS_LSTAT		(VFS_BASE + 23)
+#define VFS_IOCTL		(VFS_BASE + 24)
+#define VFS_FCNTL		(VFS_BASE + 25)
+#define VFS_PIPE2		(VFS_BASE + 26)
+#define VFS_UMASK		(VFS_BASE + 27)
+#define VFS_CHROOT		(VFS_BASE + 28)
+#define VFS_GETDENTS		(VFS_BASE + 29)
+#define VFS_SELECT		(VFS_BASE + 30)
+#define VFS_FCHDIR		(VFS_BASE + 31)
+#define VFS_FSYNC		(VFS_BASE + 32)
+#define VFS_TRUNCATE		(VFS_BASE + 33)
+#define VFS_FTRUNCATE		(VFS_BASE + 34)
+#define VFS_FCHMOD		(VFS_BASE + 35)
+#define VFS_FCHOWN		(VFS_BASE + 36)
+#define VFS_UTIMENS		(VFS_BASE + 37)
+#define VFS_VMCALL		(VFS_BASE + 38)
+#define VFS_GETVFSSTAT		(VFS_BASE + 39)
+#define VFS_STATVFS1 	 	(VFS_BASE + 40)
+#define VFS_FSTATVFS1		(VFS_BASE + 41)
+#define VFS_GETRUSAGE		(VFS_BASE + 42)
+#define VFS_SVRCTL		(VFS_BASE + 43)
+#define VFS_GCOV_FLUSH		(VFS_BASE + 44)
+#define VFS_MAPDRIVER		(VFS_BASE + 45)
+#define VFS_COPYFD		(VFS_BASE + 46)
+#define VFS_CHECKPERMS		(VFS_BASE + 47)
+#define VFS_GETSYSINFO		(VFS_BASE + 48)
+
+#define NR_VFS_CALLS		49	/* highest number from base plus one */
+
+/*===========================================================================*
+ *                              Calls to SYNC                                 
+* 
+*===========================================================================*/
+
+#define SYNC_BASE                0x1700
+
+#define IS_SYNC_CALL(type)       (((type) & ~0xff) == SYNC_BASE)
+
+#define SYNC_MUTEX_INIT         (SYNC_BASE + 0)
+#define SYNC_MUTEX_DESTROY      (SYNC_BASE + 1)
+#define SYNC_MUTEX_LOCK         (SYNC_BASE + 2)
+#define SYNC_MUTEX_UNLOCK	(SYNC_BASE + 3)
+#define SYNC_CV_INIT	        (SYNC_BASE + 4)
+#define SYNC_CV_DESTROY		(SYNC_BASE + 5)
+#define SYNC_CV_WAIT		(SYNC_BASE + 6)
+#define SYNC_CV_SIGNAL		(SYNC_BASE + 7)
+#define SYNC_CV_BROADCAST	(SYNC_BASE + 8)
+
+#define NR_SYNC_CALLS            9      /* highest number from base plus one */
+
+
+#endif /* !_MINIX_CALLNR_H */
diff -ruNp srclimpio/minix/include/minix/minix/chardriver.h proj/minix/include/minix/minix/chardriver.h
--- srclimpio/minix/include/minix/minix/chardriver.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/chardriver.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,36 @@
+#ifndef _MINIX_CHARDRIVER_H
+#define _MINIX_CHARDRIVER_H
+
+#include <minix/driver.h>
+
+typedef unsigned int cdev_id_t;
+
+/* Entry points into the device dependent code of character drivers. */
+struct chardriver {
+  int (*cdr_open)(devminor_t minor, int access, endpoint_t user_endpt);
+  int (*cdr_close)(devminor_t minor);
+  ssize_t (*cdr_read)(devminor_t minor, u64_t position, endpoint_t endpt,
+	cp_grant_id_t grant, size_t size, int flags, cdev_id_t id);
+  ssize_t (*cdr_write)(devminor_t minor, u64_t position, endpoint_t endpt,
+	cp_grant_id_t grant, size_t size, int flags, cdev_id_t id);
+  int (*cdr_ioctl)(devminor_t minor, unsigned long request, endpoint_t endpt,
+	cp_grant_id_t grant, int flags, endpoint_t user_endpt, cdev_id_t id);
+  int (*cdr_cancel)(devminor_t minor, endpoint_t endpt, cdev_id_t id);
+  int (*cdr_select)(devminor_t minor, unsigned int ops, endpoint_t endpt);
+  void (*cdr_intr)(unsigned int mask);
+  void (*cdr_alarm)(clock_t stamp);
+  void (*cdr_other)(message *m_ptr, int ipc_status);
+};
+
+/* Functions defined by libchardriver. */
+void chardriver_announce(void);
+int chardriver_get_minor(message *m, devminor_t *minor);
+void chardriver_process(struct chardriver *cdp, message *m_ptr,
+	int ipc_status);
+void chardriver_terminate(void);
+void chardriver_task(struct chardriver *cdp);
+
+void chardriver_reply_task(endpoint_t endpt, cdev_id_t id, int r);
+void chardriver_reply_select(endpoint_t endpt, devminor_t minor, int ops);
+
+#endif /* _MINIX_CHARDRIVER_H */
diff -ruNp srclimpio/minix/include/minix/minix/clkconf.h proj/minix/include/minix/minix/clkconf.h
--- srclimpio/minix/include/minix/minix/clkconf.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/clkconf.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,18 @@
+#ifndef _CLKCONF_H
+#define _CLKCONF_H
+
+/* Clock configuration */
+#define CM_FCLKEN1_CORE 0xA00
+#define CM_ICLKEN1_CORE 0xA10
+#define CM_FCLKEN_WKUP 0xC00
+#define CM_ICLKEN_WKUP 0xC10
+
+#define CM_PER_I2C2_CLKCTRL 0x044
+#define CM_PER_I2C1_CLKCTRL 0x048
+#define CM_WKUP_I2C0_CLKCTRL 0x4B8
+
+int clkconf_init();
+int clkconf_set(u32_t clk, u32_t mask, u32_t value);
+int clkconf_release();
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/com.h proj/minix/include/minix/minix/com.h
--- srclimpio/minix/include/minix/minix/com.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/com.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,976 @@
+/* This file defines constants for use in message communication (mostly)
+ * between system processes.
+ *
+ * A number of protocol message request and response types are defined. For
+ * debugging purposes, each protocol is assigned its own unique number range.
+ * The following such message type ranges have been allocated:
+ *
+ *     0x00 -   0xFF	Process Manager (PM) requests (see callnr.h)
+ *    0x100 -  0x1FF	Virtual File System (VFS) requests (see callnr.h)
+ *    0x200 -  0x2FF	Data link layer requests and responses
+ *    0x300 -  0x3FF	Bus controller requests and responses
+ *    0x400 -  0x4FF	Character device requests and responses
+ *    0x500 -  0x5FF	Block device requests and responses
+ *    0x600 -  0x6FF	Kernel calls
+ *    0x700 -  0x7FF	Reincarnation Server (RS) requests
+ *    0x800 -  0x8FF	Data Store (DS) requests
+ *    0x900 -  0x9FF	Requests from PM to VFS, and responses
+ *    0xA00 -  0xAFF	Requests from VFS to file systems (see vfsif.h)
+ *    0xB00 -  0xBFF	Transaction IDs from VFS to file systems (see vfsif.h)
+ *    0xC00 -  0xCFF	Virtual Memory (VM) requests
+ *    0xD00 -  0xDFF	IPC server requests
+ *    0xE00 -  0xEFF	Common system messages (e.g. system signals)
+ *    0xF00 -  0xFFF	Scheduling messages
+ *   0x1000 - 0x10FF	Notify messages
+ *   0x1100 - 0x11FF	USB  
+ *   0x1200 - 0x12FF	Devman
+ *   0x1300 - 0x13FF	TTY requests
+ *   0x1400 - 0x14FF	Real Time Clock requests and responses
+ *   0x1500 - 0x15FF	Input server messages
+ *   0x1600 - 0x16FF	VirtualBox (VBOX) requests (see vboxif.h)
+ *   0x1700 - 0x17FF	Variables de sincronizacion
+ *
+ * Zero and negative values are widely used for OK and error responses.
+ */
+
+#ifndef _MINIX_COM_H
+#define _MINIX_COM_H 
+
+/*===========================================================================*
+ *            	Process numbers of processes in the system image	     *
+ *===========================================================================*/
+
+/* Kernel tasks. These all run in the same address space. */
+#define ASYNCM	((endpoint_t) -5) /* notifies about finished async sends */
+#define IDLE    ((endpoint_t) -4) /* runs when no one else can run */
+#define CLOCK  	((endpoint_t) -3) /* alarms and other clock functions */
+#define SYSTEM  ((endpoint_t) -2) /* request system functionality */
+#define KERNEL  ((endpoint_t) -1) /* pseudo-process for IPC and scheduling */
+#define HARDWARE     KERNEL	/* for hardware interrupt handlers */
+
+/* Number of tasks. Note that NR_PROCS is defined in <minix/config.h>. */
+#define MAX_NR_TASKS	1023
+#define NR_TASKS	  5 
+
+/* User-space processes, that is, device drivers, servers, and INIT. */
+#define PM_PROC_NR   ((endpoint_t) 0)	/* process manager */
+#define VFS_PROC_NR  ((endpoint_t) 1)	/* file system */
+#define RS_PROC_NR   ((endpoint_t) 2)  	/* reincarnation server */
+#define MEM_PROC_NR  ((endpoint_t) 3)  	/* memory driver (RAM disk, null, etc.) */
+#define SCHED_PROC_NR ((endpoint_t) 4)	/* scheduler */
+#define TTY_PROC_NR  ((endpoint_t) 5)	/* terminal (TTY) driver */
+#define DS_PROC_NR   ((endpoint_t) 6)   /* data store server */
+#define MFS_PROC_NR  ((endpoint_t) 7)   /* minix root filesystem */
+#define VM_PROC_NR   ((endpoint_t) 8)   /* memory server */
+#define PFS_PROC_NR  ((endpoint_t) 9)  /* pipe filesystem */
+#define SYNC_PROC_NR ((endpoint_t) 10)  /* syncvar */
+
+#define LAST_SPECIAL_PROC_NR	11	/* An untyped version for computation in macros.*/
+
+#define INIT_PROC_NR ((endpoint_t) LAST_SPECIAL_PROC_NR)  /* init
+                                                        -- goes multiuser */
+#define NR_BOOT_MODULES (INIT_PROC_NR+1)
+
+/* Root system process and root user process. */
+#define ROOT_SYS_PROC_NR  RS_PROC_NR
+#define ROOT_USR_PROC_NR  INIT_PROC_NR
+
+/*===========================================================================*
+ *                	   Kernel notification types                         *
+ *===========================================================================*/
+
+/* Kernel notification types. In principle, these can be sent to any process,
+ * so make sure that these types do not interfere with other message types.
+ * Notifications are prioritized because of the way they are unhold() and
+ * blocking notifications are delivered. The lowest numbers go first. The
+ * offset are used for the per-process notification bit maps. 
+ */
+#define NOTIFY_MESSAGE		  0x1000
+/* FIXME the old is_notify(a) should be replaced by is_ipc_notify(status). */
+#define is_ipc_notify(ipc_status) (IPC_STATUS_CALL(ipc_status) == NOTIFY)
+#define is_notify(a)		  ((unsigned) ((a) - NOTIFY_MESSAGE) < 0x100)
+#define is_ipc_asynch(ipc_status) \
+    (is_ipc_notify(ipc_status) || IPC_STATUS_CALL(ipc_status) == SENDA)
+
+/*===========================================================================*
+ *                Messages for BUS controller drivers 			     *
+ *===========================================================================*/
+#define BUSC_RQ_BASE	0x300	/* base for request types */
+#define BUSC_RS_BASE	0x380	/* base for response types */
+
+#define BUSC_PCI_INIT		(BUSC_RQ_BASE + 0)	/* First message to
+							 * PCI driver
+							 */
+#define BUSC_PCI_FIRST_DEV	(BUSC_RQ_BASE + 1)	/* Get index (and
+							 * vid/did) of the
+							 * first PCI device
+							 */
+#define BUSC_PCI_NEXT_DEV	(BUSC_RQ_BASE + 2)	/* Get index (and
+							 * vid/did) of the
+							 * next PCI device
+							 */
+#define BUSC_PCI_FIND_DEV	(BUSC_RQ_BASE + 3)	/* Get index of a
+							 * PCI device based on
+							 * bus/dev/function
+							 */
+#define BUSC_PCI_IDS		(BUSC_RQ_BASE + 4)	/* Get vid/did from an
+							 * index
+							 */
+#define BUSC_PCI_RESERVE	(BUSC_RQ_BASE + 7)	/* Reserve a PCI dev */
+#define BUSC_PCI_ATTR_R8	(BUSC_RQ_BASE + 8)	/* Read 8-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_R16	(BUSC_RQ_BASE + 9)	/* Read 16-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_R32	(BUSC_RQ_BASE + 10)	/* Read 32-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W8	(BUSC_RQ_BASE + 11)	/* Write 8-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W16	(BUSC_RQ_BASE + 12)	/* Write 16-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_ATTR_W32	(BUSC_RQ_BASE + 13)	/* Write 32-bit
+							 * attribute value
+							 */
+#define BUSC_PCI_RESCAN		(BUSC_RQ_BASE + 14)	/* Rescan bus */
+#define BUSC_PCI_DEV_NAME_S	(BUSC_RQ_BASE + 15)	/* Get the name of a
+							 * PCI device
+							 * (safecopy)
+							 */
+#define BUSC_PCI_SLOT_NAME_S	(BUSC_RQ_BASE + 16)	/* Get the name of a
+							 * PCI slot (safecopy)
+							 */
+#define BUSC_PCI_SET_ACL	(BUSC_RQ_BASE + 17)	/* Set the ACL for a
+							 * driver (safecopy)
+							 */
+#define BUSC_PCI_DEL_ACL	(BUSC_RQ_BASE + 18)	/* Delete the ACL of a
+							 * driver 
+							 */
+#define BUSC_PCI_GET_BAR	(BUSC_RQ_BASE + 19)	/* Get Base Address
+							 * Register properties
+							 */
+#define IOMMU_MAP		(BUSC_RQ_BASE + 32)	/* Ask IOMMU to map
+							 * a segment of memory
+							 */
+
+#define BUSC_I2C_RESERVE	(BUSC_RQ_BASE + 64)	/* reserve i2c device */
+#define BUSC_I2C_EXEC		(BUSC_RQ_BASE + 65)	/* perform i2c action */
+
+/*===========================================================================*
+ *                  	   Messages for networking layer		     *
+ *===========================================================================*/
+
+/* Base type for data link layer requests and responses. */
+#define DL_RQ_BASE	0x200		
+#define DL_RS_BASE	0x280		
+
+#define IS_DL_RQ(type) (((type) & ~0x7f) == DL_RQ_BASE)
+#define IS_DL_RS(type) (((type) & ~0x7f) == DL_RS_BASE)
+
+/* Message types for data link layer requests. */
+#define DL_CONF		(DL_RQ_BASE + 0)
+#define DL_GETSTAT_S	(DL_RQ_BASE + 1)
+#define DL_WRITEV_S	(DL_RQ_BASE + 2)
+#define DL_READV_S	(DL_RQ_BASE + 3)
+
+/* Message type for data link layer replies. */
+#define DL_CONF_REPLY	(DL_RS_BASE + 0)
+#define DL_STAT_REPLY	(DL_RS_BASE + 1)
+#define DL_TASK_REPLY	(DL_RS_BASE + 2)
+
+/* Bits in 'flags' field of DL replies. */
+#  define DL_NOFLAGS		0x00
+#  define DL_PACK_SEND		0x01
+#  define DL_PACK_RECV		0x02
+
+/* Bits in 'DL_MODE' field of DL requests. */
+#  define DL_NOMODE		0x0
+#  define DL_PROMISC_REQ	0x1
+#  define DL_MULTI_REQ		0x2
+#  define DL_BROAD_REQ		0x4
+
+/*===========================================================================*
+ *                  SYSTASK request types and field names                    *
+ *===========================================================================*/
+
+/* System library calls are dispatched via a call vector, so be careful when 
+ * modifying the system call numbers. The numbers here determine which call
+ * is made from the call vector.
+ */ 
+#define KERNEL_CALL	0x600	/* base for kernel calls to SYSTEM */ 
+
+#  define SYS_FORK       (KERNEL_CALL + 0)	/* sys_fork() */
+#  define SYS_EXEC       (KERNEL_CALL + 1)	/* sys_exec() */
+#  define SYS_CLEAR	 (KERNEL_CALL + 2)	/* sys_clear() */
+#  define SYS_SCHEDULE 	 (KERNEL_CALL + 3)	/* sys_schedule() */
+#  define SYS_PRIVCTL    (KERNEL_CALL + 4)	/* sys_privctl() */
+#  define SYS_TRACE      (KERNEL_CALL + 5)	/* sys_trace() */
+#  define SYS_KILL       (KERNEL_CALL + 6)	/* sys_kill() */
+
+#  define SYS_GETKSIG    (KERNEL_CALL + 7)	/* sys_getsig() */
+#  define SYS_ENDKSIG    (KERNEL_CALL + 8)	/* sys_endsig() */
+#  define SYS_SIGSEND    (KERNEL_CALL + 9)	/* sys_sigsend() */
+#  define SYS_SIGRETURN  (KERNEL_CALL + 10)	/* sys_sigreturn() */
+
+#  define SYS_MEMSET     (KERNEL_CALL + 13)	/* sys_memset() */
+
+#  define SYS_UMAP       (KERNEL_CALL + 14)	/* sys_umap() */
+#  define SYS_VIRCOPY    (KERNEL_CALL + 15)	/* sys_vircopy() */
+#  define SYS_PHYSCOPY   (KERNEL_CALL + 16) 	/* sys_physcopy() */
+#  define SYS_UMAP_REMOTE (KERNEL_CALL + 17)	/* sys_umap_remote() */
+#  define SYS_VUMAP      (KERNEL_CALL + 18)	/* sys_vumap() */
+
+#  define SYS_IRQCTL     (KERNEL_CALL + 19)	/* sys_irqctl() */
+#  define SYS_INT86      (KERNEL_CALL + 20)	/* sys_int86() */
+#  define SYS_DEVIO      (KERNEL_CALL + 21)	/* sys_devio() */
+#  define SYS_SDEVIO     (KERNEL_CALL + 22)	/* sys_sdevio() */
+#  define SYS_VDEVIO     (KERNEL_CALL + 23)	/* sys_vdevio() */
+
+#  define SYS_SETALARM	 (KERNEL_CALL + 24)	/* sys_setalarm() */
+#  define SYS_TIMES	 (KERNEL_CALL + 25)	/* sys_times() */
+#  define SYS_GETINFO    (KERNEL_CALL + 26) 	/* sys_getinfo() */
+#  define SYS_ABORT      (KERNEL_CALL + 27)	/* sys_abort() */
+#  define SYS_IOPENABLE  (KERNEL_CALL + 28)	/* sys_enable_iop() */
+#  define SYS_SAFECOPYFROM (KERNEL_CALL + 31)	/* sys_safecopyfrom() */
+#  define SYS_SAFECOPYTO   (KERNEL_CALL + 32)	/* sys_safecopyto() */
+#  define SYS_VSAFECOPY  (KERNEL_CALL + 33)	/* sys_vsafecopy() */
+#  define SYS_SETGRANT   (KERNEL_CALL + 34)	/* sys_setgrant() */
+#  define SYS_READBIOS   (KERNEL_CALL + 35)	/* sys_readbios() */
+
+#  define SYS_SPROF      (KERNEL_CALL + 36)     /* sys_sprof() */ 
+#  define SYS_CPROF      (KERNEL_CALL + 37)     /* sys_cprof() */
+#  define SYS_PROFBUF    (KERNEL_CALL + 38)     /* sys_profbuf() */
+
+#  define SYS_STIME      (KERNEL_CALL + 39)	/* sys_stime() */
+#  define SYS_SETTIME    (KERNEL_CALL + 40)	/* sys_settime() */
+
+#  define SYS_VMCTL      (KERNEL_CALL + 43)	/* sys_vmctl() */
+
+#  define SYS_DIAGCTL    (KERNEL_CALL + 44)	/* sys_diagctl() */
+
+#  define SYS_VTIMER     (KERNEL_CALL + 45)	/* sys_vtimer() */
+#  define SYS_RUNCTL     (KERNEL_CALL + 46)	/* sys_runctl() */
+#  define SYS_GETMCONTEXT (KERNEL_CALL + 50)    /* sys_getmcontext() */
+#  define SYS_SETMCONTEXT (KERNEL_CALL + 51)    /* sys_setmcontext() */
+
+#  define SYS_UPDATE	 (KERNEL_CALL + 52)	/* sys_update() */
+#  define SYS_EXIT	 (KERNEL_CALL + 53)	/* sys_exit() */
+
+#  define SYS_SCHEDCTL (KERNEL_CALL + 54)	/* sys_schedctl() */
+#  define SYS_STATECTL (KERNEL_CALL + 55)	/* sys_statectl() */
+
+#  define SYS_SAFEMEMSET (KERNEL_CALL + 56)	/* sys_safememset() */
+
+#  define SYS_PADCONF (KERNEL_CALL + 57)	/* sys_padconf() */
+#  define SYS_SAMPLE    (KERNEL_CALL + 58)      /* sys_sample() */
+
+/* Total */
+#define NR_SYS_CALLS	59	/* number of kernel calls */
+
+#define SYS_CALL_MASK_SIZE BITMAP_CHUNKS(NR_SYS_CALLS)
+
+/* Basic kernel calls allowed to every system process. */
+#define SYS_BASIC_CALLS \
+    SYS_EXIT, SYS_SAFECOPYFROM, SYS_SAFECOPYTO, SYS_VSAFECOPY, SYS_GETINFO, \
+    SYS_TIMES, SYS_SETALARM, SYS_SETGRANT, \
+    SYS_PROFBUF, SYS_DIAGCTL, SYS_STATECTL, SYS_SAFEMEMSET
+
+/* Field names for SYS_DEVIO, SYS_VDEVIO, SYS_SDEVIO. */
+#   define _DIO_INPUT		0x001
+#   define _DIO_OUTPUT		0x002
+#   define _DIO_DIRMASK		0x00f
+#   define _DIO_BYTE		0x010
+#   define _DIO_WORD		0x020
+#   define _DIO_LONG		0x030
+#   define _DIO_TYPEMASK	0x0f0
+#   define _DIO_SAFE		0x100
+#   define _DIO_SAFEMASK	0xf00
+#   define DIO_INPUT_BYTE	    (_DIO_INPUT|_DIO_BYTE)
+#   define DIO_INPUT_WORD	    (_DIO_INPUT|_DIO_WORD)
+#   define DIO_INPUT_LONG	    (_DIO_INPUT|_DIO_LONG)
+#   define DIO_OUTPUT_BYTE	    (_DIO_OUTPUT|_DIO_BYTE)
+#   define DIO_OUTPUT_WORD	    (_DIO_OUTPUT|_DIO_WORD)
+#   define DIO_OUTPUT_LONG	    (_DIO_OUTPUT|_DIO_LONG)
+#   define DIO_SAFE_INPUT_BYTE      (_DIO_INPUT|_DIO_BYTE|_DIO_SAFE)
+#   define DIO_SAFE_INPUT_WORD      (_DIO_INPUT|_DIO_WORD|_DIO_SAFE)
+#   define DIO_SAFE_INPUT_LONG      (_DIO_INPUT|_DIO_LONG|_DIO_SAFE)
+#   define DIO_SAFE_OUTPUT_BYTE     (_DIO_OUTPUT|_DIO_BYTE|_DIO_SAFE)
+#   define DIO_SAFE_OUTPUT_WORD     (_DIO_OUTPUT|_DIO_WORD|_DIO_SAFE)
+#   define DIO_SAFE_OUTPUT_LONG     (_DIO_OUTPUT|_DIO_LONG|_DIO_SAFE)
+
+/* Field names for SYS_IRQCTL. */
+#  define IRQ_SETPOLICY     1	/* manage a slot of the IRQ table */
+#  define IRQ_RMPOLICY      2	/* remove a slot of the IRQ table */
+#  define IRQ_ENABLE        3	/* enable interrupts */
+#  define IRQ_DISABLE       4	/* disable interrupts */
+#  define IRQ_REENABLE  0x001	/* reenable IRQ line after interrupt */
+#  define IRQ_BYTE      0x100	/* byte values */      
+#  define IRQ_WORD      0x200	/* word values */
+#  define IRQ_LONG      0x400	/* long values */
+
+#define CP_FLAG_TRY	0x01	/* do not transparently map */
+
+/* Field names for SYS_GETINFO. */
+#   define GET_KINFO	   0	/* get kernel information structure */
+#   define GET_IMAGE	   1	/* get system image table */
+#   define GET_PROCTAB	   2	/* get kernel process table */
+#   define GET_RANDOMNESS  3	/* get randomness buffer */
+#   define GET_MONPARAMS   4	/* get monitor parameters */
+#   define GET_KENV	   5	/* get kernel environment string */
+#   define GET_IRQHOOKS	   6	/* get the IRQ table */
+#   define GET_PRIVTAB	   8	/* get kernel privileges table */
+#   define GET_KADDRESSES  9	/* get various kernel addresses */
+#   define GET_SCHEDINFO  10	/* get scheduling queues */
+#   define GET_PROC 	  11	/* get process slot if given process */
+#   define GET_MACHINE 	  12	/* get machine information */
+#   define GET_LOCKTIMING 13	/* get lock()/unlock() latency timing */
+#   define GET_BIOSBUFFER 14	/* get a buffer for BIOS calls */
+#   define GET_LOADINFO   15	/* get load average information */
+#   define GET_IRQACTIDS  16	/* get the IRQ masks */
+#   define GET_PRIV	  17	/* get privilege structure */
+#   define GET_HZ	  18	/* get HZ value */
+#   define GET_WHOAMI	  19	/* get own name, endpoint, and privileges */
+#   define GET_RANDOMNESS_BIN 20 /* get one randomness bin */
+#   define GET_IDLETSC	  21	/* get cumulative idle time stamp counter */
+#   define GET_CPUINFO    23    /* get information about cpus */
+#   define GET_REGS	  24	/* get general process registers */
+#   define GET_RUSAGE	  25	/* get resource usage */
+
+/* Subfunctions for SYS_PRIVCTL */
+#define SYS_PRIV_ALLOW		1	/* Allow process to run */
+#define SYS_PRIV_DISALLOW	2	/* Disallow process to run */
+#define SYS_PRIV_SET_SYS	3	/* Set a system privilege structure */
+#define SYS_PRIV_SET_USER	4	/* Set a user privilege structure */
+#define SYS_PRIV_ADD_IO 	5	/* Add I/O range (struct io_range) */
+#define SYS_PRIV_ADD_MEM	6	/* Add memory range (struct mem_range)
+					 */
+#define SYS_PRIV_ADD_IRQ	7	/* Add IRQ */
+#define SYS_PRIV_QUERY_MEM	8	/* Verify memory privilege. */
+#define SYS_PRIV_UPDATE_SYS	9	/* Update a sys privilege structure. */
+#define SYS_PRIV_YIELD	       10	/* Allow process to run and suspend */
+
+/* Constants for exec. FIXME: these do not belong here. */
+#define PMEF_AUXVECTORS	20
+#define PMEF_EXECNAMELEN1 PATH_MAX
+
+/* Flags for PR_FORK_FLAGS. */
+#define PFF_VMINHIBIT	0x01	/* Don't schedule until release by VM. */
+
+/* SYS_SAFEMEMSET */
+#define SMS_DST		m2_i1	/* dst endpoint */
+#define SMS_GID		m2_i3	/* grant id */
+#define SMS_OFFSET	m2_l1	/* offset within grant */
+#define SMS_BYTES	m2_l2	/* bytes from offset */
+#define SMS_PATTERN	m2_i2	/* memset() pattern */
+
+/* Field names for SYS_VMCTL. */
+#define SVMCTL_WHO	m1_i1
+#define SVMCTL_PARAM	m1_i2	/* All SYS_VMCTL requests. */
+#define SVMCTL_VALUE	m1_i3
+#define	SVMCTL_MRG_TARGET	m2_i1	/* MEMREQ_GET reply: target process */
+#define	SVMCTL_MRG_ADDR		m2_i2	/* MEMREQ_GET reply: address */
+#define	SVMCTL_MRG_LENGTH	m2_i3	/* MEMREQ_GET reply: length */
+#define	SVMCTL_MRG_FLAG		m2_s1	/* MEMREQ_GET reply: flag */
+#define	SVMCTL_MRG_EP2		m2_l1	/* MEMREQ_GET reply: source process */
+#define	SVMCTL_MRG_ADDR2	m2_l2	/* MEMREQ_GET reply: source address */
+#define SVMCTL_MRG_REQUESTOR	m2_p1	/* MEMREQ_GET reply: requestor */
+#define SVMCTL_MAP_VIR_ADDR	m1_p1
+#define SVMCTL_PTROOT		m1_i3
+#define SVMCTL_PTROOT_V		m1_p1
+
+/* Reply message for VMCTL_KERN_PHYSMAP */
+#define SVMCTL_MAP_FLAGS	m2_i1	/* VMMF_* */
+#define SVMCTL_MAP_PHYS_ADDR	m2_l1
+#define SVMCTL_MAP_PHYS_LEN	m2_l2
+
+#define VMMF_UNCACHED		(1L << 0)
+#define VMMF_USER		(1L << 1)
+#define VMMF_WRITE		(1L << 2)
+#define VMMF_GLO		(1L << 3)
+
+/* Values for SVMCTL_PARAM. */
+#define VMCTL_CLEAR_PAGEFAULT	12
+#define VMCTL_GET_PDBR		13
+#define VMCTL_MEMREQ_GET 	14
+#define VMCTL_MEMREQ_REPLY	15
+#define VMCTL_NOPAGEZERO	18
+#define VMCTL_I386_KERNELLIMIT	19
+#define VMCTL_I386_INVLPG	25
+#define VMCTL_FLUSHTLB		26
+#define VMCTL_KERN_PHYSMAP	27
+#define VMCTL_KERN_MAP_REPLY	28
+#define VMCTL_SETADDRSPACE	29
+#define VMCTL_VMINHIBIT_SET	30
+#define VMCTL_VMINHIBIT_CLEAR	31
+#define VMCTL_CLEARMAPCACHE	32
+#define VMCTL_BOOTINHIBIT_CLEAR	33
+
+/* Codes and field names for SYS_DIAGCTL. */
+#define DIAGCTL_CODE_DIAG	1	/* Print diagnostics. */
+#define DIAGCTL_CODE_STACKTRACE	2	/* Print process stack. */
+#define DIAGCTL_CODE_REGISTER	3	/* Register for diagnostic signals */
+#define DIAGCTL_CODE_UNREGISTER	4	/* Unregister for diagnostic signals */
+#define DIAG_BUFSIZE	(80*25)
+
+/* Field names for SYS_VTIMER. */
+#define VT_WHICH	m2_i1	/* which timer to set/retrieve */
+#  define VT_VIRTUAL        1	/* the ITIMER_VIRTUAL timer */
+#  define VT_PROF           2	/* the ITIMER_PROF timer */
+#define VT_SET		m2_i2	/* 1 for setting a timer, 0 retrieval only */
+#define VT_VALUE	m2_l1	/* new/previous value of the timer */
+#define VT_ENDPT	m2_l2	/* process to set/retrieve the timer for */
+
+/* Field names for SYS_RUNCTL. */
+#define RC_ENDPT	m1_i1	/* which process to stop or resume */
+#define RC_ACTION	m1_i2	/* set or clear stop flag */
+#  define RC_STOP           0	/* stop the process */
+#  define RC_RESUME         1	/* clear the stop flag */
+#define RC_FLAGS	m1_i3	/* request flags */
+#  define RC_DELAY          1	/* delay stop if process is sending */
+
+/* Field names for SYS_UPDATE. */
+#define SYS_UPD_SRC_ENDPT	m1_i1	/* source endpoint */
+#define SYS_UPD_DST_ENDPT	m1_i2	/* destination endpoint */
+
+/* Subfunctions for SYS_STATECTL */
+#define SYS_STATE_CLEAR_IPC_REFS    1	/* clear IPC references */
+
+/* Subfunctions for SYS_SCHEDCTL */
+#  define SCHEDCTL_FLAG_KERNEL	1	/* mark kernel scheduler and remove 
+					 * RTS_NO_QUANTUM; otherwise caller is 
+					 * marked scheduler 
+					 */
+
+/* Field names for SYS_PADCONF */
+#define PADCONF_PADCONF		m2_i1	/* pad to configure */
+#define PADCONF_MASK		m2_i2	/* mask to apply */
+#define PADCONF_VALUE		m2_i3	/* value to write */
+
+/*===========================================================================*
+ *                Messages for the Reincarnation Server 		     *
+ *===========================================================================*/
+
+#define RS_RQ_BASE		0x700
+
+#define RS_UP		(RS_RQ_BASE + 0)	/* start system service */
+#define RS_DOWN		(RS_RQ_BASE + 1)	/* stop system service */
+#define RS_REFRESH	(RS_RQ_BASE + 2)	/* refresh system service */
+#define RS_RESTART	(RS_RQ_BASE + 3)	/* restart system service */
+#define RS_SHUTDOWN	(RS_RQ_BASE + 4)	/* alert about shutdown */
+#define RS_UPDATE	(RS_RQ_BASE + 5)	/* update system service */
+#define RS_CLONE	(RS_RQ_BASE + 6)	/* clone system service */
+#define RS_EDIT		(RS_RQ_BASE + 7)	/* edit system service */
+
+#define RS_LOOKUP	(RS_RQ_BASE + 8)	/* lookup server name */
+
+#define RS_GETSYSINFO	(RS_RQ_BASE + 9)	/* get system information */
+
+#define RS_INIT 	(RS_RQ_BASE + 20)	/* service init message */
+#define RS_LU_PREPARE	(RS_RQ_BASE + 21)	/* prepare to update message */
+
+/*===========================================================================*
+ *                Messages for the Data Store Server			     *
+ *===========================================================================*/
+
+#define DS_RQ_BASE		0x800
+
+#define DS_PUBLISH	(DS_RQ_BASE + 0)	/* publish data */
+#define DS_RETRIEVE	(DS_RQ_BASE + 1)	/* retrieve data by name */
+#define DS_SUBSCRIBE	(DS_RQ_BASE + 2)	/* subscribe to data updates */
+#define DS_CHECK	(DS_RQ_BASE + 3)	/* retrieve updated data */
+#define DS_DELETE	(DS_RQ_BASE + 4)	/* delete data */
+#define DS_SNAPSHOT	(DS_RQ_BASE + 5)	/* take a snapshot */
+#define DS_RETRIEVE_LABEL  (DS_RQ_BASE + 6)	/* retrieve label's name */
+#define DS_GETSYSINFO	(DS_RQ_BASE + 7)	/* get system information */
+
+/*===========================================================================*
+ *                Messages used between PM and VFS			     *
+ *===========================================================================*/
+
+#define VFS_PM_RQ_BASE	0x900
+#define VFS_PM_RS_BASE	0x980
+
+#define IS_VFS_PM_RQ(type) (((type) & ~0x7f) == VFS_PM_RQ_BASE)
+#define IS_VFS_PM_RS(type) (((type) & ~0x7f) == VFS_PM_RS_BASE)
+
+/* Requests from PM to VFS. */
+#define VFS_PM_INIT	(VFS_PM_RQ_BASE + 0)	/* Process table exchange */
+#define VFS_PM_SETUID	(VFS_PM_RQ_BASE + 1)	/* Set new user ID */
+#define VFS_PM_SETGID	(VFS_PM_RQ_BASE + 2)	/* Set group ID */
+#define VFS_PM_SETSID	(VFS_PM_RQ_BASE + 3)	/* Set session leader */
+#define VFS_PM_EXIT	(VFS_PM_RQ_BASE + 4)	/* Process exits */
+#define VFS_PM_DUMPCORE	(VFS_PM_RQ_BASE + 5)	/* Process is to dump core */
+#define VFS_PM_EXEC	(VFS_PM_RQ_BASE + 6)	/* Forwarded exec call */
+#define VFS_PM_FORK	(VFS_PM_RQ_BASE + 7)	/* Newly forked process */
+#define VFS_PM_SRV_FORK	(VFS_PM_RQ_BASE + 8)	/* fork for system services */
+#define VFS_PM_UNPAUSE	(VFS_PM_RQ_BASE + 9)	/* Interrupt process call */
+#define VFS_PM_REBOOT	(VFS_PM_RQ_BASE + 10)	/* System reboot */
+#define VFS_PM_SETGROUPS	(VFS_PM_RQ_BASE + 11)	/* Set groups */
+
+/* Replies from VFS to PM */
+#define VFS_PM_SETUID_REPLY	(VFS_PM_RS_BASE + 1)
+#define VFS_PM_SETGID_REPLY	(VFS_PM_RS_BASE + 2)
+#define VFS_PM_SETSID_REPLY	(VFS_PM_RS_BASE + 3)
+#define VFS_PM_EXIT_REPLY	(VFS_PM_RS_BASE + 4)
+#define VFS_PM_CORE_REPLY	(VFS_PM_RS_BASE + 5)
+#define VFS_PM_EXEC_REPLY	(VFS_PM_RS_BASE + 6)
+#define VFS_PM_FORK_REPLY	(VFS_PM_RS_BASE + 7)
+#define VFS_PM_SRV_FORK_REPLY	(VFS_PM_RS_BASE + 8)
+#define VFS_PM_UNPAUSE_REPLY	(VFS_PM_RS_BASE + 9)
+#define VFS_PM_REBOOT_REPLY	(VFS_PM_RS_BASE + 10)
+#define VFS_PM_SETGROUPS_REPLY	(VFS_PM_RS_BASE + 11)
+
+/* Standard parameters for all requests and replies, except PM_REBOOT */
+#  define VFS_PM_ENDPT		m7_i1	/* process endpoint */
+
+/* Additional parameters for PM_INIT */
+#  define VFS_PM_SLOT		m7_i2	/* process slot number */
+#  define VFS_PM_PID		m7_i3	/* process pid */
+
+/* Additional parameters for PM_SETUID and PM_SETGID */
+#  define VFS_PM_EID		m7_i2	/* effective user/group id */
+#  define VFS_PM_RID		m7_i3	/* real user/group id */
+
+/* Additional parameter for PM_SETGROUPS */
+#  define VFS_PM_GROUP_NO	m7_i2	/* number of groups */
+#  define VFS_PM_GROUP_ADDR	m7_p1	/* struct holding group data */
+
+/* Additional parameters for PM_EXEC */
+#  define VFS_PM_PATH		m7_p1	/* executable */
+#  define VFS_PM_PATH_LEN	m7_i2	/* length of path including
+					 * terminating null character
+					 */
+#  define VFS_PM_FRAME		m7_p2	/* arguments and environment */
+#  define VFS_PM_FRAME_LEN	m7_i3	/* size of frame */
+#  define VFS_PM_PS_STR		m7_i5	/* ps_strings pointer */
+
+/* Additional parameters for PM_EXEC_REPLY and PM_CORE_REPLY */
+#  define VFS_PM_STATUS		m7_i2	/* OK or failure */
+#  define VFS_PM_PC		m7_p1	/* program counter */
+#  define VFS_PM_NEWSP		m7_p2	/* possibly-changed stack ptr */
+#  define VFS_PM_NEWPS_STR	m7_i5	/* possibly-changed ps_strings ptr */
+
+/* Additional parameters for PM_FORK and PM_SRV_FORK */
+#  define VFS_PM_PENDPT		m7_i2	/* parent process endpoint */
+#  define VFS_PM_CPID		m7_i3	/* child pid */
+#  define VFS_PM_REUID		m7_i4	/* real and effective uid */
+#  define VFS_PM_REGID		m7_i5	/* real and effective gid */
+
+/* Additional parameters for PM_DUMPCORE */
+#  define VFS_PM_TERM_SIG	m7_i2	/* process's termination signal */
+
+/*===========================================================================*
+ *                Messages used from VFS to file servers		     *
+ *===========================================================================*/
+
+#define FS_BASE		0xA00		/* Requests sent by VFS to filesystem
+					 * implementations. See <minix/vfsif.h>
+					 */
+
+/*===========================================================================*
+ *                Common requests and miscellaneous field names		     *
+ *===========================================================================*/
+
+#define COMMON_RQ_BASE		0xE00
+
+/* Field names for system signals (sent by a signal manager). */
+#define SIGS_SIGNAL_RECEIVED (COMMON_RQ_BASE+0)
+
+/* Common request to all processes: gcov data. */
+#define COMMON_REQ_GCOV_DATA (COMMON_RQ_BASE+1)
+
+/* Common fault injection ctl request to all processes. */
+#define COMMON_REQ_FI_CTL (COMMON_RQ_BASE+2)
+
+/*===========================================================================*
+ *                Messages for VM server				     *
+ *===========================================================================*/
+#define VM_RQ_BASE		0xC00
+
+/* Calls from PM */
+#define VM_EXIT			(VM_RQ_BASE+0)
+#	define VME_ENDPOINT		m1_i1
+#define VM_FORK			(VM_RQ_BASE+1)
+#	define VMF_ENDPOINT		m1_i1
+#	define VMF_SLOTNO		m1_i2
+#	define VMF_CHILD_ENDPOINT	m1_i3	/* result */
+#define VM_BRK			(VM_RQ_BASE+2)
+#define VM_EXEC_NEWMEM		(VM_RQ_BASE+3)
+#	define VMEN_ENDPOINT		m1_i1
+#	define VMEN_ARGSPTR		m1_p1
+#	define VMEN_ARGSSIZE		m1_i2
+#	define VMEN_FLAGS		m1_i3	/* result */
+#	define VMEN_STACK_TOP		m1_p2	/* result */
+#define VM_WILLEXIT		(VM_RQ_BASE+5)
+#	define VMWE_ENDPOINT		m1_i1
+
+/* General calls. */
+#define VM_MMAP			(VM_RQ_BASE+10)
+
+#define VM_MUNMAP		(VM_RQ_BASE+17)
+#	define VMUM_ADDR		m_mmap.addr
+#	define VMUM_LEN			m_mmap.len
+
+/* to VM: inform VM about a region of memory that is used for
+ * bus-master DMA
+ */
+#define VM_ADDDMA	(VM_RQ_BASE+12)
+#	define VMAD_EP			m2_i1
+#	define VMAD_START		m2_l1
+#	define VMAD_SIZE		m2_l2
+
+/* to VM: inform VM that a region of memory that is no longer
+ * used for bus-master DMA
+ */
+#define VM_DELDMA       (VM_RQ_BASE+13)
+#	define VMDD_EP			m2_i1
+#	define VMDD_START		m2_l1
+#	define VMDD_SIZE		m2_l2
+
+/* to VM: ask VM for a region of memory that should not
+ * be used for bus-master DMA any longer
+ */
+#define VM_GETDMA       (VM_RQ_BASE+14)
+#	define VMGD_PROCP		m2_i1
+#	define VMGD_BASEP		m2_l1
+#	define VMGD_SIZEP		m2_l2
+
+#define VM_MAP_PHYS		(VM_RQ_BASE+15)
+
+#define VM_UNMAP_PHYS		(VM_RQ_BASE+16)
+
+/* To VM: map in cache block by FS */
+#define VM_MAPCACHEPAGE		(VM_RQ_BASE+26)
+
+/* To VM: identify cache block in FS */
+#define VM_SETCACHEPAGE		(VM_RQ_BASE+27)
+
+/* To VM: clear all cache blocks for a device */
+#define VM_CLEARCACHE		(VM_RQ_BASE+28)
+
+/* To VFS: fields for request from VM. */
+#	define VFS_VMCALL_REQ		m10_i1
+#	define VFS_VMCALL_FD		m10_i2
+#	define VFS_VMCALL_REQID		m10_i3
+#	define VFS_VMCALL_ENDPOINT	m10_i4
+#	define VFS_VMCALL_OFFSET	m10_ull1
+#	define VFS_VMCALL_LENGTH	m10_l3
+
+/* Request codes to from VM to VFS */
+#define VMVFSREQ_FDLOOKUP		101
+#define VMVFSREQ_FDCLOSE		102
+#define VMVFSREQ_FDIO			103
+
+/* Calls from VFS. */
+#define VM_VFS_REPLY		(VM_RQ_BASE+30)
+#	define VMV_ENDPOINT		m10_i1
+#	define VMV_RESULT		m10_i2
+#	define VMV_REQID		m10_i3
+#	define VMV_DEV			m10_i4
+#	define VMV_INO			m10_l1
+#	define VMV_FD			m10_l2
+#	define VMV_SIZE_PAGES		m10_l3
+
+#define VM_REMAP		(VM_RQ_BASE+33)
+
+#define VM_SHM_UNMAP		(VM_RQ_BASE+34)
+
+#define VM_GETPHYS		(VM_RQ_BASE+35)
+
+#define VM_GETREF		(VM_RQ_BASE+36)
+
+#define VM_RS_SET_PRIV		(VM_RQ_BASE+37)
+#	define VM_RS_NR			m2_i1
+#	define VM_RS_BUF		m2_l1
+#	define VM_RS_SYS		m2_i2
+
+#define VM_QUERY_EXIT		(VM_RQ_BASE+38)
+
+#define VM_NOTIFY_SIG		(VM_RQ_BASE+39)
+#	define VM_NOTIFY_SIG_ENDPOINT	m1_i1
+#	define VM_NOTIFY_SIG_IPC	m1_i2
+
+#define VM_INFO			(VM_RQ_BASE+40)
+
+/* VM_INFO 'what' values. */
+#define VMIW_STATS			1
+#define VMIW_USAGE			2
+#define VMIW_REGION			3
+
+#define VM_RS_UPDATE		(VM_RQ_BASE+41)
+
+#define VM_RS_MEMCTL		(VM_RQ_BASE+42)
+#	define VM_RS_CTL_ENDPT		m1_i1
+#	define VM_RS_CTL_REQ		m1_i2
+#		define VM_RS_MEM_PIN	    0	/* pin memory */
+#		define VM_RS_MEM_MAKE_VM    1	/* make VM instance */
+
+#define VM_WATCH_EXIT		(VM_RQ_BASE+43)
+
+#define VM_REMAP_RO		(VM_RQ_BASE+44)
+/* same args as VM_REMAP */
+
+#define VM_PROCCTL		(VM_RQ_BASE+45)
+#define VMPCTL_PARAM		m9_l1
+#define VMPCTL_WHO		m9_l2
+#define VMPCTL_M1		m9_l3
+#define VMPCTL_LEN		m9_l4
+#define VMPCTL_FLAGS		m9_l5
+
+#define VMPPARAM_CLEAR		1	/* values for VMPCTL_PARAM */
+#define VMPPARAM_HANDLEMEM	2
+
+#define VM_VFS_MMAP             (VM_RQ_BASE+46)
+
+#define VM_GETRUSAGE		(VM_RQ_BASE+47)
+
+/* Total. */
+#define NR_VM_CALLS				48
+#define VM_CALL_MASK_SIZE			BITMAP_CHUNKS(NR_VM_CALLS)
+
+/* not handled as a normal VM call, thus at the end of the reserved rage */
+#define VM_PAGEFAULT		(VM_RQ_BASE+0xff)
+#	define VPF_ADDR		m1_i1
+#	define VPF_FLAGS	m1_i2
+
+/* Basic vm calls allowed to every process. */
+#define VM_BASIC_CALLS \
+    VM_BRK, VM_MMAP, VM_MUNMAP, VM_MAP_PHYS, VM_UNMAP_PHYS, VM_INFO, \
+    VM_GETRUSAGE
+
+/*===========================================================================*
+ *                Messages for IPC server				     *
+ *===========================================================================*/
+#define IPC_BASE	0xD00
+
+/* Shared Memory */
+#define IPC_SHMGET	(IPC_BASE+1)
+#define IPC_SHMAT	(IPC_BASE+2)
+#define IPC_SHMDT	(IPC_BASE+3)
+#define IPC_SHMCTL	(IPC_BASE+4)
+
+/* Semaphore */
+#define IPC_SEMGET	(IPC_BASE+5)
+#define IPC_SEMCTL	(IPC_BASE+6)
+#define IPC_SEMOP	(IPC_BASE+7)
+
+/*===========================================================================*
+ *                Messages for Scheduling				     *
+ *===========================================================================*/
+#define SCHEDULING_BASE	0xF00
+
+#define SCHEDULING_NO_QUANTUM	(SCHEDULING_BASE+1)
+#define SCHEDULING_START	(SCHEDULING_BASE+2)
+#define SCHEDULING_STOP		(SCHEDULING_BASE+3)
+#define SCHEDULING_SET_NICE	(SCHEDULING_BASE+4)
+#define SCHEDULING_INHERIT	(SCHEDULING_BASE+5)
+
+/*===========================================================================*
+ *              Messages for USB                                             *
+ *===========================================================================*/
+
+#define USB_BASE 0x1100
+
+/* those are from driver to USBD */
+#define USB_RQ_INIT          (USB_BASE +  0) /* First message to HCD driver */
+#define USB_RQ_DEINIT        (USB_BASE +  1) /* Quit the session */
+#define USB_RQ_SEND_URB      (USB_BASE +  2) /* Send URB */
+#define USB_RQ_CANCEL_URB    (USB_BASE +  3) /* Cancel URB */
+#define USB_RQ_SEND_INFO     (USB_BASE +  4) /* Sends various information */
+#define USB_REPLY            (USB_BASE +  5)
+
+
+/* those are from USBD to driver */
+#define USB_COMPLETE_URB    (USB_BASE +  6)
+#define USB_ANNOUCE_DEV     (USB_BASE +  7) /* Announce a new USB Device */
+#define USB_WITHDRAW_DEV    (USB_BASE +  8) /* Withdraw a allready anncounced
+                                              USB device*/
+#   define USB_GRANT_ID     m4_l1
+#   define USB_GRANT_SIZE   m4_l2
+
+#   define USB_URB_ID       m4_l1
+#   define USB_RESULT       m4_l2
+#   define USB_DEV_ID       m4_l1
+#   define USB_DRIVER_EP    m4_l2
+#   define USB_INTERFACES   m4_l3
+#   define USB_RB_INIT_NAME m3_ca1
+
+#   define USB_INFO_TYPE    m4_l1
+#   define USB_INFO_VALUE   m4_l2
+
+/*===========================================================================*
+ *              Messages for DeviceManager (s/t like SysFS)                  *
+ *===========================================================================*/
+
+#define DEVMAN_BASE 0x1200
+
+#define DEVMAN_ADD_DEV     (DEVMAN_BASE + 0)
+#define DEVMAN_DEL_DEV     (DEVMAN_BASE + 1)
+#define DEVMAN_ADD_BUS     (DEVMAN_BASE + 2)
+#define DEVMAN_DEL_BUS     (DEVMAN_BASE + 3)
+#define DEVMAN_ADD_DEVFILE (DEVMAN_BASE + 4)
+#define DEVMAN_DEL_DEVFILE (DEVMAN_BASE + 5)
+
+#define DEVMAN_REQUEST     (DEVMAN_BASE + 6)
+#define DEVMAN_REPLY       (DEVMAN_BASE + 7)
+
+#define DEVMAN_BIND        (DEVMAN_BASE + 8)
+#define DEVMAN_UNBIND      (DEVMAN_BASE + 9)
+
+#   define DEVMAN_GRANT_ID       m4_l1
+#   define DEVMAN_GRANT_SIZE     m4_l2
+
+#   define DEVMAN_ENDPOINT       m4_l3
+#   define DEVMAN_DEVICE_ID      m4_l2
+#   define DEVMAN_RESULT         m4_l1
+
+/*===========================================================================*
+ *			Messages for TTY				     *
+ *===========================================================================*/
+
+#define TTY_RQ_BASE 0x1300
+
+#define TTY_FKEY_CONTROL	(TTY_RQ_BASE + 1) /* control an F-key at TTY */
+#  define    FKEY_MAP		10	/* observe function key */
+#  define    FKEY_UNMAP		11	/* stop observing function key */
+#  define    FKEY_EVENTS	12	/* request open key presses */
+
+#define TTY_INPUT_UP		(TTY_RQ_BASE + 2) /* input server is up */
+#define TTY_INPUT_EVENT		(TTY_RQ_BASE + 3) /* relayed input event */
+
+/*===========================================================================*
+ *			Messages for input server and drivers		     *
+ *===========================================================================*/
+
+/* The input protocol has no real replies. All messages are one-way. */
+#define INPUT_RQ_BASE 0x1500	/* from TTY to server, or server to driver */
+#define INPUT_RS_BASE 0x1580	/* from input driver to input server */
+
+#define INPUT_CONF		(INPUT_RQ_BASE + 0)	/* configure driver */
+#define INPUT_SETLEDS		(INPUT_RQ_BASE + 1)	/* set keyboard LEDs */
+
+#define INPUT_EVENT		(INPUT_RS_BASE + 0)	/* send input event */
+
+/*===========================================================================*
+ *			VFS-FS TRANSACTION IDs				     *
+ *===========================================================================*/
+
+#define VFS_TRANSACTION_BASE 0xB00
+
+#define VFS_TRANSID	(VFS_TRANSACTION_BASE + 1)
+#define IS_VFS_FS_TRANSID(type) (((type) & ~0xff) == VFS_TRANSACTION_BASE)
+
+/*===========================================================================*
+ *			Messages for character devices			     *
+ *===========================================================================*/
+
+/* Base type for character device requests and responses. */
+#define CDEV_RQ_BASE	0x400
+#define CDEV_RS_BASE	0x480
+
+#define IS_CDEV_RQ(type) (((type) & ~0x7f) == CDEV_RQ_BASE)
+#define IS_CDEV_RS(type) (((type) & ~0x7f) == CDEV_RS_BASE)
+
+/* Message types for character device requests. */
+#define CDEV_OPEN	(CDEV_RQ_BASE + 0)	/* open a minor device */
+#define CDEV_CLOSE	(CDEV_RQ_BASE + 1)	/* close a minor device */
+#define CDEV_READ	(CDEV_RQ_BASE + 2)	/* read into a buffer */
+#define CDEV_WRITE	(CDEV_RQ_BASE + 3)	/* write from a buffer */
+#define CDEV_IOCTL	(CDEV_RQ_BASE + 4)	/* I/O control operation */
+#define CDEV_CANCEL	(CDEV_RQ_BASE + 5)	/* cancel suspended request */
+#define CDEV_SELECT	(CDEV_RQ_BASE + 6)	/* test for ready operations */
+
+/* Message types for character device responses. */
+#define CDEV_REPLY	(CDEV_RS_BASE + 0)	/* general reply code */
+#define CDEV_SEL1_REPLY	(CDEV_RS_BASE + 1)	/* immediate select reply */
+#define CDEV_SEL2_REPLY	(CDEV_RS_BASE + 2)	/* select notification reply */
+
+/* Bits in 'CDEV_ACCESS' field of block device open requests. */
+#  define CDEV_R_BIT		0x01	/* open with read access */
+#  define CDEV_W_BIT		0x02	/* open with write access */
+#  define CDEV_NOCTTY		0x04	/* not to become the controlling TTY */
+
+/* Bits in 'CDEV_FLAGS' field of block device transfer requests. */
+#  define CDEV_NOFLAGS		0x00	/* no flags are set */
+#  define CDEV_NONBLOCK		0x01	/* do not suspend I/O request */
+
+/* Bits in 'CDEV_OPS', 'CDEV_STATUS' fields of block device select messages. */
+#  define CDEV_OP_RD		0x01	/* selected for read operation */
+#  define CDEV_OP_WR		0x02	/* selected for write operation */
+#  define CDEV_OP_ERR		0x04	/* selected for error operation */
+#  define CDEV_NOTIFY		0x08	/* notification requested */
+
+/* Bits in 'CDEV_STATUS' field of block device open responses. */
+#  define CDEV_CLONED		0x20000000	/* device is cloned */
+#  define CDEV_CTTY		0x40000000	/* device is controlling TTY */
+
+/*===========================================================================*
+ *			Messages for block devices			     *
+ *===========================================================================*/
+
+/* Base type for block device requests and responses. */
+#define BDEV_RQ_BASE	0x500
+#define BDEV_RS_BASE	0x580
+
+#define IS_BDEV_RQ(type) (((type) & ~0x7f) == BDEV_RQ_BASE)
+#define IS_BDEV_RS(type) (((type) & ~0x7f) == BDEV_RS_BASE)
+
+/* Message types for block device requests. */
+#define BDEV_OPEN	(BDEV_RQ_BASE + 0)	/* open a minor device */
+#define BDEV_CLOSE	(BDEV_RQ_BASE + 1)	/* close a minor device */
+#define BDEV_READ	(BDEV_RQ_BASE + 2)	/* read into a buffer */
+#define BDEV_WRITE	(BDEV_RQ_BASE + 3)	/* write from a buffer */
+#define BDEV_GATHER	(BDEV_RQ_BASE + 4)	/* read into a vector */
+#define BDEV_SCATTER	(BDEV_RQ_BASE + 5)	/* write from a vector */
+#define BDEV_IOCTL	(BDEV_RQ_BASE + 6)	/* I/O control operation */
+
+/* Message types for block device responses. */
+#define BDEV_REPLY	(BDEV_RS_BASE + 0)	/* general reply code */
+
+/* Bits in 'BDEV_ACCESS' field of block device open requests. */
+#  define BDEV_R_BIT		0x01	/* open with read access */
+#  define BDEV_W_BIT		0x02	/* open with write access */
+
+/* Bits in 'BDEV_FLAGS' field of block device transfer requests. */
+#  define BDEV_NOFLAGS		0x00	/* no flags are set */
+#  define BDEV_FORCEWRITE	0x01	/* force write to disk immediately */
+#  define BDEV_NOPAGE		0x02	/* eeprom: don't send page address */
+
+/*===========================================================================*
+ *			Messages for Real Time Clocks			     *
+ *===========================================================================*/
+
+/* Base type for real time clock requests and responses. */
+#define RTCDEV_RQ_BASE	0x1400
+#define RTCDEV_RS_BASE	0x1480
+
+#define IS_RTCDEV_RQ(type) (((type) & ~0x7f) == RTCDEV_RQ_BASE)
+#define IS_RTCDEV_RS(type) (((type) & ~0x7f) == RTCDEV_RS_BASE)
+
+/* Message types for real time clock requests. */
+#define RTCDEV_GET_TIME	(RTCDEV_RQ_BASE + 0)	/* get time from hw clock */
+#define RTCDEV_SET_TIME	(RTCDEV_RQ_BASE + 1)	/* set time in hw clock */
+#define RTCDEV_PWR_OFF	(RTCDEV_RQ_BASE + 2)	/* set time to cut the power */
+
+/* Same as GET/SET above but using grants */
+#define RTCDEV_GET_TIME_G (RTCDEV_RQ_BASE + 3)	/* get time from hw clock */
+#define RTCDEV_SET_TIME_G (RTCDEV_RQ_BASE + 4)	/* set time in hw clock */
+
+/* Message types for real time clock responses. */
+#define RTCDEV_REPLY	(RTCDEV_RS_BASE + 0)	/* general reply code */
+
+/* Bits in 'lc_readclock_rtcdev.flags' field of real time clock requests. */
+#define RTCDEV_NOFLAGS	0x00	/* no flags are set */
+#define RTCDEV_Y2KBUG	0x01	/* Interpret 1980 as 2000 for RTC w/Y2K bug */
+#define RTCDEV_CMOSREG	0x02	/* Also set the CMOS clock register bits. */
+
+/*===========================================================================*
+ *		Internal codes used by several services			     *
+ *===========================================================================*/
+
+#define SUSPEND 	 -998 	/* status to suspend caller, reply later */
+
+#endif /* !_MINIX_COM_H */
diff -ruNp srclimpio/minix/include/minix/minix/config.h proj/minix/include/minix/minix/config.h
--- srclimpio/minix/include/minix/minix/config.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/config.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,98 @@
+#ifndef _CONFIG_H
+#define _CONFIG_H
+
+/* Minix release and version numbers. */
+#define OS_NAME "Minix"
+#define OS_RELEASE "3.3.0"
+#define OS_CONFIG "GENERIC"
+#define OS_VERSION OS_NAME " " OS_RELEASE " (" OS_CONFIG ")"
+
+/* This file sets configuration parameters for the MINIX kernel, FS, and PM.
+ * It is divided up into two main sections.  The first section contains
+ * user-settable parameters.  In the second section, various internal system
+ * parameters are set based on the user-settable parameters.
+ *
+ * Parts of config.h have been moved to sys_config.h, which can be included
+ * by other include files that wish to get at the configuration data, but
+ * don't want to pollute the users namespace. Some editable values have
+ * gone there.
+ *
+ */
+
+#include <minix/sys_config.h>
+
+/* Number of slots in the process table for non-kernel processes. The number
+ * of system processes defines how many processes with special privileges 
+ * there can be. User processes share the same properties and count for one. 
+ *
+ * These can be changed in sys_config.h.
+ */
+#define NR_PROCS 	  _NR_PROCS 
+#define NR_SYS_PROCS      _NR_SYS_PROCS
+#define NR_SYS_CHUNKS	  BITMAP_CHUNKS(NR_SYS_PROCS)
+
+/* Number of controller tasks (/dev/cN device classes). */
+#define NR_CTRLRS          2
+
+/* DMA_SECTORS may be increased to speed up DMA based drivers. */
+#define DMA_SECTORS        1	/* DMA buffer size (must be >= 1) */
+
+/* NR_CONS, NR_RS_LINES, and NR_PTYS determine the number of terminals the
+ * system can handle.
+ */
+#define NR_CONS            4	/* # system consoles (1 to 8) */
+#define	NR_RS_LINES	   4	/* # rs232 terminals (0 to 3) */
+#define	NR_PTYS		   32	/* # pseudo terminals (0 to 64) */
+
+/* This feature enable the counting of system calls in PM and FS */
+#define ENABLE_SYSCALL_STATS	0
+
+/* Max. number of I/O ranges that can be assigned to a process */
+#define NR_IO_RANGE	64
+
+/* Max. number of device memory ranges that can be assigned to a process */
+#define NR_MEM_RANGE	20
+
+/* Max. number of IRQs that can be assigned to a process */
+#define NR_IRQ	16
+
+/* Scheduling priorities. Values must start at zero (highest
+ * priority) and increment.
+ */
+#define NR_SCHED_QUEUES   16	/* MUST equal minimum priority + 1 */
+#define TASK_Q		   0	/* highest, used for kernel tasks */
+#define MAX_USER_Q  	   0    /* highest priority for user processes */   
+#define USER_Q  	  ((MIN_USER_Q - MAX_USER_Q) / 2 + MAX_USER_Q) /* default
+						(should correspond to nice 0) */
+#define MIN_USER_Q	  (NR_SCHED_QUEUES - 1)	/* minimum priority for user
+						   processes */
+/* default scheduling quanta */
+#define USER_QUANTUM 200
+
+/* defualt user process cpu */
+#define USER_DEFAULT_CPU	-1 /* use the default cpu or do not change the
+				      current one */
+
+/*===========================================================================*
+ *	There are no user-settable parameters after this line		     *
+ *===========================================================================*/
+/* Set the FP_FORMAT type based on the machine selected, either hw or sw    */
+#define FP_NONE	 _FP_NONE	/* no floating point support                */
+#define FP_IEEE	 _FP_IEEE	/* conform IEEE floating point standard     */
+
+/* _MINIX_FP_FORMAT is defined in sys_config.h. */
+#define FP_FORMAT	_MINIX_FP_FORMAT
+
+/* _ASKDEV and _FASTLOAD are defined in sys_config.h. */
+#define ASKDEV _ASKDEV
+#define FASTLOAD _FASTLOAD
+
+/* Enable or disable system profiling. */
+#define SPROFILE          0    /* statistical profiling */
+#define CPROFILE          0    /* call profiling */
+
+/* PCI configuration parameters */
+#define NR_PCIBUS 40
+#define NR_PCIDEV 50
+
+#endif /* _CONFIG_H */
diff -ruNp srclimpio/minix/include/minix/minix/const.h proj/minix/include/minix/minix/const.h
--- srclimpio/minix/include/minix/minix/const.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/const.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,164 @@
+#ifndef _MINIX_CONST_H
+#define _MINIX_CONST_H
+
+#include <machine/archconst.h>
+
+/* The UNUSED annotation tells the compiler or lint not to complain
+ * about an unused variable or function parameter.
+ *
+ * A number of different annotations are used, depending on the
+ * compiler or checker that is looking at the code.
+ *
+ * Note that some variants rename the parameter, so if you use
+ * the parameter after all, you'll get a complaint about a missing
+ * variable.
+ *
+ * You use it like this:
+ *
+ *   void foo(int UNUSED(x)){}
+ */
+
+#ifndef UNUSED
+#if defined _lint
+# define UNUSED(v) /*lint -e(715,818)*/ v
+#elif defined(__GNUC__)
+# define UNUSED(v) UNUSED_ ## v __attribute((unused))
+#elif defined __LCLINT__
+# define UNUSED(v) /*@unused@*/ v
+#else
+# define UNUSED(v) _UNUSED_ ## v
+#endif
+#endif
+
+#define EXTERN        extern	/* used in *.h files */
+
+#define TRUE               1	/* used for turning integers into Booleans */
+#define FALSE              0	/* used for turning integers into Booleans */
+
+#define SUPER_USER ((uid_t) 0)	/* uid_t of superuser */
+
+#include <sys/null.h>      /* NULL Pointer */
+
+#define SCPVEC_NR	  64	/* max # of entries in a SYS_VSAFECOPY request */
+#define MAPVEC_NR	  64	/* max # of entries in a SYS_VUMAP request */
+#define NR_IOREQS	  64	/* maximum number of entries in an iorequest */
+
+#define VUA_READ	0x01	/* for SYS_VUMAP: read access */
+#define VUA_WRITE	0x02	/* for SYS_VUMAP: write access */
+
+/* Message passing constants. */
+#define MESS_SIZE (sizeof(message))	/* might need usizeof from FS here */
+
+/* Memory related constants. */
+#define SEGMENT_TYPE  0xFF00	/* bit mask to get segment type */
+#define SEGMENT_INDEX 0x00FF	/* bit mask to get segment index */
+
+#define PHYS_SEG      0x0400	/* flag indicating entire physical memory */
+
+#define LOCAL_VM_SEG  0x1000	/* same as LOCAL_SEG, but with vm lookup */
+#define MEM_GRANT	3
+#define VIR_ADDR	1
+#define VM_D		(LOCAL_VM_SEG | VIR_ADDR)
+#define VM_GRANT	(LOCAL_VM_SEG | MEM_GRANT)
+
+/* Labels used to disable code sections for different reasons. */
+#define DEAD_CODE	   0	/* unused code in normal configuration */
+#define FUTURE_CODE	   0	/* new code to be activated + tested later */
+#define TEMP_CODE	   1	/* active code to be removed later */
+
+/* Miscellaneous */
+#define BYTE            0377	/* mask for 8 bits */
+#define READING            0	/* copy data to user */
+#define WRITING            1	/* copy data from user */
+#define PEEKING            2	/* retrieve FS data without copying */
+#define HAVE_SCATTERED_IO  1	/* scattered I/O is now standard */
+
+/* Memory is allocated in clicks. */
+#if defined(__i386__) || defined(__arm__)
+#define CLICK_SIZE      4096	/* unit in which memory is allocated */
+#define CLICK_SHIFT       12	/* log2 of CLICK_SIZE */
+#else
+#error Unsupported arch
+#endif
+
+/* Click alignment macros. */
+#define CLICK_FLOOR(n)  (((vir_bytes)(n) / CLICK_SIZE) * CLICK_SIZE)
+#define CLICK_CEIL(n)   CLICK_FLOOR((vir_bytes)(n) + CLICK_SIZE-1)
+
+/* Sizes of memory tables. The boot monitor distinguishes three memory areas,
+ * namely low mem below 1M, 1M-16M, and mem after 16M. More chunks are needed
+ * for DOS MINIX.
+*/
+#define NR_MEMS            16
+
+#define CLICK2ABS(v) ((v) << CLICK_SHIFT)
+#define ABS2CLICK(a) ((a) >> CLICK_SHIFT)
+
+/* Flag bits for i_mode in the inode. */
+#define I_TYPE          0170000	/* this field gives inode type */
+#define I_UNIX_SOCKET	0140000 /* unix domain socket */
+#define I_SYMBOLIC_LINK 0120000	/* file is a symbolic link */
+#define I_REGULAR       0100000	/* regular file, not dir or special */
+#define I_BLOCK_SPECIAL 0060000	/* block special file */
+#define I_DIRECTORY     0040000	/* file is a directory */
+#define I_CHAR_SPECIAL  0020000	/* character special file */
+#define I_NAMED_PIPE    0010000	/* named pipe (FIFO) */
+#define I_SET_UID_BIT   0004000	/* set effective uid_t on exec */
+#define I_SET_GID_BIT   0002000	/* set effective gid_t on exec */
+#define I_SET_STCKY_BIT 0001000	/* sticky bit */ 
+#define ALL_MODES       0007777	/* all bits for user, group and others */
+#define RWX_MODES       0000777	/* mode bits for RWX only */
+#define R_BIT           0000004	/* Rwx protection bit */
+#define W_BIT           0000002	/* rWx protection bit */
+#define X_BIT           0000001	/* rwX protection bit */
+#define I_NOT_ALLOC     0000000	/* this inode is free */
+
+/* Some limits. */
+#define MAX_INODE_NR ((ino_t) 037777777777)	/* largest inode number */
+#define MAX_FILE_POS ((off_t) 0x7FFFFFFF)	/* largest legal file offset */
+#define UMAX_FILE_POS ((unsigned) 0x7FFFFFFF)	/* largest legal file offset */
+
+#define MAX_SYM_LOOPS	8	/* how many symbolic links are recursed */
+
+#define NO_BLOCK              ((block_t) 0)	/* absence of a block number */
+#define NO_ENTRY                ((ino_t) 0)	/* absence of a dir entry */
+#define NO_ZONE                ((zone_t) 0)	/* absence of a zone number */
+#define NO_DEV                  ((dev_t) 0)	/* absence of a device numb */
+#define NO_LINK		      ((nlink_t) 0)	/* absence of incoming links */
+#define INVAL_UID	       ((uid_t) -1)	/* invalid uid value */
+#define INVAL_GID	       ((gid_t) -1)	/* invalid gid value */
+
+#define SERVARNAME		"cttyline"
+#define ARCHVARNAME		"arch"
+#define BOARDVARNAME		"board"
+#define SERBAUDVARNAME		"cttybaud"
+
+/* Bits for s_flags in the privilege structure. */
+#define PREEMPTIBLE     0x002   /* kernel tasks are not preemptible */
+#define BILLABLE        0x004   /* some processes are not billable */
+#define DYN_PRIV_ID     0x008   /* privilege id assigned dynamically */
+ 
+#define SYS_PROC        0x010   /* system processes have own priv structure */
+#define CHECK_IO_PORT   0x020   /* check if I/O request is allowed */
+#define CHECK_IRQ       0x040   /* check if IRQ can be used */
+#define CHECK_MEM       0x080   /* check if (VM) mem map request is allowed */
+#define ROOT_SYS_PROC   0x100   /* this is a root system process instance */
+#define VM_SYS_PROC     0x200   /* this is a vm system process instance */
+#define LU_SYS_PROC     0x400   /* this is a live updated sys proc instance */
+#define RST_SYS_PROC    0x800   /* this is a restarted sys proc instance */
+
+/* Values for the "verbose" boot monitor variable */
+#define VERBOSEBOOT_QUIET 0
+#define VERBOSEBOOT_BASIC 1
+#define VERBOSEBOOT_EXTRA 2
+#define VERBOSEBOOT_MAX   3
+#define VERBOSEBOOTVARNAME "verbose"
+
+/* magic value to put in struct proc entries for sanity checks. */
+#define PMAGIC 0xC0FFEE1
+
+/* MINIX_KERNFLAGS flags */
+#define MKF_I386_INTEL_SYSENTER	(1L << 0) /* SYSENTER available and supported */
+#define MKF_I386_AMD_SYSCALL	(1L << 1) /* SYSCALL available and supported */
+
+#endif /* _MINIX_CONST_H */
diff -ruNp srclimpio/minix/include/minix/minix/cpufeature.h proj/minix/include/minix/minix/cpufeature.h
--- srclimpio/minix/include/minix/minix/cpufeature.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/cpufeature.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,30 @@
+
+#ifndef _MINIX_CPUFEATURE_H
+#define _MINIX_CPUFEATURE_H 1
+
+#define _CPUF_I386_FPU		0	/* FPU-x87 FPU on Chip */
+#define _CPUF_I386_PSE 		1	/* Page Size Extension */
+#define _CPUF_I386_PGE 		2	/* Page Global Enable */
+#define _CPUF_I386_APIC_ON_CHIP	3	/* APIC is present on the chip */
+#define _CPUF_I386_TSC		4	/* Timestamp counter present */
+#define _CPUF_I386_SSE1234_12	5	/* Support for SSE/SSE2/SSE3/SSSE3/SSE4
+					 * Extensions and FXSR
+					 */
+#define _CPUF_I386_FXSR		6
+#define _CPUF_I386_SSE		7
+#define _CPUF_I386_SSE2		8
+#define _CPUF_I386_SSE3		9
+#define _CPUF_I386_SSSE3	10
+#define _CPUF_I386_SSE4_1	11
+#define _CPUF_I386_SSE4_2	12
+
+#define _CPUF_I386_HTT		13	/* Supports HTT */
+#define _CPUF_I386_HTT_MAX_NUM	14	/* Maximal num of threads */
+
+#define _CPUF_I386_MTRR		15
+#define _CPUF_I386_SYSENTER	16	/* Intel SYSENTER instrs */
+#define _CPUF_I386_SYSCALL	17	/* AMD SYSCALL instrs */
+
+int _cpufeature(int featureno);
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/debug.h proj/minix/include/minix/minix/debug.h
--- srclimpio/minix/include/minix/minix/debug.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/debug.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,22 @@
+#ifndef _MINIX_DEBUG_H
+#define _MINIX_DEBUG_H 1
+
+/* For reminders of things to be fixed. */
+#define FIXME(str) { static int fixme_warned = 0; \
+	if(!fixme_warned) { \
+		printf("FIXME: %s:%d: %s\n", __FILE__, __LINE__, str);\
+		fixme_warned = 1; \
+	} \
+}
+
+#define NOT_REACHABLE	do {						\
+	panic("NOT_REACHABLE at %s:%d", __FILE__, __LINE__);	\
+	for(;;);							\
+} while(0)
+
+#define NOT_IMPLEMENTED do {	\
+		panic("NOT_IMPLEMENTED at %s:%d", __FILE__, __LINE__); \
+} while(0)
+
+#endif /* _MINIX_DEBUG_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/devio.h proj/minix/include/minix/minix/devio.h
--- srclimpio/minix/include/minix/minix/devio.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/devio.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,68 @@
+/* This file provides basic types and some constants for the 
+ * SYS_DEVIO and SYS_VDEVIO system calls, which allow user-level 
+ * processes to perform device I/O. 
+ *
+ * Created: 
+ *	Apr 08, 2004 by Jorrit N. Herder
+ */
+
+#ifndef _DEVIO_H
+#define _DEVIO_H
+
+#include <minix/sys_config.h>     /* needed to include <minix/type.h> */
+#include <sys/types.h>        /* u8_t, u16_t, u32_t needed */
+
+typedef u16_t port_t;
+
+/* We have different granularities of port I/O: 8, 16, 32 bits.
+ * Also see <ibm/portio.h>, which has functions for bytes, words,  
+ * and longs. Hence, we need different (port,value)-pair types. 
+ */
+typedef struct { u16_t port;  u8_t value; } pvb_pair_t;
+typedef struct { u16_t port; u16_t value; } pvw_pair_t;
+typedef struct { u16_t port; u32_t value; } pvl_pair_t;
+
+/* Macro shorthand to set (port,value)-pair. */
+#define pv_set(pv, p, v) do {					\
+	u32_t _p = (p), _v = (v);				\
+	(pv).port = _p;						\
+	(pv).value = _v;					\
+	if((pv).port != _p || (pv).value != _v) {		\
+		printf("%s:%d: actual port: 0x%x != 0x%x || "	\
+			"actual value: 0x%x != 0x%x\n",	\
+			__FILE__, __LINE__, (pv).port, _p, (pv).value, _v); \
+		panic("pv_set(" #pv ", " #p ", " #v ")"); \
+	}							\
+} while(0)
+
+#if 0	/* no longer in use !!! */
+/* Define a number of flags to indicate granularity we are using. */
+#define MASK_GRANULARITY 0x000F  /* not in use! does not match flags */
+#define PVB_FLAG 'b'
+#define PVW_FLAG 'w'
+#define PVL_FLAG 'l'
+
+/* Flags indicating whether request wants to do input or output. */
+#define MASK_IN_OR_OUT 0x00F0
+#define DEVIO_INPUT 0x0010
+#define DEVIO_OUTPUT 0x0020
+#endif	/* 0 */
+
+#if 0	/* no longer used !!! */
+/* Define how large the (port,value)-pair buffer in the kernel is. 
+ * This buffer is used to copy the (port,value)-pairs in kernel space.
+ */
+#define PV_BUF_SIZE  64      /* creates char pv_buf[PV_BUF_SIZE] */
+
+/* Note that SYS_VDEVIO sends a pointer to a vector of (port,value)-pairs, 
+ * whereas SYS_DEVIO includes a single (port,value)-pair in the messages.
+ * Calculate maximum number of (port,value)-pairs that can be handled 
+ * in a single SYS_VDEVIO system call with above struct definitions. 
+ */
+#define MAX_PVB_PAIRS ((PV_BUF_SIZE * sizeof(char)) / sizeof(pvb_pair_t))
+#define MAX_PVW_PAIRS ((PV_BUF_SIZE * sizeof(char)) / sizeof(pvw_pair_t))
+#define MAX_PVL_PAIRS ((PV_BUF_SIZE * sizeof(char)) / sizeof(pvl_pair_t))
+#endif /* 0 */
+	
+
+#endif  /* _DEVIO_H */
diff -ruNp srclimpio/minix/include/minix/minix/devman.h proj/minix/include/minix/minix/devman.h
--- srclimpio/minix/include/minix/minix/devman.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/devman.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,72 @@
+#ifndef MINIX_LIBDEVMAN_H
+#define MINIX_LIBDEVMAN_H
+#include <minix/com.h>
+#include <minix/ipc.h>
+#include <minix/usb_ch9.h>
+
+/* used for serializing */
+struct devman_device_info {
+	int count;
+	int parent_dev_id;
+	unsigned name_offset;
+	unsigned subsystem_offset;
+};
+
+struct devman_device_info_entry {
+	unsigned type;
+	unsigned name_offset;
+	unsigned data_offset;
+	unsigned req_nr;
+};
+
+#ifndef DEVMAN_SERVER
+struct devman_usb_bind_cb_data {
+	int dev_id;
+	int interface;
+};
+
+struct devman_usb_interface {
+	struct devman_dev *dev;
+	struct devman_usb_dev *usb_dev;
+	usb_interface_descriptor_t *desc;
+	/* used by the lib */
+	struct devman_usb_bind_cb_data cb_data;
+};
+
+struct devman_usb_dev {
+	struct devman_dev *dev;
+	int    dev_id;            /* The ID identifying the device 
+									 on server side */
+	usb_device_descriptor_t *desc;
+
+	int    configuration;        /* the configuration used for this
+	                                device */
+	
+	char   *manufacturer;
+	char   *product;
+	char   *serial;
+
+	int    intf_count;          /* the number of interfaces in the current
+	                               configuration */
+
+	struct devman_usb_interface interfaces[32];
+	/* used by the lib */
+	struct devman_usb_bind_cb_data cb_data;
+};
+
+typedef int (*devman_usb_bind_cb_t)(struct devman_usb_bind_cb_data *data, endpoint_t ep);
+
+int devman_add_device(struct devman_dev *dev);
+int devman_del_device(struct devman_dev *dev);
+int devman_init(void);
+struct devman_usb_dev* devman_usb_device_new(int dev_id);
+int devman_usb_device_add(struct devman_usb_dev *dev);
+int devman_usb_device_remove(struct devman_usb_dev *dev);
+void devman_usb_device_delete(struct devman_usb_dev *udev);
+int devman_handle_msg(message *m);
+void devman_usb_init(devman_usb_bind_cb_t bind_cb, devman_usb_bind_cb_t
+	unbind_cb);
+
+#endif
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/dmap.h proj/minix/include/minix/minix/dmap.h
--- srclimpio/minix/include/minix/minix/dmap.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/dmap.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,94 @@
+#ifndef _DMAP_H
+#define _DMAP_H
+
+#include <minix/sys_config.h>
+#include <minix/ipc.h>
+
+/*===========================================================================*
+ *               	 Major and minor device numbers  		     *
+ *===========================================================================*/
+
+/* Major device numbers. */
+#define NONE_MAJOR		   0	/*  0 = not used                      */
+#define MEMORY_MAJOR  		   1	/*  1 = /dev/mem    (memory devices)  */
+#define FLOPPY_MAJOR	           2	/*  2 = /dev/fd0    (floppy disks)    */
+                                        /*  3 = /dev/c0                       */
+#define TTY_MAJOR		   4	/*  4 = /dev/tty00  (ttys)            */
+#define CTTY_MAJOR		   5	/*  5 = /dev/tty                      */
+#define PRINTER_MAJOR		   6	/*  6 = /dev/lp     (printer driver)  */
+#define INET_MAJOR		   7	/*  7 = /dev/ip     (inet)            */
+					/*  8 = /dev/c1                       */
+#define PTY_MAJOR		   9	/*  9 = /dev/ptyp0  (pty driver)      */
+					/* 10 = /dev/c2                       */
+#define FILTER_MAJOR		  11	/* 11 = /dev/filter (filter driver)   */
+					/* 12 = /dev/c3                       */
+#define AUDIO_MAJOR		  13	/* 13 = /dev/audio  (audio driver)    */
+#define FBD_MAJOR		  14	/* 14 = /dev/fbd    (faulty block dev)*/
+#define LOG_MAJOR		  15	/* 15 = /dev/klog   (log driver)      */
+#define RANDOM_MAJOR		  16	/* 16 = /dev/random (random driver)   */
+#define HELLO_MAJOR		  17	/* 17 = /dev/hello  (hello driver)    */
+#define UDS_MAJOR		  18	/* 18 = /dev/uds    (pfs)             */
+#define FB_MAJOR		  19	/* 18 = /dev/fb0    (fb driver)       */
+#define I2C0_MAJOR		  20	/* 20 = /dev/i2c-1  (i2c-dev)         */
+#define I2C1_MAJOR		  21	/* 21 = /dev/i2c-2  (i2c-dev)         */
+#define I2C2_MAJOR		  22	/* 22 = /dev/i2c-3  (i2c-dev)         */
+#define EEPROMB1S50_MAJOR	  23	/* 23 = /dev/eepromb1s50 (cat24c256)  */
+#define EEPROMB1S51_MAJOR	  24	/* 24 = /dev/eepromb1s51 (cat24c256)  */
+#define EEPROMB1S52_MAJOR	  25	/* 25 = /dev/eepromb1s52 (cat24c256)  */
+#define EEPROMB1S53_MAJOR	  26	/* 26 = /dev/eepromb1s53 (cat24c256)  */
+#define EEPROMB1S54_MAJOR	  27	/* 27 = /dev/eepromb1s54 (cat24c256)  */
+#define EEPROMB1S55_MAJOR	  28	/* 28 = /dev/eepromb1s55 (cat24c256)  */
+#define EEPROMB1S56_MAJOR	  29	/* 29 = /dev/eepromb1s56 (cat24c256)  */
+#define EEPROMB1S57_MAJOR	  30	/* 30 = /dev/eepromb1s57 (cat24c256)  */
+#define EEPROMB2S50_MAJOR	  31	/* 31 = /dev/eepromb2s50 (cat24c256)  */
+#define EEPROMB2S51_MAJOR	  32	/* 32 = /dev/eepromb2s51 (cat24c256)  */
+#define EEPROMB2S52_MAJOR	  33	/* 33 = /dev/eepromb2s52 (cat24c256)  */
+#define EEPROMB2S53_MAJOR	  34	/* 34 = /dev/eepromb2s53 (cat24c256)  */
+#define EEPROMB2S54_MAJOR	  35	/* 35 = /dev/eepromb2s54 (cat24c256)  */
+#define EEPROMB2S55_MAJOR	  36	/* 36 = /dev/eepromb2s55 (cat24c256)  */
+#define EEPROMB2S56_MAJOR	  37	/* 37 = /dev/eepromb2s56 (cat24c256)  */
+#define EEPROMB2S57_MAJOR	  38	/* 38 = /dev/eepromb2s57 (cat24c256)  */
+#define EEPROMB3S50_MAJOR	  39	/* 39 = /dev/eepromb3s50 (cat24c256)  */
+#define EEPROMB3S51_MAJOR	  40	/* 40 = /dev/eepromb3s51 (cat24c256)  */
+#define EEPROMB3S52_MAJOR	  41	/* 41 = /dev/eepromb3s52 (cat24c256)  */
+#define EEPROMB3S53_MAJOR	  42	/* 42 = /dev/eepromb3s53 (cat24c256)  */
+#define EEPROMB3S54_MAJOR	  43	/* 43 = /dev/eepromb3s54 (cat24c256)  */
+#define EEPROMB3S55_MAJOR	  44	/* 44 = /dev/eepromb3s55 (cat24c256)  */
+#define EEPROMB3S56_MAJOR	  45	/* 45 = /dev/eepromb3s56 (cat24c256)  */
+#define EEPROMB3S57_MAJOR	  46	/* 46 = /dev/eepromb3s57 (cat24c256)  */
+#define TSL2550B1S39_MAJOR	  47	/* 47 = /dev/tsl2550b1s39 (tsl2550)   */
+#define TSL2550B2S39_MAJOR	  48	/* 48 = /dev/tsl2550b2s39 (tsl2550)   */
+#define TSL2550B3S39_MAJOR	  49	/* 49 = /dev/tsl2550b3s39 (tsl2550)   */
+#define SHT21B1S40_MAJOR	  50	/* 50 = /dev/sht21b1s40 (sht21)       */
+#define SHT21B2S40_MAJOR	  51	/* 51 = /dev/sht21b2s40 (sht21)       */
+#define SHT21B3S40_MAJOR	  52	/* 52 = /dev/sht21b3s40 (sht21)       */
+#define BMP085B1S77_MAJOR	  53	/* 53 = /dev/bmp085b1s77 (bmp085)     */
+#define BMP085B2S77_MAJOR	  54	/* 54 = /dev/bmp085b2s77 (bmp085)     */
+#define BMP085B3S77_MAJOR	  55	/* 55 = /dev/bmp085b3s77 (bmp085)     */
+					/* 56-63 = /dev/vnd[0-7] (vnd)	      */
+#define INPUT_MAJOR		  64	/* 64 = /dev/input (input)            */
+#define USB_BASE_MAJOR		  65	/* 65-133 = USB major range	      */
+
+#define NR_DEVICES   		 134	/* number of (major) devices */
+
+/* Minor device numbers for memory driver. */
+#  define RAM_DEV_OLD  		   0	/* minor device for /dev/ram */
+#  define MEM_DEV     		   1	/* minor device for /dev/mem */
+#  define KMEM_DEV    		   2	/* minor device for /dev/kmem */
+#  define NULL_DEV    		   3	/* minor device for /dev/null */
+#  define BOOT_DEV    		   4	/* minor device for /dev/boot */
+#  define ZERO_DEV    		   5	/* minor device for /dev/zero */
+#  define IMGRD_DEV   		   6	/* minor device for /dev/imgrd */
+#  define RAM_DEV_FIRST		   7	/* first minor device for /dev/ram* */
+
+#define CTRLR(n) ((n)==0 ? 3 : (8 + 2*((n)-1)))	/* magic formula */
+
+/* Minor device numbers for log driver. */
+#  define IS_KLOG_DEV		   0	/* minor device for /dev/klog */
+
+/* Full device numbers that are special to the boot monitor and FS. */
+#  define DEV_RAM     ((dev_t) 0x0100)	/* device number of /dev/ram */
+#  define DEV_IMGRD   ((dev_t) 0x0106)	/* device number of /dev/imgrd */
+
+#endif /* _DMAP_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/driver.h proj/minix/include/minix/minix/driver.h
--- srclimpio/minix/include/minix/minix/driver.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/driver.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,43 @@
+#ifndef _MINIX_DRIVER_H
+#define _MINIX_DRIVER_H
+
+/* Types and constants shared between block and character drivers. */
+
+#define _POSIX_SOURCE	1	/* tell headers to include POSIX stuff */
+#define _NETBSD_SOURCE	1	/* tell headers to include MINIX stuff */
+#define _SYSTEM		1	/* get negative error number in <errno.h> */
+
+/* The following are so basic, all the *.c files get them automatically. */
+#include <minix/config.h>	/* MUST be first */
+#include <minix/type.h>
+#include <minix/ipc.h>
+#include <minix/com.h>
+#include <minix/callnr.h>
+#include <sys/types.h>
+#include <minix/const.h>
+#include <minix/syslib.h>
+#include <minix/sysutil.h>
+#include <minix/endpoint.h>
+#include <string.h>
+#include <limits.h>
+#include <stddef.h>
+#include <errno.h>
+#include <sys/param.h>
+#include <minix/u64.h>
+#include <minix/partition.h>
+
+/* Base and size of a partition in bytes. */
+struct device {
+	u64_t dv_base;
+	u64_t dv_size;
+};
+
+/* Generic receive function for all drivers. */
+#ifndef driver_receive
+#define driver_receive sef_receive_status
+#endif
+
+/* Maximum supported number of concurrently opened minor devices. */
+#define MAX_NR_OPEN_DEVICES 256
+
+#endif /* _MINIX_DRIVER_H */
diff -ruNp srclimpio/minix/include/minix/minix/drivers.h proj/minix/include/minix/minix/drivers.h
--- srclimpio/minix/include/minix/minix/drivers.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/drivers.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,43 @@
+/* This is the master header for all device drivers. It includes some other
+ * files and defines the principal constants.
+ */
+
+#ifndef _INC_DRIVERS_H
+#define _INC_DRIVERS_H
+
+#define _POSIX_SOURCE	1	/* tell headers to include POSIX stuff */
+#define _NETBSD_SOURCE	1	/* tell headers to include MINIX stuff */
+#define _SYSTEM		1	/* get negative error number in <errno.h> */
+
+/* The following are so basic, all the *.c files get them automatically. */
+#include <minix/config.h>	/* MUST be first */
+#include <minix/bitmap.h>
+#include <minix/callnr.h>
+#include <minix/com.h>
+#include <minix/const.h>
+#include <minix/devio.h>
+#include <minix/dmap.h>
+#include <minix/spin.h>
+#include <minix/syslib.h>
+#include <minix/sysutil.h>
+#include <minix/timers.h>
+#include <minix/type.h>
+#include <sys/param.h>
+#include <sys/types.h>
+
+#include <machine/interrupt.h>	/* IRQ vectors and miscellaneous ports */
+#if defined(__i386__)
+#include <machine/bios.h>	/* BIOS index numbers */
+#include <machine/ports.h>	/* Well-known ports */
+#endif
+
+#include <errno.h>
+#include <lib.h>
+#include <limits.h>
+#include <signal.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/drvlib.h proj/minix/include/minix/minix/drvlib.h
--- srclimpio/minix/include/minix/minix/drvlib.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/drvlib.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,18 @@
+/* IBM device driver definitions			Author: Kees J. Bot
+ *								7 Dec 1995
+ */
+
+#include <machine/partition.h>
+
+void partition(struct blockdriver *bdr, int device, int style, int
+	atapi);
+
+#define DEV_PER_DRIVE	(1 + NR_PARTITIONS)
+#define SUB_PER_DRIVE	(NR_PARTITIONS * NR_PARTITIONS)
+#define MINOR_t0	64
+#define MINOR_r0	120
+#define MINOR_d0p0s0	128
+#define MINOR_fd0p0	(28<<2)
+#define P_FLOPPY	0
+#define P_PRIMARY	1
+#define P_SUB		2
diff -ruNp srclimpio/minix/include/minix/minix/ds.h proj/minix/include/minix/minix/ds.h
--- srclimpio/minix/include/minix/minix/ds.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/ds.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,74 @@
+/* Prototypes and definitions for DS interface. */
+
+#ifndef _MINIX_DS_H
+#define _MINIX_DS_H
+
+#ifdef _MINIX_SYSTEM
+
+#include <sys/types.h>
+#include <minix/endpoint.h>
+
+/* Flags. */
+#define DSF_IN_USE		0x001	/* entry is in use */
+#define DSF_PRIV_RETRIEVE	0x002	/* only owner can retrieve */
+#define DSF_PRIV_OVERWRITE	0x004	/* only owner can overwrite */
+#define DSF_PRIV_SNAPSHOT	0x004	/* only owner can take a snapshot */
+#define DSF_PRIV_SUBSCRIBE	0x008	/* only owner can subscribe */
+#define DSF_TYPE_U32		0x010	/* u32 data type */
+#define DSF_TYPE_STR		0x020	/* string data type */
+#define DSF_TYPE_MEM		0x040	/* memory range data type */
+#define DSF_TYPE_LABEL		0x100	/* label data type */
+
+#define DSF_MASK_TYPE		0xFF0	/* mask for type flags. */
+#define DSF_MASK_INTERNAL	0xFFF	/* mask for internal flags. */
+
+#define DSF_OVERWRITE		0x01000	/* overwrite if entry exists */
+#define DSF_INITIAL		0x02000	/* check subscriptions immediately */
+
+/* DS constants. */
+#define DS_MAX_KEYLEN 80        /* Max length of a key, including '\0'. */
+
+/* DS events. */
+#define DS_DRIVER_UP		1
+
+/* ds.c */
+
+/* U32 */
+int ds_publish_u32(const char *name, u32_t val, int flags);
+int ds_retrieve_u32(const char *name, u32_t *val);
+int ds_delete_u32(const char *ds_name);
+
+/* STRING */
+int ds_publish_str(const char *name, char *val, int flags);
+int ds_retrieve_str(const char *name, char *val, size_t len);
+int ds_delete_str(const char *ds_name);
+
+/* MEM */
+int ds_publish_mem(const char *ds_name, void *vaddr, size_t length, int
+	flags);
+int ds_retrieve_mem(const char *ds_name, char *vaddr, size_t *length);
+int ds_delete_mem(const char *ds_name);
+
+/* MAP */
+int ds_publish_map(const char *ds_name, void *vaddr, size_t length, int
+	flags);
+int ds_snapshot_map(const char *ds_name, int *nr_snapshot);
+int ds_retrieve_map(const char *ds_name, char *vaddr, size_t *length,
+	int nr_snapshot, int flags);
+int ds_delete_map(const char *ds_name);
+
+/* LABEL */
+int ds_publish_label(const char *ds_name, endpoint_t endpoint, int
+	flags);
+int ds_retrieve_label_name(char *ds_name, endpoint_t endpoint);
+int ds_retrieve_label_endpt(const char *ds_name, endpoint_t *endpoint);
+int ds_delete_label(const char *ds_name);
+
+/* Subscribe and check. */
+int ds_subscribe(const char *regex, int flags);
+int ds_check(char *ds_name, int *type, endpoint_t *owner_e);
+
+#endif /* _MINIX_SYSTEM */
+
+#endif /* _MINIX_DS_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/endpoint.h proj/minix/include/minix/minix/endpoint.h
--- srclimpio/minix/include/minix/minix/endpoint.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/endpoint.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,75 @@
+
+#ifndef _MINIX_ENDPOINT_H
+#define _MINIX_ENDPOINT_H 1
+
+#ifdef _MINIX_SYSTEM
+
+#include <minix/sys_config.h>
+#include <minix/com.h>
+#include <limits.h>
+#include <minix/type.h>
+
+/*
+ * Endpoints are split into two parts: a process slot and a generation number.
+ *
+ * The process slot number identifies the slot in various process tables.
+ * It is positive or zero for user processes, and negative for kernel tasks.
+ * Constants dictate that with the current endpoint layout, the maximum range
+ * of process slot numbers is [-MAX_NR_TASKS,MAX_NR_PROCS>.  The used part of
+ * the range is currently [-NR_TASKS,NR_PROCS> -- these two constants may be
+ * changed within the maximum range without changing the endpoint layout.
+ *
+ * The generation number is a per-slot number that gets increased by one every
+ * time a slot is reused for a new process.  The generation number minimizes
+ * the chance that the endpoint of a dead process can (accidentially) be used
+ * to communicate with a different, live process.  Preventing such accidents
+ * is essential for proper system service restartability support.
+ *
+ * The split between the two parts of the endpoint is such that when the
+ * generation number is zero, the endpoint number equals the process slot
+ * number, even for negative task numbers.  This is required for the endpoint
+ * numbers hardcoded in <minix/com.h>, and it makes endpoint numbers easy to
+ * read in general.
+ *
+ * There are three special endpoint numbers: ANY, NONE, and SELF.  These
+ * numbers are used to identify "any process", "no process at all", and
+ * "own process", respectively.  They fall outside the normal range of
+ * process slot numbers, and are always of generation zero.
+ */
+
+/*
+ * The following constant defines the split between the two parts of the
+ * endpoint numbers.  It can be adjusted to allow for either more processes
+ * or more per-process generation numbers.  Changing it will change the
+ * endpoint number layout, and thus break binary compatibility with existing
+ * processes.
+ */
+#define _ENDPOINT_GENERATION_SHIFT	15
+
+/* Derived constants. */
+#define _ENDPOINT_GENERATION_SIZE	(1 << _ENDPOINT_GENERATION_SHIFT)
+/* INT_MAX is used here to prevent signedness issues with the macros below. */
+#define _ENDPOINT_MAX_GENERATION	(INT_MAX/_ENDPOINT_GENERATION_SIZE-1)
+#define _ENDPOINT_SLOT_TOP	(_ENDPOINT_GENERATION_SIZE-MAX_NR_TASKS)
+
+/* The special endpoint numbers, and the resulting maximum slot number. */
+#define ANY		((endpoint_t) (_ENDPOINT_SLOT_TOP - 1))
+#define NONE		((endpoint_t) (_ENDPOINT_SLOT_TOP - 2))
+#define SELF		((endpoint_t) (_ENDPOINT_SLOT_TOP - 3))
+#define MAX_NR_PROCS		      (_ENDPOINT_SLOT_TOP - 3)	/* (int)SELF */
+
+/* Sanity check. */
+#if NR_PROCS > MAX_NR_PROCS
+#error "NR_PROCS exceeds MAX_NR_PROCS, increase _ENDPOINT_GENERATION_SHIFT"
+#endif
+
+/* Generation + Process slot number <-> endpoint. */
+#define _ENDPOINT(g, p) \
+	((endpoint_t)(((g) << _ENDPOINT_GENERATION_SHIFT) + (p)))
+#define _ENDPOINT_G(e) (((e)+MAX_NR_TASKS) >> _ENDPOINT_GENERATION_SHIFT)
+#define _ENDPOINT_P(e) \
+	((((e)+MAX_NR_TASKS) & (_ENDPOINT_GENERATION_SIZE - 1)) - MAX_NR_TASKS)
+
+#endif /* _MINIX_SYSTEM */
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/fb.h proj/minix/include/minix/minix/fb.h
--- srclimpio/minix/include/minix/minix/fb.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/fb.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,38 @@
+#ifndef __MINIX_FB_H_
+#define __MINIX_FB_H_
+
+#include <minix/type.h>
+
+struct fb_fix_screeninfo {
+	char id[16];		/* Identification string */
+	u16_t xpanstep;
+	u16_t ypanstep;
+	u16_t ywrapstep;
+	u32_t line_length;
+	phys_bytes mmio_start;
+	size_t mmio_len;
+	u16_t reserved[15];
+};
+
+struct fb_bitfield {
+	u32_t offset;
+	u32_t length;
+	u32_t msb_right;
+};
+
+struct fb_var_screeninfo {
+	u32_t xres;		/* visible resolution */
+	u32_t yres;
+	u32_t xres_virtual;	/* virtual resolution */
+	u32_t yres_virtual;
+	u32_t xoffset;		/* offset from virtual to visible */
+	u32_t yoffset;
+	u32_t bits_per_pixel;
+	struct fb_bitfield red;	/* bitfield in fb mem if true color */
+	struct fb_bitfield green;
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency */
+	u16_t reserved[10];
+};
+
+#endif /* __MINIX_FB_H_ */
diff -ruNp srclimpio/minix/include/minix/minix/fslib.h proj/minix/include/minix/minix/fslib.h
--- srclimpio/minix/include/minix/minix/fslib.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/fslib.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,6 @@
+/* V1 and V2 file system disk to/from memory support functions. */
+
+int bitmapsize(bit_t _nr_bits, int block_size);
+unsigned conv2(int _norm, int _w);
+long conv4(int _norm, long _x);
+void new_icopy(struct inode *_rip, d2_inode *_dip, int _direction, int _norm);
diff -ruNp srclimpio/minix/include/minix/minix/gcov.h proj/minix/include/minix/minix/gcov.h
--- srclimpio/minix/include/minix/minix/gcov.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/gcov.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,25 @@
+#include <sys/types.h>
+#include <lib.h>
+#include <stdlib.h>
+#include <minix/syslib.h>
+
+/* opcodes for use in gcov buffer */
+#define GCOVOP_OPEN	23
+#define GCOVOP_WRITE	24
+#define GCOVOP_CLOSE	25
+#define GCOVOP_END	26
+
+/* More information on the GCOV Minix Wiki page. */
+
+int gcov_flush_svr(char *buff, int buff_sz, int server_nr);
+extern void __gcov_flush (void);
+int do_gcov_flush_impl(message *msg);
+
+FILE *_gcov_fopen(char *name, char *mode);
+size_t _gcov_fread(void *ptr, size_t itemsize, size_t nitems,
+	FILE *stream);
+size_t _gcov_fwrite(void *ptr, size_t itemsize, size_t nitems,
+	FILE *stream);
+int _gcov_fclose(FILE *stream);
+int _gcov_fseek(FILE *stream, long offset, int ptrname);
+char *_gcov_getenv(const char *name);
diff -ruNp srclimpio/minix/include/minix/minix/gpio.h proj/minix/include/minix/minix/gpio.h
--- srclimpio/minix/include/minix/minix/gpio.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/gpio.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,34 @@
+#ifndef __INCLUDE_GPIO_H__
+#define __INCLUDE_GPIO_H__
+
+struct gpio
+{
+	int nr;			/* GPIO number */
+	int mode;		/* GPIO mode (input=0/output=1) */
+};
+
+#define GPIO_MODE_INPUT 0
+#define GPIO_MODE_OUTPUT 1
+
+int gpio_init(void);
+
+/* request access to a gpio */
+int gpio_claim(char *owner, int nr, struct gpio **gpio);
+
+/* Configure the GPIO for a certain purpose */
+int gpio_pin_mode(struct gpio *gpio, int mode);
+
+/* Set the value for a GPIO */
+int gpio_set(struct gpio *gpio, int value);
+
+/* Read the current value of the GPIO */
+int gpio_read(struct gpio *gpio, int *value);
+
+/* Read and clear the value interrupt value of the GPIO */
+int gpio_intr_read(struct gpio *gpio, int *value);
+
+/* Interrupt hook */
+int gpio_intr_message(message * m);
+
+int gpio_release(void);
+#endif /* __INCLUDE_GPIO_H__ */
diff -ruNp srclimpio/minix/include/minix/minix/hash.h proj/minix/include/minix/minix/hash.h
--- srclimpio/minix/include/minix/minix/hash.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/hash.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,49 @@
+
+#ifndef _MINIX_HASH_H
+#define _MINIX_HASH_H 1
+
+#include <stdint.h>
+
+/* This code is taken from:
+ * lookup3.c, by Bob Jenkins, May 2006, Public Domain.
+ * (macro names modified)
+ */
+
+#define hash_rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))
+
+#define hash_mix(a,b,c) \
+{ \
+  a -= c;  a ^= hash_rot(c, 4);  c += b; \
+  b -= a;  b ^= hash_rot(a, 6);  a += c; \
+  c -= b;  c ^= hash_rot(b, 8);  b += a; \
+  a -= c;  a ^= hash_rot(c,16);  c += b; \
+  b -= a;  b ^= hash_rot(a,19);  a += c; \
+  c -= b;  c ^= hash_rot(b, 4);  b += a; \
+}
+
+#define hash_final(a,b,c) \
+{ \
+  c ^= b; c -= hash_rot(b,14); \
+  a ^= c; a -= hash_rot(c,11); \
+  b ^= a; b -= hash_rot(a,25); \
+  c ^= b; c -= hash_rot(b,16); \
+  a ^= c; a -= hash_rot(c,4);  \
+  b ^= a; b -= hash_rot(a,14); \
+  c ^= b; c -= hash_rot(b,24); \
+}
+
+#define hash_i_64(a, u, v) {				\
+	u32_t i1 = (a), i2 = ex64lo(u), i3 = ex64hi(u);	\
+	hash_mix(i1, i2, i3);				\
+	hash_final(i1, i2, i3);				\
+	(v) = i3;					\
+}
+
+#define hash_32(n, v) {					\
+	u32_t i1 = 0xa5a5a5a5, i2 = 0x12345678, i3 = n;	\
+	hash_mix(i1, i2, i3);				\
+	hash_final(i1, i2, i3);				\
+	(v) = i3;					\
+}
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/hgfs.h proj/minix/include/minix/minix/hgfs.h
--- srclimpio/minix/include/minix/minix/hgfs.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/hgfs.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,11 @@
+/* Part of libhgfs - (c) 2009, D.C. van Moolenbroek */
+
+#ifndef _MINIX_HGFS_H
+#define _MINIX_HGFS_H
+
+#include <minix/sffs.h>
+
+int hgfs_init(const struct sffs_table **tablep);
+void hgfs_cleanup(void);
+
+#endif /* _MINIX_HGFS_H */
diff -ruNp srclimpio/minix/include/minix/minix/i2c.h proj/minix/include/minix/minix/i2c.h
--- srclimpio/minix/include/minix/minix/i2c.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/i2c.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,27 @@
+#ifndef __MINIX_I2C_H
+#define	__MINIX_I2C_H
+
+/*
+ * Minix I2C /dev Interface.
+ *
+ * Same as NetBSD/OpenBSD interface but with a flat struct (i.e. no pointers). 
+ * The NetBSD/OpenBSD interface can still be used on i2c device files. The
+ * ioctl(2) function will translate to/from the Minix version of the struct.
+ */
+
+#include <sys/types.h>
+#include <dev/i2c/i2c_io.h>
+#include <minix/ioctl.h>
+
+typedef struct minix_i2c_ioctl_exec {
+	i2c_op_t iie_op;		/* operation to perform */
+	i2c_addr_t iie_addr;		/* address of device */
+	uint8_t iie_cmd[I2C_EXEC_MAX_CMDLEN];	/* pointer to command */
+	size_t iie_cmdlen;		/* length of command */
+	uint8_t iie_buf[I2C_EXEC_MAX_BUFLEN];	/* pointer to data buffer */
+	size_t iie_buflen;		/* length of data buffer */
+} minix_i2c_ioctl_exec_t;
+
+#define	MINIX_I2C_IOCTL_EXEC		 _IOWR('I', 1, minix_i2c_ioctl_exec_t)
+
+#endif /* __MINIX_I2C_H */
diff -ruNp srclimpio/minix/include/minix/minix/i2cdriver.h proj/minix/include/minix/minix/i2cdriver.h
--- srclimpio/minix/include/minix/minix/i2cdriver.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/i2cdriver.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,32 @@
+/* Prototypes and definitions for i2c drivers. */
+
+#ifndef _MINIX_I2CDRIVER_H
+#define _MINIX_I2CDRIVER_H
+
+#include <minix/endpoint.h>
+#include <minix/i2c.h>
+#include <minix/ipc.h>
+
+/* Functions defined by i2cdriver.c: */
+int i2cdriver_env_parse(uint32_t * bus, i2c_addr_t * address,
+						i2c_addr_t * valid_addrs);
+void i2cdriver_announce(uint32_t bus);
+endpoint_t i2cdriver_bus_endpoint(uint32_t bus);
+int i2cdriver_subscribe_bus_updates(uint32_t bus);
+void i2cdriver_handle_bus_update(endpoint_t * bus_endpoint, uint32_t bus,
+							i2c_addr_t address);
+int i2cdriver_reserve_device(endpoint_t bus_endpoint, i2c_addr_t address);
+int i2cdriver_exec(endpoint_t bus_endpoint, minix_i2c_ioctl_exec_t *ioctl_exec);
+
+int i2creg_raw_read8(endpoint_t bus, i2c_addr_t addr, uint8_t * val);
+int i2creg_read8(endpoint_t bus, i2c_addr_t addr, uint8_t reg, uint8_t * val);
+int i2creg_read16(endpoint_t bus, i2c_addr_t addr, uint8_t reg, uint16_t * val);
+int i2creg_read24(endpoint_t bus, i2c_addr_t addr, uint8_t reg, uint32_t * val);
+int i2creg_raw_write8(endpoint_t bus, i2c_addr_t addr, uint8_t val);
+int i2creg_write8(endpoint_t bus, i2c_addr_t addr, uint8_t reg, uint8_t val);
+int i2creg_set_bits8(endpoint_t bus, i2c_addr_t addr, uint8_t reg,
+								uint8_t bits);
+int i2creg_clear_bits8(endpoint_t bus, i2c_addr_t addr, uint8_t reg,
+								uint8_t bits);
+
+#endif /* _MINIX_I2CDRIVER_H */
diff -ruNp srclimpio/minix/include/minix/minix/input.h proj/minix/include/minix/minix/input.h
--- srclimpio/minix/include/minix/minix/input.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/input.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,333 @@
+#ifndef _MINIX_INPUT_H
+#define _MINIX_INPUT_H
+
+#include <sys/types.h>
+
+#ifdef _SYSTEM
+
+/* Device type. */
+#define INPUT_DEV_KBD		0x01	/* keyboard device */
+#define INPUT_DEV_MOUSE		0x02	/* mouse device */
+
+/* Known-invalid input device ID. */
+#define INVALID_INPUT_ID	(-1)
+
+#endif /* _SYSTEM */
+
+/*
+ * The input server heavily draws on the USB HID specification for events.
+ * Every driver should convert its event codes into this format.  This also
+ * implies that we use the U.S. keyboard layout for key events.  The mapping to
+ * localized keyboard layouts will be done at a different place (TTY, Xserver).
+ */
+
+/* A single event, as read from one of the input devices. */
+struct input_event {
+	uint16_t page;			/* event page (INPUT_PAGE_) */
+	uint16_t code;			/* page-specific event code */
+	int32_t value;			/* event value */
+	uint16_t flags;			/* event flags (INPUT_FLAG_) */
+	uint16_t devid;			/* identifier of source device */
+	uint32_t rsvd[2];		/* reserved for a future timestamp */
+};
+
+/* Event pages. */
+#define INPUT_PAGE_GD		0x0001	/* General Desktop page */
+#define INPUT_PAGE_KEY		0x0007	/* Keyboard/Keypad page */
+#define INPUT_PAGE_LED		0x0008	/* LED page */
+#define INPUT_PAGE_BUTTON	0x0009	/* Button page */
+#define INPUT_PAGE_CONS		0x000C	/* Consumer page */
+
+/* Event values.  Not exhaustive. */
+#define INPUT_RELEASE		0
+#define INPUT_PRESS		1
+
+/* Event flags. */
+#define INPUT_FLAG_ABS		0x00	/* absolute value (the default) */
+#define INPUT_FLAG_REL		0x04	/* relative value */
+
+/* Page-specific event codes. */
+enum {
+	INPUT_GD_X = 0x0030,
+	INPUT_GD_Y,
+
+	INPUT_GD_SYSTEM_POWER_DOWN = 0x0081,
+	INPUT_GD_SYSTEM_SLEEP,
+	INPUT_GD_SYSTEM_WAKE_UP
+};
+
+enum {
+	INPUT_KEY_A = 0x0004,
+	INPUT_KEY_B,
+	INPUT_KEY_C,
+	INPUT_KEY_D,
+	INPUT_KEY_E,
+	INPUT_KEY_F,
+	INPUT_KEY_G,
+	INPUT_KEY_H,
+	INPUT_KEY_I,
+	INPUT_KEY_J,
+	INPUT_KEY_K,
+	INPUT_KEY_L,
+	INPUT_KEY_M,
+	INPUT_KEY_N,
+	INPUT_KEY_O,
+	INPUT_KEY_P,
+	INPUT_KEY_Q,
+	INPUT_KEY_R,
+	INPUT_KEY_S,
+	INPUT_KEY_T,
+	INPUT_KEY_U,
+	INPUT_KEY_V,
+	INPUT_KEY_W,
+	INPUT_KEY_X,
+	INPUT_KEY_Y,
+	INPUT_KEY_Z,
+	INPUT_KEY_1,
+	INPUT_KEY_2,
+	INPUT_KEY_3,
+	INPUT_KEY_4,
+	INPUT_KEY_5,
+	INPUT_KEY_6,
+	INPUT_KEY_7,
+	INPUT_KEY_8,
+	INPUT_KEY_9,
+	INPUT_KEY_0,
+
+	INPUT_KEY_ENTER,
+	INPUT_KEY_ESCAPE,
+	INPUT_KEY_BACKSPACE,
+	INPUT_KEY_TAB,
+	INPUT_KEY_SPACEBAR,
+	INPUT_KEY_DASH,
+	INPUT_KEY_EQUAL,
+	INPUT_KEY_OPEN_BRACKET,
+	INPUT_KEY_CLOSE_BRACKET,
+	INPUT_KEY_BACKSLASH,
+	INPUT_KEY_EUROPE_1,
+	INPUT_KEY_SEMICOLON,
+	INPUT_KEY_APOSTROPH,
+	INPUT_KEY_GRAVE_ACCENT,
+	INPUT_KEY_COMMA,
+	INPUT_KEY_PERIOD,
+	INPUT_KEY_SLASH,
+	INPUT_KEY_CAPS_LOCK,
+
+	INPUT_KEY_F1,
+	INPUT_KEY_F2,
+	INPUT_KEY_F3,
+	INPUT_KEY_F4,
+	INPUT_KEY_F5,
+	INPUT_KEY_F6,
+	INPUT_KEY_F7,
+	INPUT_KEY_F8,
+	INPUT_KEY_F9,
+	INPUT_KEY_F10,
+	INPUT_KEY_F11,
+	INPUT_KEY_F12,
+
+	INPUT_KEY_PRINT_SCREEN,
+	INPUT_KEY_SCROLL_LOCK,
+	INPUT_KEY_PAUSE,
+	INPUT_KEY_INSERT,
+	INPUT_KEY_HOME,
+	INPUT_KEY_PAGE_UP,
+	INPUT_KEY_DELETE,
+	INPUT_KEY_END,
+	INPUT_KEY_PAGE_DOWN,
+	INPUT_KEY_RIGHT_ARROW,
+	INPUT_KEY_LEFT_ARROW,
+	INPUT_KEY_DOWN_ARROW,
+	INPUT_KEY_UP_ARROW,
+	INPUT_KEY_NUM_LOCK,
+
+	INPUT_KEY_KP_SLASH,
+	INPUT_KEY_KP_STAR,
+	INPUT_KEY_KP_DASH,
+	INPUT_KEY_KP_PLUS,
+	INPUT_KEY_KP_ENTER,
+	INPUT_KEY_KP_1,
+	INPUT_KEY_KP_2,
+	INPUT_KEY_KP_3,
+	INPUT_KEY_KP_4,
+	INPUT_KEY_KP_5,
+	INPUT_KEY_KP_6,
+	INPUT_KEY_KP_7,
+	INPUT_KEY_KP_8,
+	INPUT_KEY_KP_9,
+	INPUT_KEY_KP_0,
+	INPUT_KEY_KP_PERIOD,
+
+	INPUT_KEY_EUROPE_2,
+	INPUT_KEY_APPLICATION,
+	INPUT_KEY_POWER,
+	INPUT_KEY_KP_EQUAL,
+
+	INPUT_KEY_F13,
+	INPUT_KEY_F14,
+	INPUT_KEY_F15,
+	INPUT_KEY_F16,
+	INPUT_KEY_F17,
+	INPUT_KEY_F18,
+	INPUT_KEY_F19,
+	INPUT_KEY_F20,
+	INPUT_KEY_F21,
+	INPUT_KEY_F22,
+	INPUT_KEY_F23,
+	INPUT_KEY_F24,
+
+	INPUT_KEY_EXECUTE,
+	INPUT_KEY_HELP,
+	INPUT_KEY_MENU,
+	INPUT_KEY_SELECT,
+	INPUT_KEY_STOP,
+	INPUT_KEY_AGAIN,
+	INPUT_KEY_UNDO,
+	INPUT_KEY_CUT,
+	INPUT_KEY_COPY,
+	INPUT_KEY_PASTE,
+	INPUT_KEY_FIND,
+	INPUT_KEY_MUTE,
+	INPUT_KEY_VOLUME_UP,
+	INPUT_KEY_VOLUME_DOWN,
+	INPUT_KEY_LOCKING_CAPS_LOCK,
+	INPUT_KEY_LOCKING_NUM_LOCK,
+	INPUT_KEY_LOCKING_SCROLL_LOCK,
+	INPUT_KEY_KP_COMMA,
+	INPUT_KEY_EQUAL_SIGN,
+	INPUT_KEY_I10L_1,
+	INPUT_KEY_I10L_2,
+	INPUT_KEY_I10L_3,
+	INPUT_KEY_I10L_4,
+	INPUT_KEY_I10L_5,
+	INPUT_KEY_I10L_6,
+	INPUT_KEY_I10L_7,
+	INPUT_KEY_I10L_8,
+	INPUT_KEY_I10L_9,
+	INPUT_KEY_LANG_1,
+	INPUT_KEY_LANG_2,
+	INPUT_KEY_LANG_3,
+	INPUT_KEY_LANG_4,
+	INPUT_KEY_LANG_5,
+	INPUT_KEY_LANG_6,
+	INPUT_KEY_LANG_7,
+	INPUT_KEY_LANG_8,
+	INPUT_KEY_LANG_9,
+	INPUT_KEY_ALT_ERASE,
+	INPUT_KEY_SYSREQ,
+	INPUT_KEY_CANCEL,
+	INPUT_KEY_CLEAR,
+	INPUT_KEY_PRIOR,
+	INPUT_KEY_RETURN,
+	INPUT_KEY_SEPARATOR,
+	INPUT_KEY_OUT,
+	INPUT_KEY_OPER,
+	INPUT_KEY_CLEAR_AGAIN,
+	INPUT_KEY_CR_SEL,
+	INPUT_KEY_EX_SEL,
+
+	/* 0x00A5 -- 0x00AF RESERVED */
+
+	INPUT_KEY_KP_00 = 0x00B0,
+	INPUT_KEY_KP_000,
+	INPUT_KEY_THOUSANDS_SEP,
+	INPUT_KEY_DECIMAL_SEP,
+	INPUT_KEY_CURRENCY_UNIT,
+	INPUT_KEY_CURRENCY_SUBUNIT,
+	INPUT_KEY_KP_OPEN_PARENTHESIS,
+	INPUT_KEY_KP_CLOSE_PARENTHESIS,
+	INPUT_KEY_KP_OPEN_BRACE,
+	INPUT_KEY_KP_CLOSE_BRACE,
+	INPUT_KEY_KP_TAB,
+	INPUT_KEY_KP_BACKSPACE,
+	INPUT_KEY_KP_A,
+	INPUT_KEY_KP_B,
+	INPUT_KEY_KP_C,
+	INPUT_KEY_KP_D,
+	INPUT_KEY_KP_E,
+	INPUT_KEY_KP_F,
+	INPUT_KEY_KP_XOR,
+	INPUT_KEY_KP_CARET,
+	INPUT_KEY_KP_PERCENT,
+	INPUT_KEY_KP_SMALLER_THEN,
+	INPUT_KEY_KP_GREATER_THEN,
+	INPUT_KEY_KP_AMP,
+	INPUT_KEY_KP_DOUBLE_AMP,
+	INPUT_KEY_KP_PIPE,
+	INPUT_KEY_KP_DOUBLE_PIPE,
+	INPUT_KEY_KP_COLON,
+	INPUT_KEY_KP_NUMBER,
+	INPUT_KEY_KP_SPACE,
+	INPUT_KEY_KP_AT,
+	INPUT_KEY_KP_EXCLAMATION_MARK,
+	INPUT_KEY_KP_MEM_STORE,
+	INPUT_KEY_KP_MEM_RECALL,
+	INPUT_KEY_KP_MEM_CLEAR,
+	INPUT_KEY_KP_MEM_ADD,
+	INPUT_KEY_KP_MEM_SUBTRACT,
+	INPUT_KEY_KP_MEM_MULTIPLY,
+	INPUT_KEY_KP_MEM_DIVIDE,
+	INPUT_KEY_KP_PLUS_MINUS,
+	INPUT_KEY_KP_CLEAR,
+	INPUT_KEY_KP_CLEAR_ENTRY,
+	INPUT_KEY_KP_BIN,
+	INPUT_KEY_KP_OCT,
+	INPUT_KEY_KP_DEC,
+	INPUT_KEY_KP_HEX,
+
+	/* 0x00DE, 0x00DF RESERVED */
+
+	INPUT_KEY_LEFT_CTRL = 0x00E0,
+	INPUT_KEY_LEFT_SHIFT,
+	INPUT_KEY_LEFT_ALT,
+	INPUT_KEY_LEFT_GUI,
+	INPUT_KEY_RIGHT_CTRL,
+	INPUT_KEY_RIGHT_SHIFT,
+	INPUT_KEY_RIGHT_ALT,
+	INPUT_KEY_RIGHT_GUI
+
+	/* 0x00E8 -- 0xFFFF RESERVED */
+};
+
+enum {
+	INPUT_LED_NUMLOCK = 0x0001,
+	INPUT_LED_CAPSLOCK,
+	INPUT_LED_SCROLLLOCK
+};
+
+enum {
+	INPUT_BUTTON_1 = 0x0001,
+};
+
+enum {
+	INPUT_CONS_SCAN_NEXT_TRACK = 0x00B5,
+	INPUT_CONS_SCAN_PREVIOUS_TRACK,
+	INPUT_CONS_STOP,
+
+	INPUT_CONS_PLAY_PAUSE = 0x00CD,
+
+	INPUT_CONS_MUTE = 0x00E2,
+
+	INPUT_CONS_VOLUME_UP = 0x00E9,
+	INPUT_CONS_VOLUME_DOWN,
+
+	INPUT_CONS_AL_MEDIA_SELECT = 0x0183,
+
+	INPUT_CONS_AL_EMAIL_READER = 0x018A,
+
+	INPUT_CONS_AL_CALCULATOR = 0x0192,
+
+	INPUT_CONS_AL_LOCAL_BROWSER = 0x0194,
+
+	INPUT_CONS_AC_SEARCH = 0x0221,
+	INPUT_CONS_AC_GO_TO,
+	INPUT_CONS_AC_HOME,
+	INPUT_CONS_AC_BACK,
+	INPUT_CONS_AC_FORWARD,
+	INPUT_CONS_AC_STOP,
+	INPUT_CONS_AC_REFRESH,
+
+	INPUT_CONS_AC_BOOKMARKS = 0x022A
+};
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/inputdriver.h proj/minix/include/minix/minix/inputdriver.h
--- srclimpio/minix/include/minix/minix/inputdriver.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/inputdriver.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,24 @@
+#ifndef _MINIX_INPUTDRIVER_H
+#define _MINIX_INPUTDRIVER_H
+
+#include <minix/driver.h>
+#include <minix/input.h>
+
+/* Entry points into the device dependent code of input drivers. */
+struct inputdriver {
+	void (*idr_leds)(unsigned int leds);
+	void (*idr_intr)(unsigned int mask);
+	void (*idr_alarm)(clock_t stamp);
+	void (*idr_other)(message *m_ptr, int ipc_status);
+};
+
+/* Functions defined by libinputdriver. */
+void inputdriver_announce(unsigned int type);
+void inputdriver_send_event(int mouse, unsigned short page,
+	unsigned short code, int value, int flags);
+void inputdriver_process(struct inputdriver *idp, message *m_ptr,
+	int ipc_status);
+void inputdriver_terminate(void);
+void inputdriver_task(struct inputdriver *idp);
+
+#endif /* !_MINIX_INPUTDRIVER_H */
diff -ruNp srclimpio/minix/include/minix/minix/ioctl.h proj/minix/include/minix/minix/ioctl.h
--- srclimpio/minix/include/minix/minix/ioctl.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/ioctl.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1 @@
+#include <sys/ioccom.h>
diff -ruNp srclimpio/minix/include/minix/minix/ipc.h proj/minix/include/minix/minix/ipc.h
--- srclimpio/minix/include/minix/minix/ipc.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/ipc.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,2420 @@
+#ifndef _IPC_H
+#define _IPC_H
+
+#include <minix/ipcconst.h>
+#include <minix/type.h>
+#include <minix/const.h>
+#include <sys/signal.h>
+#include <sys/types.h>
+
+/*==========================================================================* 
+ * Types relating to messages. 						    *
+ *==========================================================================*/ 
+
+#define M_PATH_STRING_MAX  40
+
+typedef struct {
+	uint8_t data[56];
+} mess_u8;
+_ASSERT_MSG_SIZE(mess_u8);
+
+typedef struct {
+	uint16_t data[28];
+} mess_u16;
+_ASSERT_MSG_SIZE(mess_u16);
+
+typedef struct {
+	uint32_t data[14];
+} mess_u32;
+_ASSERT_MSG_SIZE(mess_u32);
+
+typedef struct {
+	uint64_t data[7];
+} mess_u64;
+_ASSERT_MSG_SIZE(mess_u64);
+
+typedef struct {
+	uint64_t m1ull1;
+	int m1i1, m1i2, m1i3;
+	char *m1p1, *m1p2, *m1p3, *m1p4;
+	uint8_t padding[20];
+} mess_1;
+_ASSERT_MSG_SIZE(mess_1);
+
+typedef struct {
+	int64_t m2ll1;
+	int m2i1, m2i2, m2i3;
+	long m2l1, m2l2;
+	char *m2p1;
+	sigset_t sigset;
+	short m2s1;
+	uint8_t padding[6];
+} mess_2;
+_ASSERT_MSG_SIZE(mess_2);
+
+typedef struct {
+	int m3i1, m3i2;
+	char *m3p1;
+	char m3ca1[44];
+} mess_3;
+_ASSERT_MSG_SIZE(mess_3);
+
+typedef struct {
+	int64_t m4ll1;
+	long m4l1, m4l2, m4l3, m4l4, m4l5;
+	uint8_t padding[28];
+} mess_4;
+_ASSERT_MSG_SIZE(mess_4);
+
+typedef struct {
+	int m7i1, m7i2, m7i3, m7i4, m7i5;
+	char *m7p1, *m7p2;
+	uint8_t padding[28];
+} mess_7;
+_ASSERT_MSG_SIZE(mess_7);
+
+typedef struct {
+	uint64_t m9ull1, m9ull2;
+	long m9l1, m9l2, m9l3, m9l4, m9l5;
+	short m9s1, m9s2, m9s3, m9s4;
+	uint8_t padding[12];
+} mess_9;
+_ASSERT_MSG_SIZE(mess_9);
+
+typedef struct {
+	u64_t m10ull1;
+	int m10i1, m10i2, m10i3, m10i4;
+	long m10l1, m10l2, m10l3;
+	uint8_t padding[20];
+} mess_10;
+_ASSERT_MSG_SIZE(mess_10);
+
+/* Helper union for DS messages */
+union	ds_val {
+	cp_grant_id_t	grant;
+	u32_t		u32;
+	endpoint_t	ep;
+};
+
+typedef struct {
+	union	ds_val 	val_out;
+	int	val_len;
+	uint8_t padding[48];
+} mess_ds_reply;
+_ASSERT_MSG_SIZE(mess_ds_reply);
+
+typedef struct {
+	cp_grant_id_t	key_grant;
+	int		key_len;
+	int		flags;
+	union ds_val 	val_in;
+	int		val_len;
+	endpoint_t	owner;
+	uint8_t padding[32];
+} mess_ds_req;
+_ASSERT_MSG_SIZE(mess_ds_req);
+
+typedef struct {
+	off_t seek_pos;
+
+	size_t nbytes;
+
+	uint8_t data[44];
+} mess_fs_vfs_breadwrite;
+_ASSERT_MSG_SIZE(mess_fs_vfs_breadwrite);
+
+typedef struct {
+	mode_t mode;
+
+	uint8_t data[52];
+} mess_fs_vfs_chmod;
+_ASSERT_MSG_SIZE(mess_fs_vfs_chmod);
+
+typedef struct {
+	mode_t mode;
+
+	uint8_t data[52];
+} mess_fs_vfs_chown;
+_ASSERT_MSG_SIZE(mess_fs_vfs_chown);
+
+typedef struct {
+	off_t file_size;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[28];
+} mess_fs_vfs_create;
+_ASSERT_MSG_SIZE(mess_fs_vfs_create);
+
+typedef struct {
+	off_t seek_pos;
+
+	size_t nbytes;
+
+	uint8_t data[44];
+} mess_fs_vfs_getdents;
+_ASSERT_MSG_SIZE(mess_fs_vfs_getdents);
+
+typedef struct {
+	off_t offset;
+	off_t file_size;
+	dev_t device;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint16_t symloop;
+
+	uint8_t data[10];
+} mess_fs_vfs_lookup;
+_ASSERT_MSG_SIZE(mess_fs_vfs_lookup);
+
+typedef struct {
+	off_t file_size;
+	dev_t device;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[20];
+} mess_fs_vfs_newnode;
+_ASSERT_MSG_SIZE(mess_fs_vfs_newnode);
+
+typedef struct {
+	size_t nbytes;
+
+	uint8_t data[52];
+} mess_fs_vfs_rdlink;
+_ASSERT_MSG_SIZE(mess_fs_vfs_rdlink);
+
+typedef struct {
+	off_t file_size;
+	dev_t device;
+	ino_t inode;
+
+	uint32_t flags;
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint16_t con_reqs;
+
+	uint8_t data[14];
+} mess_fs_vfs_readsuper;
+_ASSERT_MSG_SIZE(mess_fs_vfs_readsuper);
+
+typedef struct {
+	off_t seek_pos;
+
+	size_t nbytes;
+
+	uint8_t data[44];
+} mess_fs_vfs_readwrite;
+_ASSERT_MSG_SIZE(mess_fs_vfs_readwrite);
+
+typedef struct {
+	uint8_t padding[56];
+} mess_i2c_li2cdriver_busc_i2c_exec;
+_ASSERT_MSG_SIZE(mess_i2c_li2cdriver_busc_i2c_exec);
+
+typedef struct {
+	uint8_t padding[56];
+} mess_i2c_li2cdriver_busc_i2c_reserve;
+_ASSERT_MSG_SIZE(mess_i2c_li2cdriver_busc_i2c_reserve);
+
+typedef struct {
+	int kbd_id;
+	int mouse_id;
+	int rsvd1_id;
+	int rsvd2_id;
+
+	uint8_t padding[40];
+} mess_input_linputdriver_input_conf;
+_ASSERT_MSG_SIZE(mess_input_linputdriver_input_conf);
+
+typedef struct {
+	uint32_t led_mask;
+
+	uint8_t padding[52];
+} mess_input_linputdriver_setleds;
+_ASSERT_MSG_SIZE(mess_input_linputdriver_setleds);
+
+typedef struct {
+	int id;
+	int page;
+	int code;
+	int value;
+	int flags;
+
+	uint8_t padding[36];
+} mess_input_tty_event;
+_ASSERT_MSG_SIZE(mess_input_tty_event);
+
+typedef struct {
+	time_t acnt_queue;
+
+	unsigned long acnt_deqs;
+	unsigned long acnt_ipc_sync;
+	unsigned long acnt_ipc_async;
+	unsigned long acnt_preempt;
+	uint32_t acnt_cpu;
+	uint32_t acnt_cpu_load;
+
+	uint8_t padding[24];
+} mess_krn_lsys_schedule;
+_ASSERT_MSG_SIZE(mess_krn_lsys_schedule);
+
+typedef struct {
+	uint32_t value;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_devio;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_devio);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes msgaddr;
+
+	uint8_t padding[48];
+} mess_krn_lsys_sys_fork;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_fork);
+
+typedef struct {
+	endpoint_t endpt;
+	int privflags;
+	char name[48];
+
+} mess_krn_lsys_sys_getwhoami;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_getwhoami);
+
+typedef struct {
+	int hook_id;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_irqctl;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_irqctl);
+
+typedef struct {
+	clock_t real_ticks;
+	clock_t boot_ticks;
+	clock_t boot_time;
+	clock_t user_time;
+	clock_t system_time;
+
+	uint8_t padding[36];
+} mess_krn_lsys_sys_times;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_times);
+
+typedef struct {
+	long int data;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_trace;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_trace);
+
+typedef struct {
+	phys_bytes dst_addr;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_umap;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_umap);
+
+typedef struct {
+	int pcount;
+
+	uint8_t padding[52];
+} mess_krn_lsys_sys_vumap;
+_ASSERT_MSG_SIZE(mess_krn_lsys_sys_vumap);
+
+typedef struct {
+	off_t pos;
+
+	int minor;
+	int id;
+	int access;
+
+	int count;
+	cp_grant_id_t grant;
+	int flags;
+
+	endpoint_t user;
+	int request;
+
+	uint8_t padding[16];
+} mess_lbdev_lblockdriver_msg;
+_ASSERT_MSG_SIZE(mess_lbdev_lblockdriver_msg);
+
+typedef struct {
+	int status;
+	int id;
+
+	uint8_t padding[48];
+} mess_lblockdriver_lbdev_reply;
+_ASSERT_MSG_SIZE(mess_lblockdriver_lbdev_reply);
+
+typedef struct {
+	int		id;
+	int		num;
+	int		cmd;
+	int		opt;
+	int		ret;
+	uint8_t		padding[36];
+} mess_lc_ipc_semctl;
+_ASSERT_MSG_SIZE(mess_lc_ipc_semctl);
+
+typedef struct {
+	key_t		key;
+	int		nr;
+	int		flag;
+	int		retid;
+	uint8_t		padding[40];
+} mess_lc_ipc_semget;
+_ASSERT_MSG_SIZE(mess_lc_ipc_semget);
+
+typedef struct {
+	int		id;
+	void		*ops;
+	unsigned int	size;
+	uint8_t		padding[42];
+} mess_lc_ipc_semop;
+_ASSERT_MSG_SIZE(mess_lc_ipc_semop);
+
+typedef struct {
+	int		id;
+	const void	*addr;
+	int		flag;
+	void		*retaddr;
+	uint8_t		padding[40];
+} mess_lc_ipc_shmat;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmat);
+
+typedef struct {
+	int		id;
+	int		cmd;
+	void		*buf;
+	int		ret;
+	uint8_t		padding[40];
+} mess_lc_ipc_shmctl;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmctl);
+
+typedef struct {
+	const void	*addr;
+	uint8_t		padding[52];
+} mess_lc_ipc_shmdt;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmdt);
+
+typedef struct {
+	key_t		key;
+	size_t		size;
+	int		flag;
+	int		retid;
+	uint8_t		padding[40];
+} mess_lc_ipc_shmget;
+_ASSERT_MSG_SIZE(mess_lc_ipc_shmget);
+
+typedef struct {
+	int action;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[40];
+} mess_lc_pm_cprof;
+_ASSERT_MSG_SIZE(mess_lc_pm_cprof);
+
+typedef struct {
+	vir_bytes name;
+	size_t namelen;
+	vir_bytes frame;
+	size_t framelen;
+	vir_bytes ps_str;
+
+	uint8_t padding[36];
+} mess_lc_pm_exec;
+_ASSERT_MSG_SIZE(mess_lc_pm_exec);
+
+typedef struct {
+	int status;
+
+	uint8_t padding[52];
+} mess_lc_pm_exit;
+_ASSERT_MSG_SIZE(mess_lc_pm_exit);
+
+typedef struct {
+	pid_t pid;
+
+	uint8_t padding[52];
+} mess_lc_pm_getsid;
+_ASSERT_MSG_SIZE(mess_lc_pm_getsid);
+
+typedef struct {
+	int num;
+	vir_bytes ptr;		/* gid_t * */
+
+	uint8_t padding[48];
+} mess_lc_pm_groups;
+_ASSERT_MSG_SIZE(mess_lc_pm_groups);
+
+typedef struct {
+	int which;
+	vir_bytes value;	/* const struct itimerval * */
+	vir_bytes ovalue;	/* struct itimerval * */
+
+	uint8_t padding[44];
+} mess_lc_pm_itimer;
+_ASSERT_MSG_SIZE(mess_lc_pm_itimer);
+
+typedef struct {
+	vir_bytes ctx;		/* mcontext_t * */
+
+	uint8_t padding[52];
+} mess_lc_pm_mcontext;
+_ASSERT_MSG_SIZE(mess_lc_pm_mcontext);
+
+typedef struct {
+	int which;
+	int who;
+	int prio;
+
+	uint8_t padding[44];
+} mess_lc_pm_priority;
+_ASSERT_MSG_SIZE(mess_lc_pm_priority);
+
+typedef struct {
+	pid_t pid;
+	int req;
+	vir_bytes addr;
+	long data;
+
+	uint8_t padding[40];
+} mess_lc_pm_ptrace;
+_ASSERT_MSG_SIZE(mess_lc_pm_ptrace);
+
+typedef struct {
+	int how;
+
+	uint8_t padding[52];
+} mess_lc_pm_reboot;
+_ASSERT_MSG_SIZE(mess_lc_pm_reboot);
+
+typedef struct {
+	endpoint_t who;
+	vir_bytes addr;
+
+	uint8_t padding[48];
+} mess_lc_pm_rusage;
+_ASSERT_MSG_SIZE(mess_lc_pm_rusage);
+
+typedef struct {
+	gid_t gid;
+
+	uint8_t padding[52];
+} mess_lc_pm_setgid;
+_ASSERT_MSG_SIZE(mess_lc_pm_setgid);
+
+typedef struct {
+	uid_t uid;
+
+	uint8_t padding[52];
+} mess_lc_pm_setuid;
+_ASSERT_MSG_SIZE(mess_lc_pm_setuid);
+
+typedef struct {
+	pid_t pid;
+	int nr;
+	vir_bytes act;		/* const struct sigaction * */
+	vir_bytes oact;		/* struct sigaction * */
+	vir_bytes ret;		/* int (*)(void) */
+
+	uint8_t padding[36];
+} mess_lc_pm_sig;
+_ASSERT_MSG_SIZE(mess_lc_pm_sig);
+
+typedef struct {
+	int how;
+	vir_bytes ctx;
+	sigset_t set;
+
+	uint8_t padding[32];
+} mess_lc_pm_sigset;
+_ASSERT_MSG_SIZE(mess_lc_pm_sigset);
+
+typedef struct {
+	int action;
+	int freq;
+	int intr_type;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[32];
+} mess_lc_pm_sprof;
+_ASSERT_MSG_SIZE(mess_lc_pm_sprof);
+
+typedef struct {
+	int req;
+	int field;
+	size_t len;
+	vir_bytes value;
+
+	uint8_t padding[40];
+} mess_lc_pm_sysuname;
+_ASSERT_MSG_SIZE(mess_lc_pm_sysuname);
+
+typedef struct {
+	time_t sec;
+
+	clockid_t clk_id;
+	int now;
+	long nsec;
+
+	uint8_t padding[36];
+} mess_lc_pm_time;
+_ASSERT_MSG_SIZE(mess_lc_pm_time);
+
+typedef struct {
+	pid_t pid;
+	int options;
+
+	uint8_t padding[48];
+} mess_lc_pm_waitpid;
+_ASSERT_MSG_SIZE(mess_lc_pm_waitpid);
+
+typedef struct {
+	cp_grant_id_t grant;
+	vir_bytes tm;			/* struct tm * */
+	int flags;
+
+	uint8_t padding[44];
+} mess_lc_readclock_rtcdev;
+_ASSERT_MSG_SIZE(mess_lc_readclock_rtcdev);
+
+typedef struct {
+	vir_bytes name;
+	size_t len;
+	int fd;
+	uid_t owner;
+	gid_t group;
+
+	uint8_t padding[36];
+} mess_lc_vfs_chown;
+_ASSERT_MSG_SIZE(mess_lc_vfs_chown);
+
+typedef struct {
+	int fd;
+
+	uint8_t padding[52];
+} mess_lc_vfs_close;
+_ASSERT_MSG_SIZE(mess_lc_vfs_close);
+
+typedef struct {
+	vir_bytes name;
+	size_t len;
+	int flags;
+	mode_t mode;
+
+	uint8_t padding[40];
+} mess_lc_vfs_creat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_creat);
+
+typedef struct {
+	int fd;
+
+	uint8_t padding[52];
+} mess_lc_vfs_fchdir;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fchdir);
+
+typedef struct {
+	int fd;
+	mode_t mode;
+
+	uint8_t padding[48];
+} mess_lc_vfs_fchmod;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fchmod);
+
+typedef struct {
+	int fd;
+	int cmd;
+	int arg_int;
+	vir_bytes arg_ptr;	/* struct flock * */
+
+	uint8_t padding[40];
+} mess_lc_vfs_fcntl;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fcntl);
+
+typedef struct {
+	int fd;
+	vir_bytes buf;		/* struct stat * */
+
+	uint8_t padding[48];
+} mess_lc_vfs_fstat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fstat);
+
+typedef struct {
+	int fd;
+
+	uint8_t padding[52];
+} mess_lc_vfs_fsync;
+_ASSERT_MSG_SIZE(mess_lc_vfs_fsync);
+
+typedef struct {
+	cp_grant_id_t grant;
+	int pid;
+	vir_bytes buff_p;
+	size_t buff_sz;
+
+	uint8_t padding[40];
+} mess_lc_vfs_gcov;
+_ASSERT_MSG_SIZE(mess_lc_vfs_gcov);
+
+typedef struct {
+	int32_t flags;
+	size_t len;
+	vir_bytes buf;		/* struct statvfs */
+
+	uint8_t padding[44];
+} mess_lc_vfs_getvfsstat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_getvfsstat);
+
+typedef struct {
+	int fd;
+	unsigned long req;
+	vir_bytes arg;
+
+	uint8_t padding[44];
+} mess_lc_vfs_ioctl;
+_ASSERT_MSG_SIZE(mess_lc_vfs_ioctl);
+
+typedef struct {
+	vir_bytes name1;
+	vir_bytes name2;
+	size_t len1;
+	size_t len2;
+
+	uint8_t padding[40];
+} mess_lc_vfs_link;
+_ASSERT_MSG_SIZE(mess_lc_vfs_link);
+
+typedef struct {
+	off_t offset;
+
+	int fd;
+	int whence;
+
+	uint8_t padding[40];
+} mess_lc_vfs_lseek;
+_ASSERT_MSG_SIZE(mess_lc_vfs_lseek);
+
+typedef struct {
+	dev_t device;
+
+	vir_bytes name;
+	size_t len;
+	mode_t mode;
+
+	uint8_t padding[36];
+} mess_lc_vfs_mknod;
+_ASSERT_MSG_SIZE(mess_lc_vfs_mknod);
+
+typedef struct {
+	int flags;
+	size_t devlen;
+	size_t pathlen;
+	size_t typelen;
+	size_t labellen;
+	vir_bytes dev;
+	vir_bytes path;
+	vir_bytes type;
+	vir_bytes label;
+
+	uint8_t padding[20];
+} mess_lc_vfs_mount;
+_ASSERT_MSG_SIZE(mess_lc_vfs_mount);
+
+typedef struct {
+	vir_bytes name;
+	size_t len;
+	int flags;
+	mode_t mode;
+	char buf[M_PATH_STRING_MAX];
+} mess_lc_vfs_path;
+_ASSERT_MSG_SIZE(mess_lc_vfs_path);
+
+typedef struct {
+	int fd0;
+	int fd1;
+	int flags;
+
+	uint8_t padding[44];
+} mess_lc_vfs_pipe2;
+_ASSERT_MSG_SIZE(mess_lc_vfs_pipe2);
+
+typedef struct {
+	vir_bytes name;		/* const char * */
+	size_t namelen;
+	vir_bytes buf;
+	size_t bufsize;
+
+	uint8_t padding[40];
+} mess_lc_vfs_readlink;
+_ASSERT_MSG_SIZE(mess_lc_vfs_readlink);
+
+typedef struct {
+	int fd;
+	vir_bytes buf;
+	size_t len;
+
+	uint8_t padding[44];
+} mess_lc_vfs_readwrite;
+_ASSERT_MSG_SIZE(mess_lc_vfs_readwrite);
+
+typedef struct {
+	vir_bytes addr;
+
+	uint8_t padding[52];
+} mess_lc_vfs_rusage;
+_ASSERT_MSG_SIZE(mess_lc_vfs_rusage);
+
+typedef struct {
+	uint32_t nfds;
+	fd_set *readfds;
+	fd_set *writefds;
+	fd_set *errorfds;
+	vir_bytes timeout;	/* user-provided 'struct timeval *' */
+
+	uint8_t padding[36];
+} mess_lc_vfs_select;
+_ASSERT_MSG_SIZE(mess_lc_vfs_select);
+
+typedef struct {
+	size_t len;
+	vir_bytes name;		/* const char * */
+	vir_bytes buf;		/* struct stat * */
+
+	uint8_t padding[44];
+} mess_lc_vfs_stat;
+_ASSERT_MSG_SIZE(mess_lc_vfs_stat);
+
+typedef struct {
+	int fd;
+	int flags;
+	size_t len;
+	vir_bytes name;
+	vir_bytes buf;
+
+	uint8_t padding[36];
+} mess_lc_vfs_statvfs1;
+_ASSERT_MSG_SIZE(mess_lc_vfs_statvfs1);
+
+typedef struct {
+	off_t offset;
+
+	int fd;
+	vir_bytes name;
+	size_t len;
+
+	uint8_t padding[36];
+} mess_lc_vfs_truncate;
+_ASSERT_MSG_SIZE(mess_lc_vfs_truncate);
+
+typedef struct {
+	mode_t mask;
+
+	uint8_t padding[52];
+} mess_lc_vfs_umask;
+_ASSERT_MSG_SIZE(mess_lc_vfs_umask);
+
+typedef struct {
+	vir_bytes name;
+	size_t namelen;
+	vir_bytes label;
+	size_t labellen;
+
+	uint8_t padding[40];
+} mess_lc_vfs_umount;
+_ASSERT_MSG_SIZE(mess_lc_vfs_umount);
+
+typedef struct {
+	void		*addr;
+	uint8_t		padding[52];
+} mess_lc_vm_brk;
+_ASSERT_MSG_SIZE(mess_lc_vm_brk);
+
+typedef struct {
+	endpoint_t	endpt;
+	void		*addr;
+	void		*ret_addr;
+	uint8_t		padding[44];
+} mess_lc_vm_getphys;
+_ASSERT_MSG_SIZE(mess_lc_vm_getphys);
+
+typedef struct {
+	vir_bytes addr;
+
+	uint8_t padding[52];
+} mess_lc_vm_rusage;
+_ASSERT_MSG_SIZE(mess_lc_vm_rusage);
+
+typedef struct {
+	endpoint_t	forwhom;
+	void		*addr;
+	uint8_t		padding[48];
+} mess_lc_vm_shm_unmap;
+_ASSERT_MSG_SIZE(mess_lc_vm_shm_unmap);
+
+typedef struct {
+	int status;
+	uint32_t id;		/* should be cdev_id_t */
+
+	uint8_t padding[48];
+} mess_lchardriver_vfs_reply;
+_ASSERT_MSG_SIZE(mess_lchardriver_vfs_reply);
+
+typedef struct {
+	int status;
+	int32_t minor;
+
+	uint8_t padding[48];
+} mess_lchardriver_vfs_sel1;
+_ASSERT_MSG_SIZE(mess_lchardriver_vfs_sel1);
+
+typedef struct {
+	int status;
+	int32_t minor;
+
+	uint8_t padding[48];
+} mess_lchardriver_vfs_sel2;
+_ASSERT_MSG_SIZE(mess_lchardriver_vfs_sel2);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ptr;		/* struct exec_info * */
+
+	uint8_t padding[48];
+} mess_lexec_pm_exec_new;
+_ASSERT_MSG_SIZE(mess_lexec_pm_exec_new);
+
+typedef struct {
+	cp_grant_id_t grant;
+
+	uint8_t padding[52];
+} mess_li2cdriver_i2c_busc_i2c_exec;
+_ASSERT_MSG_SIZE(mess_li2cdriver_i2c_busc_i2c_exec);
+
+typedef struct {
+	uint16_t addr; /* FIXME: strictly speaking this is an i2c_addr_t, but
+			  to get it I would need to include
+			  sys/dev/i2c/i2c_io.h, which I am not sure is a good
+			  idea to have everywhere. */
+
+	uint8_t padding[54];
+} mess_li2cdriver_i2c_busc_i2c_reserve;
+_ASSERT_MSG_SIZE(mess_li2cdriver_i2c_busc_i2c_reserve);
+
+typedef struct {
+	int id;
+	int page;
+	int code;
+	int value;
+	int flags;
+
+	uint8_t padding[36];
+} mess_linputdriver_input_event;
+_ASSERT_MSG_SIZE(mess_linputdriver_input_event);
+
+typedef struct {
+        cp_grant_id_t gid;
+	size_t size;
+
+        uint8_t padding[48];
+} mess_lsys_fi_ctl;
+_ASSERT_MSG_SIZE(mess_lsys_fi_ctl);
+
+typedef struct {
+        int status;
+
+        uint8_t padding[52];
+} mess_lsys_fi_reply;
+_ASSERT_MSG_SIZE(mess_lsys_fi_reply);
+
+typedef struct {
+	int what;
+	vir_bytes where;
+	size_t size;
+
+	uint8_t padding[44];
+} mess_lsys_getsysinfo;
+_ASSERT_MSG_SIZE(mess_lsys_getsysinfo);
+
+typedef struct {
+	size_t size;
+	phys_bytes addr;
+	vir_bytes buf;
+
+	uint8_t padding[44];
+} mess_lsys_krn_readbios;
+_ASSERT_MSG_SIZE(mess_lsys_krn_readbios);
+
+typedef struct {
+	endpoint_t	from_to;
+	cp_grant_id_t	gid;
+	size_t		offset;
+	void		*address;
+	size_t		bytes;
+	uint8_t padding[36];
+} mess_lsys_kern_safecopy;
+_ASSERT_MSG_SIZE(mess_lsys_kern_safecopy);
+
+typedef struct {
+	uint32_t flags;
+	endpoint_t endpoint;
+	int priority;
+	int quantum;
+	int cpu;
+
+	uint8_t padding[36];
+} mess_lsys_krn_schedctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_schedctl);
+
+typedef struct {
+	endpoint_t endpoint;
+	int quantum;
+	int priority;
+	int cpu;
+
+	uint8_t padding[40];
+} mess_lsys_krn_schedule;
+_ASSERT_MSG_SIZE(mess_lsys_krn_schedule);
+
+typedef struct {
+	int how;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_abort;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_abort);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_clear;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_clear);
+
+typedef struct {
+	endpoint_t src_endpt;
+	vir_bytes src_addr;
+	endpoint_t dst_endpt;
+	vir_bytes dst_addr;
+	phys_bytes nr_bytes;
+	int flags;
+
+	uint8_t padding[32];
+} mess_lsys_krn_sys_copy;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_copy);
+
+typedef struct {
+	endpoint_t endpt;
+	int action;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_cprof;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_cprof);
+
+typedef struct {
+	int request;
+	int port;
+	uint32_t value;
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_devio;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_devio);
+
+typedef struct {
+	int code;
+	vir_bytes buf;
+	int len;
+	endpoint_t endpt;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_diagctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_diagctl);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ip;
+	vir_bytes stack;
+	vir_bytes name;
+	vir_bytes ps_str;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_exec;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_exec);
+
+typedef struct {
+	endpoint_t endpt;
+	endpoint_t slot;
+	uint32_t flags;
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_fork;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_fork);
+
+typedef struct {
+	int request;
+	endpoint_t endpt;
+	vir_bytes val_ptr;
+	int val_len;
+	vir_bytes val_ptr2;
+	int val_len2_e;
+
+	uint8_t padding[32];
+} mess_lsys_krn_sys_getinfo;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_getinfo);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ctx_ptr;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_getmcontext;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_getmcontext);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_iopenable;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_iopenable);
+
+typedef struct {
+	int request;
+	int vector;
+	int policy;
+	int hook_id;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_irqctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_irqctl);
+
+typedef struct {
+	phys_bytes base;
+	phys_bytes count;
+	unsigned long pattern;
+	endpoint_t process;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_memset;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_memset);
+
+typedef struct {
+	int request;
+	endpoint_t endpt;
+	vir_bytes arg_ptr;
+	phys_bytes phys_start;
+	phys_bytes phys_len;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_privctl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_privctl);
+
+typedef struct {
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_profbuf;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_profbuf);
+
+typedef struct {
+	int request;
+	long int port;
+	endpoint_t vec_endpt;
+	phys_bytes vec_addr;
+	vir_bytes vec_size;
+	vir_bytes offset;
+
+	uint8_t padding[32];
+} mess_lsys_krn_sys_sdevio;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_sdevio);
+
+typedef struct {
+	clock_t exp_time;
+	clock_t time_left;
+	int abs_time;
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_setalarm;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setalarm);
+
+typedef struct {
+	vir_bytes addr;			/* cp_grant_t * */
+	int size;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_setgrant;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setgrant);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes ctx_ptr;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_setmcontext;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_setmcontext);
+
+typedef struct {
+	time_t sec;		/* time in seconds since 1970 */
+	long int nsec;
+	int now;		/* non-zero for immediate, 0 for adjtime */
+	clockid_t clock_id;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_settime;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_settime);
+
+typedef struct {
+	int action;
+	int freq;
+	int intr_type;
+	endpoint_t endpt;
+	vir_bytes ctl_ptr;
+	vir_bytes mem_ptr;
+	size_t mem_size;
+
+	uint8_t padding[28];
+} mess_lsys_krn_sys_sprof;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_sprof);
+
+typedef struct {
+	int request;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_statectl;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_statectl);
+
+typedef struct {
+	time_t boot_time;
+
+	uint8_t padding[48];
+} mess_lsys_krn_sys_stime;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_stime);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_krn_sys_times;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_times);
+
+typedef struct {
+	int request;
+	endpoint_t endpt;
+	vir_bytes address;
+	long int data;
+
+	uint8_t padding[40];
+} mess_lsys_krn_sys_trace;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_trace);
+
+typedef struct {
+	endpoint_t src_endpt;
+	int segment;
+	vir_bytes src_addr;
+	endpoint_t dst_endpt;
+	int nr_bytes;
+
+	uint8_t padding[36];
+} mess_lsys_krn_sys_umap;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_umap);
+
+
+typedef struct {
+	int request;
+	int vec_size;
+	vir_bytes vec_addr;		/* pv{b,w,l}_pair_t * */
+
+	uint8_t padding[44];
+} mess_lsys_krn_sys_vdevio;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_vdevio);
+
+typedef struct {
+	endpoint_t endpt;
+	vir_bytes vaddr;			/* struct vumap_vir * */
+	int vcount;
+	vir_bytes paddr;			/* struct vumap_phys * */
+	int pmax;
+	int access;
+	size_t offset;
+
+	uint8_t padding[28];
+} mess_lsys_krn_sys_vumap;
+_ASSERT_MSG_SIZE(mess_lsys_krn_sys_vumap);
+
+typedef struct {
+	void		*vec_addr;
+	int		vec_size;
+	uint8_t padding[48];
+} mess_lsys_kern_vsafecopy;
+_ASSERT_MSG_SIZE(mess_lsys_kern_vsafecopy);
+
+typedef struct {
+	int devind;
+	int port;
+
+	uint8_t padding[48];
+} mess_lsys_pci_busc_get_bar;
+_ASSERT_MSG_SIZE(mess_lsys_pci_busc_get_bar);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_lsys_pm_getepinfo;
+_ASSERT_MSG_SIZE(mess_lsys_pm_getepinfo);
+
+typedef struct {
+	pid_t pid;
+
+	uint8_t padding[52];
+} mess_lsys_pm_getprocnr;
+_ASSERT_MSG_SIZE(mess_lsys_pm_getprocnr);
+
+typedef struct {
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t padding[48];
+} mess_lsys_pm_srv_fork;
+_ASSERT_MSG_SIZE(mess_lsys_pm_srv_fork);
+
+typedef struct {
+	endpoint_t endpoint;
+	endpoint_t parent;
+	int maxprio;
+	int quantum;
+
+	uint8_t padding[40];
+} mess_lsys_sched_scheduling_start;
+_ASSERT_MSG_SIZE(mess_lsys_sched_scheduling_start);
+
+typedef struct {
+	endpoint_t endpoint;
+
+	uint8_t padding[52];
+} mess_lsys_sched_scheduling_stop;
+_ASSERT_MSG_SIZE(mess_lsys_sched_scheduling_stop);
+
+typedef struct {
+	int request;
+	vir_bytes arg;
+
+	uint8_t padding[48];
+} mess_lsys_svrctl;
+_ASSERT_MSG_SIZE(mess_lsys_svrctl);
+
+typedef struct {
+	int request;
+	int fkeys;
+	int sfkeys;
+
+	uint8_t padding[44];
+} mess_lsys_tty_fkey_ctl;
+_ASSERT_MSG_SIZE(mess_lsys_tty_fkey_ctl);
+
+typedef struct {
+	endpoint_t endpt;
+	cp_grant_id_t grant;
+	size_t count;
+
+	uint8_t padding[44];
+} mess_lsys_vfs_checkperms;
+_ASSERT_MSG_SIZE(mess_lsys_vfs_checkperms);
+
+typedef struct {
+	endpoint_t endpt;
+	int fd;
+	int what;
+
+	uint8_t padding[44];
+} mess_lsys_vfs_copyfd;
+_ASSERT_MSG_SIZE(mess_lsys_vfs_copyfd);
+
+typedef struct {
+	devmajor_t major;
+	size_t labellen;
+	vir_bytes label;
+
+	uint8_t padding[44];
+} mess_lsys_vfs_mapdriver;
+_ASSERT_MSG_SIZE(mess_lsys_vfs_mapdriver);
+
+typedef struct {
+	endpoint_t	endpt;
+	void		*addr;
+	int		retc;
+	uint8_t		padding[44];
+} mess_lsys_vm_getref;
+_ASSERT_MSG_SIZE(mess_lsys_vm_getref);
+
+typedef struct {
+	int		what;
+	endpoint_t	ep;
+	int		count;
+	void		*ptr;
+	vir_bytes	next;
+	uint8_t		padding[36];
+} mess_lsys_vm_info;
+_ASSERT_MSG_SIZE(mess_lsys_vm_info);
+
+typedef struct {
+	endpoint_t	ep;
+	phys_bytes	phaddr;
+	size_t		len;
+	void		*reply;
+	uint8_t		padding[40];
+} mess_lsys_vm_map_phys;
+_ASSERT_MSG_SIZE(mess_lsys_vm_map_phys);
+
+typedef struct {
+	endpoint_t	ret_pt;
+	int		is_more;
+	uint8_t		padding[48];
+} mess_lsys_vm_query_exit;
+_ASSERT_MSG_SIZE(mess_lsys_vm_query_exit);
+
+typedef struct {
+	endpoint_t	ep;
+	void		*vaddr;
+	uint8_t		padding[48];
+} mess_lsys_vm_unmap_phys;
+_ASSERT_MSG_SIZE(mess_lsys_vm_unmap_phys);
+
+typedef struct {
+	endpoint_t src;
+	endpoint_t dst;
+	uint8_t		padding[48];
+} mess_lsys_vm_update;
+_ASSERT_MSG_SIZE(mess_lsys_vm_update);
+
+typedef struct {
+	endpoint_t	destination;
+	endpoint_t	source;
+	void		*dest_addr;
+	void		*src_addr;
+	size_t		size;
+	void		*ret_addr;
+	uint8_t		padding[32];
+} mess_lsys_vm_vmremap;
+_ASSERT_MSG_SIZE(mess_lsys_vm_vmremap);
+
+typedef struct {
+	endpoint_t	ep;
+	uint8_t		padding[52];
+} mess_lsys_vm_watch_exit;
+_ASSERT_MSG_SIZE(mess_lsys_vm_watch_exit);
+
+typedef struct {
+	off_t offset;
+	void *addr;
+	size_t len;
+	int prot;
+	int flags;
+	int fd;
+	endpoint_t forwhom;
+	void *retaddr;
+	u32_t padding[5];
+} mess_mmap;
+_ASSERT_MSG_SIZE(mess_mmap);
+
+typedef struct {
+	int mode;
+
+	uint8_t padding[52];
+} mess_net_netdrv_dl_conf;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_conf);
+
+typedef struct {
+	cp_grant_id_t grant;
+
+	uint8_t padding[52];
+} mess_net_netdrv_dl_getstat_s;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_getstat_s);
+
+typedef struct {
+	cp_grant_id_t grant;
+	int count;
+
+	uint8_t padding[48];
+} mess_net_netdrv_dl_readv_s;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_readv_s);
+
+typedef struct {
+	cp_grant_id_t grant;
+	int count;
+
+	uint8_t padding[48];
+} mess_net_netdrv_dl_writev_s;
+_ASSERT_MSG_SIZE(mess_net_netdrv_dl_writev_s);
+
+typedef struct {
+	int stat;
+	uint8_t hw_addr[6];
+
+	uint8_t padding[46];
+} mess_netdrv_net_dl_conf;
+_ASSERT_MSG_SIZE(mess_netdrv_net_dl_conf);
+
+typedef struct {
+	int count;
+	uint32_t flags;
+
+	uint8_t padding[48];
+} mess_netdrv_net_dl_task;
+_ASSERT_MSG_SIZE(mess_netdrv_net_dl_task);
+
+typedef struct {
+	u64_t timestamp;	/* valid for every notify msg */
+	u64_t interrupts;	/* raised interrupts; valid if from HARDWARE */
+	sigset_t sigset;	/* raised signals; valid if from SYSTEM */
+	uint8_t padding[24];
+} mess_notify;
+_ASSERT_MSG_SIZE(mess_notify);
+
+typedef struct {
+	int base;
+	size_t size;
+	uint32_t flags;
+
+	uint8_t padding[44];
+} mess_pci_lsys_busc_get_bar;
+_ASSERT_MSG_SIZE(mess_pci_lsys_busc_get_bar);
+
+typedef struct {
+	uid_t egid;
+
+	uint8_t padding[52];
+} mess_pm_lc_getgid;
+_ASSERT_MSG_SIZE(mess_pm_lc_getgid);
+
+typedef struct {
+	pid_t parent_pid;
+
+	uint8_t padding[52];
+} mess_pm_lc_getpid;
+_ASSERT_MSG_SIZE(mess_pm_lc_getpid);
+
+typedef struct {
+	uid_t euid;
+
+	uint8_t padding[52];
+} mess_pm_lc_getuid;
+_ASSERT_MSG_SIZE(mess_pm_lc_getuid);
+
+typedef struct {
+	long data;
+
+	uint8_t padding[52];
+} mess_pm_lc_ptrace;
+_ASSERT_MSG_SIZE(mess_pm_lc_ptrace);
+
+typedef struct {
+	sigset_t set;
+
+	uint8_t padding[40];
+} mess_pm_lc_sigset;
+_ASSERT_MSG_SIZE(mess_pm_lc_sigset);
+
+typedef struct {
+	time_t sec;
+
+	long nsec;
+
+	uint8_t padding[44];
+} mess_pm_lc_time;
+_ASSERT_MSG_SIZE(mess_pm_lc_time);
+
+typedef struct {
+	int status;
+
+	uint8_t padding[52];
+} mess_pm_lc_waitpid;
+_ASSERT_MSG_SIZE(mess_pm_lc_waitpid);
+
+typedef struct {
+	int suid;
+
+	uint8_t padding[52];
+} mess_pm_lexec_exec_new;
+_ASSERT_MSG_SIZE(mess_pm_lexec_exec_new);
+
+typedef struct {
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t padding[48];
+} mess_pm_lsys_getepinfo;
+_ASSERT_MSG_SIZE(mess_pm_lsys_getepinfo);
+
+typedef struct {
+	endpoint_t endpt;
+
+	uint8_t padding[52];
+} mess_pm_lsys_getprocnr;
+_ASSERT_MSG_SIZE(mess_pm_lsys_getprocnr);
+
+typedef struct {
+	int num;
+
+	uint8_t padding[52];
+} mess_pm_lsys_sigs_signal;
+_ASSERT_MSG_SIZE(mess_pm_lsys_sigs_signal);
+
+typedef struct {
+	endpoint_t endpoint;
+	uint32_t maxprio;
+
+	uint8_t padding[48];
+} mess_pm_sched_scheduling_set_nice;
+_ASSERT_MSG_SIZE(mess_pm_sched_scheduling_set_nice);
+
+typedef struct {
+	int status;
+
+	uint8_t padding[52];
+} mess_readclock_lc_rtcdev;
+_ASSERT_MSG_SIZE(mess_readclock_lc_rtcdev);
+
+typedef struct {
+	int		result;
+	int		type;
+	cp_grant_id_t	rproctab_gid;
+	endpoint_t	old_endpoint;
+	uint8_t padding[40];
+} mess_rs_init;
+_ASSERT_MSG_SIZE(mess_rs_init);
+
+typedef struct {
+	endpoint_t endpt;
+	int result;
+	vir_bytes pc;
+	vir_bytes ps_str;
+
+	uint8_t padding[40];
+} mess_rs_pm_exec_restart;
+_ASSERT_MSG_SIZE(mess_rs_pm_exec_restart);
+
+typedef struct {
+	pid_t pid;
+	int nr;
+
+	uint8_t padding[48];
+} mess_rs_pm_srv_kill;
+_ASSERT_MSG_SIZE(mess_rs_pm_srv_kill);
+
+typedef struct {
+	int		len;
+	int		name_len;
+	endpoint_t	endpoint;
+	void		*addr;
+	const char	*name;
+	uint8_t padding[36];
+} mess_rs_req;
+_ASSERT_MSG_SIZE(mess_rs_req);
+
+typedef struct {
+	int		result;
+	int		state;
+	int		prepare_maxtime;
+	uint8_t padding[44];
+} mess_rs_update;
+_ASSERT_MSG_SIZE(mess_rs_update);
+
+typedef struct {
+	endpoint_t scheduler;
+
+	uint8_t padding[52];
+} mess_sched_lsys_scheduling_start;
+_ASSERT_MSG_SIZE(mess_sched_lsys_scheduling_start);
+
+/* For SYS_GETKSIG, _ENDKSIG, _KILL, _SIGSEND, _SIGRETURN. */
+typedef struct {
+	sigset_t map;		/* used to pass signal bit map */
+	endpoint_t endpt;	/* process number for inform */
+	int sig;		/* signal number to send */
+	void *sigctx;		/* pointer to signal context */
+	uint8_t padding[28];
+} mess_sigcalls;
+_ASSERT_MSG_SIZE(mess_sigcalls);
+
+typedef struct {
+	int fkeys;
+	int sfkeys;
+
+	uint8_t padding[48];
+} mess_tty_lsys_fkey_ctl;
+_ASSERT_MSG_SIZE(mess_tty_lsys_fkey_ctl);
+
+typedef struct {
+	dev_t device;
+	off_t seek_pos;
+
+	cp_grant_id_t grant;
+	size_t nbytes;
+
+	uint8_t data[32];
+} mess_vfs_fs_breadwrite;
+_ASSERT_MSG_SIZE(mess_vfs_fs_breadwrite);
+
+typedef struct {
+	ino_t inode;
+
+	mode_t mode;
+
+	uint8_t data[44];
+} mess_vfs_fs_chmod;
+_ASSERT_MSG_SIZE(mess_vfs_fs_chmod);
+
+typedef struct {
+	ino_t inode;
+
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[40];
+} mess_vfs_fs_chown;
+_ASSERT_MSG_SIZE(mess_vfs_fs_chown);
+
+typedef struct {
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[28];
+} mess_vfs_fs_create;
+_ASSERT_MSG_SIZE(mess_vfs_fs_create);
+
+typedef struct {
+	dev_t device;
+
+	uint8_t data[48];
+} mess_vfs_fs_flush;
+_ASSERT_MSG_SIZE(mess_vfs_fs_flush);
+
+typedef struct {
+	ino_t inode;
+	off_t trc_start;
+	off_t trc_end;
+
+	uint8_t data[32];
+} mess_vfs_fs_ftrunc;
+_ASSERT_MSG_SIZE(mess_vfs_fs_ftrunc);
+
+typedef struct {
+	ino_t inode;
+	off_t seek_pos;
+
+	cp_grant_id_t grant;
+	size_t mem_size;
+
+	uint8_t data[32];
+} mess_vfs_fs_getdents;
+_ASSERT_MSG_SIZE(mess_vfs_fs_getdents);
+
+typedef struct {
+	ino_t inode;
+
+	uint8_t data[48];
+} mess_vfs_fs_inhibread;
+_ASSERT_MSG_SIZE(mess_vfs_fs_inhibread);
+
+typedef struct {
+	ino_t inode;
+	ino_t dir_ino;
+
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[32];
+} mess_vfs_fs_link;
+_ASSERT_MSG_SIZE(mess_vfs_fs_link);
+
+typedef struct {
+	ino_t dir_ino;
+	ino_t root_ino;
+
+	uint32_t flags;
+	size_t path_len;
+	size_t path_size;
+	size_t ucred_size;
+	cp_grant_id_t grant_path;
+	cp_grant_id_t grant_ucred;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[8];
+} mess_vfs_fs_lookup;
+_ASSERT_MSG_SIZE(mess_vfs_fs_lookup);
+
+typedef struct {
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[28];
+} mess_vfs_fs_mkdir;
+_ASSERT_MSG_SIZE(mess_vfs_fs_mkdir);
+
+typedef struct {
+	dev_t device;
+	ino_t inode;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[20];
+} mess_vfs_fs_mknod;
+_ASSERT_MSG_SIZE(mess_vfs_fs_mknod);
+
+typedef struct {
+	ino_t inode;
+
+	uint8_t data[48];
+} mess_vfs_fs_mountpoint;
+_ASSERT_MSG_SIZE(mess_vfs_fs_mountpoint);
+
+typedef struct {
+	dev_t device;
+
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[40];
+} mess_vfs_fs_new_driver;
+_ASSERT_MSG_SIZE(mess_vfs_fs_new_driver);
+
+typedef struct {
+	dev_t device;
+
+	mode_t mode;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[36];
+} mess_vfs_fs_newnode;
+_ASSERT_MSG_SIZE(mess_vfs_fs_newnode);
+
+typedef struct {
+	uint64_t count;
+	ino_t inode;
+
+	uint8_t data[40];
+} mess_vfs_fs_putnode;
+_ASSERT_MSG_SIZE(mess_vfs_fs_putnode);
+
+typedef struct {
+	ino_t inode;
+
+	cp_grant_id_t grant;
+	size_t mem_size;
+
+	uint8_t data[40];
+} mess_vfs_fs_rdlink;
+_ASSERT_MSG_SIZE(mess_vfs_fs_rdlink);
+
+typedef struct {
+	dev_t device;
+
+	uint32_t flags;
+	size_t path_len;
+	cp_grant_id_t grant;
+
+	uint8_t data[36];
+} mess_vfs_fs_readsuper;
+_ASSERT_MSG_SIZE(mess_vfs_fs_readsuper);
+
+typedef struct {
+	ino_t inode;
+	off_t seek_pos;
+
+	cp_grant_id_t grant;
+	size_t nbytes;
+
+	uint8_t data[32];
+} mess_vfs_fs_readwrite;
+_ASSERT_MSG_SIZE(mess_vfs_fs_readwrite);
+
+typedef struct {
+	ino_t dir_old;
+	ino_t dir_new;
+
+	size_t len_old;
+	size_t len_new;
+	cp_grant_id_t grant_old;
+	cp_grant_id_t grant_new;
+
+	uint8_t data[24];
+} mess_vfs_fs_rename;
+_ASSERT_MSG_SIZE(mess_vfs_fs_rename);
+
+typedef struct {
+	ino_t inode;
+
+	size_t path_len;
+	size_t mem_size;
+	cp_grant_id_t grant_path;
+	cp_grant_id_t grant_target;
+	uid_t uid;
+	gid_t gid;
+
+	uint8_t data[24];
+} mess_vfs_fs_slink;
+_ASSERT_MSG_SIZE(mess_vfs_fs_slink);
+
+typedef struct {
+	ino_t inode;
+
+	cp_grant_id_t grant;
+
+	uint8_t data[44];
+} mess_vfs_fs_stat;
+_ASSERT_MSG_SIZE(mess_vfs_fs_stat);
+
+typedef struct {
+	cp_grant_id_t grant;
+
+	uint8_t data[52];
+} mess_vfs_fs_statvfs;
+_ASSERT_MSG_SIZE(mess_vfs_fs_statvfs);
+
+typedef struct {
+	ino_t inode;
+
+	cp_grant_id_t grant;
+	size_t path_len;
+
+	uint8_t data[40];
+} mess_vfs_fs_unlink;
+_ASSERT_MSG_SIZE(mess_vfs_fs_unlink);
+
+typedef struct {
+	ino_t inode;
+	time_t actime;
+	time_t modtime;
+
+	uint32_t acnsec;
+	uint32_t modnsec;
+
+	uint8_t data[24];
+} mess_vfs_fs_utime;
+_ASSERT_MSG_SIZE(mess_vfs_fs_utime);
+
+typedef struct {
+	off_t offset;
+
+	uint8_t padding[48];
+} mess_vfs_lc_lseek;
+_ASSERT_MSG_SIZE(mess_vfs_lc_lseek);
+
+typedef struct {
+	endpoint_t id;
+	devminor_t minor;
+
+	uint8_t padding[48];
+} mess_vfs_lchardriver_cancel;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_cancel);
+
+typedef struct {
+	endpoint_t id;
+	endpoint_t user;
+	devminor_t minor;
+	int access;
+
+	uint8_t padding[40];
+} mess_vfs_lchardriver_openclose;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_openclose);
+
+typedef struct {
+	off_t pos;
+	cp_grant_id_t grant;
+	size_t count;
+	int request;
+	int flags;
+	endpoint_t id;
+	endpoint_t user;
+	devminor_t minor;
+
+	uint8_t padding[20];
+} mess_vfs_lchardriver_readwrite;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_readwrite);
+
+typedef struct {
+	devminor_t minor;
+	int ops;
+
+	uint8_t padding[48];
+} mess_vfs_lchardriver_select;
+_ASSERT_MSG_SIZE(mess_vfs_lchardriver_select);
+
+typedef struct {
+	time_t atime;
+	time_t mtime;
+	long ansec;
+	long mnsec;
+	size_t len;
+	char *name;
+	int fd;
+	int flags;
+	uint8_t padding[16];
+} mess_vfs_utimens;
+_ASSERT_MSG_SIZE(mess_vfs_utimens);
+
+typedef struct {
+	off_t offset;
+	dev_t dev;
+	ino_t ino;
+	endpoint_t who;
+	u32_t vaddr;
+	u32_t len;
+	u32_t flags;
+	u32_t fd;
+	u16_t clearend;
+	uint8_t padding[8];
+} mess_vm_vfs_mmap;
+_ASSERT_MSG_SIZE(mess_vm_vfs_mmap);
+
+typedef struct {
+	dev_t dev;	/* 64bits long. */
+	off_t dev_offset;
+	off_t ino_offset;
+	ino_t ino;
+	void *block;
+	u32_t *flags_ptr;
+	u8_t pages;
+	u8_t flags;
+	uint8_t padding[12];
+} mess_vmmcp;
+_ASSERT_MSG_SIZE(mess_vmmcp);
+
+typedef struct {
+	void *addr;
+	u8_t flags;
+	uint8_t padding[51];
+} mess_vmmcp_reply;
+_ASSERT_MSG_SIZE(mess_vmmcp_reply);
+
+typedef struct {
+	endpoint_t m_source;		/* who sent the message */
+	int m_type;			/* what kind of message is it */
+	union {
+		mess_u8			m_u8;
+		mess_u16		m_u16;
+		mess_u32		m_u32;
+		mess_u64		m_u64;
+
+		mess_1			m_m1;
+		mess_2			m_m2;
+		mess_3			m_m3;
+		mess_4			m_m4;
+		mess_7			m_m7;
+		mess_9			m_m9;
+		mess_10			m_m10;
+
+		mess_ds_reply		m_ds_reply;
+		mess_ds_req		m_ds_req;
+		mess_fs_vfs_breadwrite	m_fs_vfs_breadwrite;
+		mess_fs_vfs_chmod	m_fs_vfs_chmod;
+		mess_fs_vfs_chown	m_fs_vfs_chown;
+		mess_fs_vfs_create	m_fs_vfs_create;
+		mess_fs_vfs_getdents	m_fs_vfs_getdents;
+		mess_fs_vfs_lookup	m_fs_vfs_lookup;
+		mess_fs_vfs_newnode	m_fs_vfs_newnode;
+		mess_fs_vfs_rdlink	m_fs_vfs_rdlink;
+		mess_fs_vfs_readsuper	m_fs_vfs_readsuper;
+		mess_fs_vfs_readwrite	m_fs_vfs_readwrite;
+		mess_i2c_li2cdriver_busc_i2c_exec m_i2c_li2cdriver_busc_i2c_exec;
+		mess_i2c_li2cdriver_busc_i2c_reserve m_i2c_li2cdriver_busc_i2c_reserve;
+		mess_input_linputdriver_input_conf m_input_linputdriver_input_conf;
+		mess_input_linputdriver_setleds m_input_linputdriver_setleds;
+		mess_input_tty_event	m_input_tty_event;
+		mess_krn_lsys_schedule	m_krn_lsys_schedule;
+		mess_krn_lsys_sys_devio m_krn_lsys_sys_devio;
+		mess_krn_lsys_sys_fork m_krn_lsys_sys_fork;
+		mess_krn_lsys_sys_getwhoami m_krn_lsys_sys_getwhoami;
+		mess_krn_lsys_sys_irqctl m_krn_lsys_sys_irqctl;
+		mess_krn_lsys_sys_times	m_krn_lsys_sys_times;
+		mess_krn_lsys_sys_trace	m_krn_lsys_sys_trace;
+		mess_krn_lsys_sys_umap	m_krn_lsys_sys_umap;
+		mess_krn_lsys_sys_vumap	m_krn_lsys_sys_vumap;
+		mess_lbdev_lblockdriver_msg m_lbdev_lblockdriver_msg;
+		mess_lblockdriver_lbdev_reply m_lblockdriver_lbdev_reply;
+		mess_lc_ipc_semctl	m_lc_ipc_semctl;
+		mess_lc_ipc_semget	m_lc_ipc_semget;
+		mess_lc_ipc_semop	m_lc_ipc_semop;
+		mess_lc_ipc_shmat	m_lc_ipc_shmat;
+		mess_lc_ipc_shmctl	m_lc_ipc_shmctl;
+		mess_lc_ipc_shmdt	m_lc_ipc_shmdt;
+		mess_lc_ipc_shmget	m_lc_ipc_shmget;
+		mess_lc_pm_cprof	m_lc_pm_cprof;
+		mess_lc_pm_exec		m_lc_pm_exec;
+		mess_lc_pm_exit		m_lc_pm_exit;
+		mess_lc_pm_getsid	m_lc_pm_getsid;
+		mess_lc_pm_groups	m_lc_pm_groups;
+		mess_lc_pm_itimer	m_lc_pm_itimer;
+		mess_lc_pm_mcontext	m_lc_pm_mcontext;
+		mess_lc_pm_priority	m_lc_pm_priority;
+		mess_lc_pm_ptrace	m_lc_pm_ptrace;
+		mess_lc_pm_reboot	m_lc_pm_reboot;
+		mess_lc_pm_rusage	m_lc_pm_rusage;
+		mess_lc_pm_setgid	m_lc_pm_setgid;
+		mess_lc_pm_setuid	m_lc_pm_setuid;
+		mess_lc_pm_sig		m_lc_pm_sig;
+		mess_lc_pm_sigset	m_lc_pm_sigset;
+		mess_lc_pm_sprof	m_lc_pm_sprof;
+		mess_lc_pm_sysuname	m_lc_pm_sysuname;
+		mess_lc_pm_time		m_lc_pm_time;
+		mess_lc_pm_waitpid	m_lc_pm_waitpid;
+		mess_lc_readclock_rtcdev m_lc_readclock_rtcdev;
+		mess_lc_vfs_chown	m_lc_vfs_chown;
+		mess_lc_vfs_close	m_lc_vfs_close;
+		mess_lc_vfs_creat	m_lc_vfs_creat;
+		mess_lc_vfs_fchdir	m_lc_vfs_fchdir;
+		mess_lc_vfs_fchmod	m_lc_vfs_fchmod;
+		mess_lc_vfs_fcntl	m_lc_vfs_fcntl;
+		mess_lc_vfs_fstat	m_lc_vfs_fstat;
+		mess_lc_vfs_fsync	m_lc_vfs_fsync;
+		mess_lc_vfs_gcov	m_lc_vfs_gcov;
+		mess_lc_vfs_getvfsstat	m_lc_vfs_getvfsstat;
+		mess_lc_vfs_ioctl	m_lc_vfs_ioctl;
+		mess_lc_vfs_link	m_lc_vfs_link;
+		mess_lc_vfs_lseek	m_lc_vfs_lseek;
+		mess_lc_vfs_mknod	m_lc_vfs_mknod;
+		mess_lc_vfs_mount	m_lc_vfs_mount;
+		mess_lc_vfs_path	m_lc_vfs_path;
+		mess_lc_vfs_pipe2	m_lc_vfs_pipe2;
+		mess_lc_vfs_readlink	m_lc_vfs_readlink;
+		mess_lc_vfs_readwrite	m_lc_vfs_readwrite;
+		mess_lc_vfs_rusage	m_lc_vfs_rusage;
+		mess_lc_vfs_select	m_lc_vfs_select;
+		mess_lc_vfs_stat	m_lc_vfs_stat;
+		mess_lc_vfs_statvfs1	m_lc_vfs_statvfs1;
+		mess_lc_vfs_truncate	m_lc_vfs_truncate;
+		mess_lc_vfs_umask	m_lc_vfs_umask;
+		mess_lc_vfs_umount	m_lc_vfs_umount;
+		mess_lc_vm_brk		m_lc_vm_brk;
+		mess_lc_vm_getphys	m_lc_vm_getphys;
+		mess_lc_vm_rusage	m_lc_vm_rusage;
+		mess_lc_vm_shm_unmap	m_lc_vm_shm_unmap;
+		mess_lchardriver_vfs_reply m_lchardriver_vfs_reply;
+		mess_lchardriver_vfs_sel1 m_lchardriver_vfs_sel1;
+		mess_lchardriver_vfs_sel2 m_lchardriver_vfs_sel2;
+		mess_lexec_pm_exec_new	m_lexec_pm_exec_new;
+		mess_li2cdriver_i2c_busc_i2c_exec m_li2cdriver_i2c_busc_i2c_exec;
+		mess_li2cdriver_i2c_busc_i2c_reserve m_li2cdriver_i2c_busc_i2c_reserve;
+		mess_linputdriver_input_event m_linputdriver_input_event;
+		mess_lsys_fi_ctl	m_lsys_fi_ctl;
+		mess_lsys_fi_reply	m_lsys_fi_reply;
+		mess_lsys_getsysinfo	m_lsys_getsysinfo;
+		mess_lsys_krn_readbios	m_lsys_krn_readbios;
+		mess_lsys_kern_safecopy	m_lsys_kern_safecopy;
+		mess_lsys_krn_schedctl	m_lsys_krn_schedctl;
+		mess_lsys_krn_schedule	m_lsys_krn_schedule;
+		mess_lsys_krn_sys_abort m_lsys_krn_sys_abort;
+		mess_lsys_krn_sys_clear m_lsys_krn_sys_clear;
+		mess_lsys_krn_sys_copy	m_lsys_krn_sys_copy;
+		mess_lsys_krn_sys_cprof m_lsys_krn_sys_cprof;
+		mess_lsys_krn_sys_devio m_lsys_krn_sys_devio;
+		mess_lsys_krn_sys_diagctl m_lsys_krn_sys_diagctl;
+		mess_lsys_krn_sys_exec	m_lsys_krn_sys_exec;
+		mess_lsys_krn_sys_fork	m_lsys_krn_sys_fork;
+		mess_lsys_krn_sys_getinfo m_lsys_krn_sys_getinfo;
+		mess_lsys_krn_sys_getmcontext m_lsys_krn_sys_getmcontext;
+		mess_lsys_krn_sys_iopenable m_lsys_krn_sys_iopenable;
+		mess_lsys_krn_sys_irqctl m_lsys_krn_sys_irqctl;
+		mess_lsys_krn_sys_memset m_lsys_krn_sys_memset;
+		mess_lsys_krn_sys_privctl m_lsys_krn_sys_privctl;
+		mess_lsys_krn_sys_profbuf m_lsys_krn_sys_profbuf;
+		mess_lsys_krn_sys_sdevio m_lsys_krn_sys_sdevio;
+		mess_lsys_krn_sys_setalarm m_lsys_krn_sys_setalarm;
+		mess_lsys_krn_sys_setgrant m_lsys_krn_sys_setgrant;
+		mess_lsys_krn_sys_setmcontext m_lsys_krn_sys_setmcontext;
+		mess_lsys_krn_sys_settime m_lsys_krn_sys_settime;
+		mess_lsys_krn_sys_sprof m_lsys_krn_sys_sprof;
+		mess_lsys_krn_sys_statectl m_lsys_krn_sys_statectl;
+		mess_lsys_krn_sys_stime	m_lsys_krn_sys_stime;
+		mess_lsys_krn_sys_times	m_lsys_krn_sys_times;
+		mess_lsys_krn_sys_trace	m_lsys_krn_sys_trace;
+		mess_lsys_krn_sys_umap	m_lsys_krn_sys_umap;
+		mess_lsys_krn_sys_vdevio m_lsys_krn_sys_vdevio;
+		mess_lsys_krn_sys_vumap m_lsys_krn_sys_vumap;
+		mess_lsys_kern_vsafecopy m_lsys_kern_vsafecopy;
+		mess_lsys_pci_busc_get_bar m_lsys_pci_busc_get_bar;
+		mess_lsys_pm_getepinfo	m_lsys_pm_getepinfo;
+		mess_lsys_pm_getprocnr	m_lsys_pm_getprocnr;
+		mess_lsys_pm_srv_fork	m_lsys_pm_srv_fork;
+		mess_lsys_sched_scheduling_start m_lsys_sched_scheduling_start;
+		mess_lsys_sched_scheduling_stop m_lsys_sched_scheduling_stop;
+		mess_lsys_svrctl	m_lsys_svrctl;
+		mess_lsys_tty_fkey_ctl	m_lsys_tty_fkey_ctl;
+		mess_lsys_vfs_checkperms m_lsys_vfs_checkperms;
+		mess_lsys_vfs_copyfd	m_lsys_vfs_copyfd;
+		mess_lsys_vfs_mapdriver	m_lsys_vfs_mapdriver;
+		mess_lsys_vm_getref	m_lsys_vm_getref;
+		mess_lsys_vm_info	m_lsys_vm_info;
+		mess_lsys_vm_map_phys	m_lsys_vm_map_phys;
+		mess_lsys_vm_query_exit	m_lsys_vm_query_exit;
+		mess_lsys_vm_unmap_phys	m_lsys_vm_unmap_phys;
+		mess_lsys_vm_update	m_lsys_vm_update;
+		mess_lsys_vm_vmremap	m_lsys_vm_vmremap;
+		mess_lsys_vm_watch_exit	m_lsys_vm_watch_exit;
+		mess_mmap		m_mmap;
+		mess_net_netdrv_dl_conf m_net_netdrv_dl_conf;
+		mess_net_netdrv_dl_getstat_s m_net_netdrv_dl_getstat_s;
+		mess_net_netdrv_dl_readv_s m_net_netdrv_dl_readv_s;
+		mess_net_netdrv_dl_writev_s m_net_netdrv_dl_writev_s;
+		mess_netdrv_net_dl_conf m_netdrv_net_dl_conf;
+		mess_netdrv_net_dl_task m_netdrv_net_dl_task;
+		mess_notify		m_notify;
+		mess_pci_lsys_busc_get_bar m_pci_lsys_busc_get_bar;
+		mess_pm_lc_getgid	m_pm_lc_getgid;
+		mess_pm_lc_getpid	m_pm_lc_getpid;
+		mess_pm_lc_getuid	m_pm_lc_getuid;
+		mess_pm_lc_ptrace	m_pm_lc_ptrace;
+		mess_pm_lc_sigset	m_pm_lc_sigset;
+		mess_pm_lc_time		m_pm_lc_time;
+		mess_pm_lc_waitpid	m_pm_lc_waitpid;
+		mess_pm_lexec_exec_new	m_pm_lexec_exec_new;
+		mess_pm_lsys_getepinfo	m_pm_lsys_getepinfo;
+		mess_pm_lsys_getprocnr	m_pm_lsys_getprocnr;
+		mess_pm_lsys_sigs_signal m_pm_lsys_sigs_signal;
+		mess_pm_sched_scheduling_set_nice m_pm_sched_scheduling_set_nice;
+		mess_readclock_lc_rtcdev m_readclock_lc_rtcdev;
+		mess_rs_init		m_rs_init;
+		mess_rs_pm_exec_restart	m_rs_pm_exec_restart;
+		mess_rs_pm_srv_kill	m_rs_pm_srv_kill;
+		mess_rs_req		m_rs_req;
+		mess_rs_update		m_rs_update;
+		mess_sched_lsys_scheduling_start m_sched_lsys_scheduling_start;
+		mess_sigcalls		m_sigcalls;
+		mess_tty_lsys_fkey_ctl	m_tty_lsys_fkey_ctl;
+		mess_vfs_fs_breadwrite	m_vfs_fs_breadwrite;
+		mess_vfs_fs_chmod	m_vfs_fs_chmod;
+		mess_vfs_fs_chown	m_vfs_fs_chown;
+		mess_vfs_fs_create	m_vfs_fs_create;
+		mess_vfs_fs_flush	m_vfs_fs_flush;
+		mess_vfs_fs_ftrunc	m_vfs_fs_ftrunc;
+		mess_vfs_fs_getdents	m_vfs_fs_getdents;
+		mess_vfs_fs_inhibread	m_vfs_fs_inhibread;
+		mess_vfs_fs_link	m_vfs_fs_link;
+		mess_vfs_fs_lookup	m_vfs_fs_lookup;
+		mess_vfs_fs_mkdir	m_vfs_fs_mkdir;
+		mess_vfs_fs_mknod	m_vfs_fs_mknod;
+		mess_vfs_fs_mountpoint	m_vfs_fs_mountpoint;
+		mess_vfs_fs_new_driver	m_vfs_fs_new_driver;
+		mess_vfs_fs_newnode	m_vfs_fs_newnode;
+		mess_vfs_fs_putnode	m_vfs_fs_putnode;
+		mess_vfs_fs_rdlink	m_vfs_fs_rdlink;
+		mess_vfs_fs_readsuper	m_vfs_fs_readsuper;
+		mess_vfs_fs_readwrite	m_vfs_fs_readwrite;
+		mess_vfs_fs_rename	m_vfs_fs_rename;
+		mess_vfs_fs_slink	m_vfs_fs_slink;
+		mess_vfs_fs_stat	m_vfs_fs_stat;
+		mess_vfs_fs_statvfs	m_vfs_fs_statvfs;
+		mess_vfs_fs_unlink	m_vfs_fs_unlink;
+		mess_vfs_fs_utime	m_vfs_fs_utime;
+		mess_vfs_lc_lseek	m_vfs_lc_lseek;
+		mess_vfs_lchardriver_cancel	m_vfs_lchardriver_cancel;
+		mess_vfs_lchardriver_openclose	m_vfs_lchardriver_openclose;
+		mess_vfs_lchardriver_readwrite	m_vfs_lchardriver_readwrite;
+		mess_vfs_lchardriver_select	m_vfs_lchardriver_select;
+		mess_vfs_utimens	m_vfs_utimens;
+		mess_vm_vfs_mmap	m_vm_vfs_mmap;
+		mess_vmmcp		m_vmmcp;
+		mess_vmmcp_reply	m_vmmcp_reply;
+
+		u8_t size[56];	/* message payload may have 56 bytes at most */
+	};
+} message __aligned(16);
+
+/* Ensure the complete union respects the IPC assumptions. */
+typedef int _ASSERT_message[/* CONSTCOND */sizeof(message) == 64 ? 1 : -1];
+
+/* The following defines provide names for useful members. */
+#define m1_i1  m_m1.m1i1
+#define m1_i2  m_m1.m1i2
+#define m1_i3  m_m1.m1i3
+#define m1_p1  m_m1.m1p1
+#define m1_p2  m_m1.m1p2
+#define m1_p3  m_m1.m1p3
+#define m1_p4  m_m1.m1p4
+#define m1_ull1  m_m1.m1ull1
+
+#define m2_ll1  m_m2.m2ll1
+#define m2_i1  m_m2.m2i1
+#define m2_i2  m_m2.m2i2
+#define m2_i3  m_m2.m2i3
+#define m2_l1  m_m2.m2l1
+#define m2_l2  m_m2.m2l2
+#define m2_p1  m_m2.m2p1
+#define m2_sigset  m_m2.sigset
+
+#define m2_s1  m_m2.m2s1
+
+#define m3_i1  m_m3.m3i1
+#define m3_i2  m_m3.m3i2
+#define m3_p1  m_m3.m3p1
+#define m3_ca1 m_m3.m3ca1
+
+#define m4_ll1  m_m4.m4ll1
+#define m4_l1  m_m4.m4l1
+#define m4_l2  m_m4.m4l2
+#define m4_l3  m_m4.m4l3
+#define m4_l4  m_m4.m4l4
+#define m4_l5  m_m4.m4l5
+
+#define m7_i1  m_m7.m7i1
+#define m7_i2  m_m7.m7i2
+#define m7_i3  m_m7.m7i3
+#define m7_i4  m_m7.m7i4
+#define m7_i5  m_m7.m7i5
+#define m7_p1  m_m7.m7p1
+#define m7_p2  m_m7.m7p2
+
+#define m9_l1  m_m9.m9l1
+#define m9_l2  m_m9.m9l2
+#define m9_l3  m_m9.m9l3
+#define m9_l4  m_m9.m9l4
+#define m9_l5  m_m9.m9l5
+#define m9_s1  m_m9.m9s1
+#define m9_s2  m_m9.m9s2
+#define m9_s3  m_m9.m9s3
+#define m9_s4  m_m9.m9s4
+#define m9_ull1  m_m9.m9ull1
+#define m9_ull2  m_m9.m9ull2
+
+#define m10_i1 m_m10.m10i1
+#define m10_i2 m_m10.m10i2
+#define m10_i3 m_m10.m10i3
+#define m10_i4 m_m10.m10i4
+#define m10_l1 m_m10.m10l1
+#define m10_l2 m_m10.m10l2
+#define m10_l3 m_m10.m10l3
+#define m10_ull1 m_m10.m10ull1
+
+
+/*==========================================================================* 
+ * Minix run-time system (IPC). 					    *
+ *==========================================================================*/ 
+
+/* Datastructure for asynchronous sends */
+typedef struct asynmsg
+{
+	unsigned flags;
+	endpoint_t dst;
+	int result;
+	message msg;
+} asynmsg_t;
+
+/* Defines for flags field */
+#define AMF_EMPTY	000	/* slot is not inuse */
+#define AMF_VALID	001	/* slot contains message */
+#define AMF_DONE	002	/* Kernel has processed the message. The
+				 * result is stored in 'result'
+				 */
+#define AMF_NOTIFY	004	/* Send a notification when AMF_DONE is set */
+#define AMF_NOREPLY	010	/* Not a reply message for a SENDREC */
+#define AMF_NOTIFY_ERR	020	/* Send a notification when AMF_DONE is set and
+				 * delivery of the message failed */
+
+int _ipc_send_intr(endpoint_t dest, message *m_ptr);
+int _ipc_receive_intr(endpoint_t src, message *m_ptr, int *status_ptr);
+int _ipc_sendrec_intr(endpoint_t src_dest, message *m_ptr);
+int _ipc_sendnb_intr(endpoint_t dest, message *m_ptr);
+int _ipc_notify_intr(endpoint_t dest);
+int _ipc_senda_intr(asynmsg_t *table, size_t count);
+
+int _do_kernel_call_intr(message *m_ptr);
+
+int get_minix_kerninfo(struct minix_kerninfo **);
+
+/* Hide names to avoid name space pollution. */
+#define ipc_notify	_ipc_notify
+#define ipc_sendrec	_ipc_sendrec
+#define ipc_receive	_ipc_receive
+#define ipc_receivenb	_ipc_receivenb
+#define ipc_send	_ipc_send
+#define ipc_sendnb	_ipc_sendnb
+#define ipc_senda	_ipc_senda
+
+#define do_kernel_call	_do_kernel_call
+
+struct minix_ipcvecs {
+	int (*send)(endpoint_t dest, message *m_ptr);
+	int (*receive)(endpoint_t src, message *m_ptr, int *st);
+	int (*sendrec)(endpoint_t src_dest, message *m_ptr);
+	int (*sendnb)(endpoint_t dest, message *m_ptr);
+	int (*notify)(endpoint_t dest);
+	int (*do_kernel_call)(message *m_ptr);
+	int (*senda)(asynmsg_t *table, size_t count);
+};
+
+/* kernel-set IPC vectors retrieved by a constructor in
+ * minix/lib/libc/sys/init.c */
+extern struct minix_ipcvecs _minix_ipcvecs;
+
+static inline int _ipc_send(endpoint_t dest, message *m_ptr)
+{
+	return _minix_ipcvecs.send(dest, m_ptr);
+}
+
+static inline int _ipc_receive(endpoint_t src, message *m_ptr, int *st)
+{
+	return _minix_ipcvecs.receive(src, m_ptr, st);
+}
+
+static inline int _ipc_sendrec(endpoint_t src_dest, message *m_ptr)
+{
+	return _minix_ipcvecs.sendrec(src_dest, m_ptr);
+}
+
+static inline int _ipc_sendnb(endpoint_t dest, message *m_ptr)
+{
+	return _minix_ipcvecs.sendnb(dest, m_ptr);
+}
+
+static inline int _ipc_notify(endpoint_t dest)
+{
+	return _minix_ipcvecs.notify(dest);
+}
+
+static inline int _do_kernel_call(message *m_ptr)
+{
+	return _minix_ipcvecs.do_kernel_call(m_ptr);
+}
+
+static inline int _ipc_senda(asynmsg_t *table, size_t count)
+{
+	return _minix_ipcvecs.senda(table, count);
+}
+
+#endif /* _IPC_H */
diff -ruNp srclimpio/minix/include/minix/minix/ipcconst.h proj/minix/include/minix/minix/ipcconst.h
--- srclimpio/minix/include/minix/minix/ipcconst.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/ipcconst.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,36 @@
+#ifndef _IPC_CONST_H
+#define _IPC_CONST_H
+
+#include <machine/ipcconst.h>
+
+ /* System call numbers that are passed when trapping to the kernel. */
+#define SEND		   1	/* blocking send */
+#define RECEIVE		   2	/* blocking receive */
+#define SENDREC	 	   3  	/* SEND + RECEIVE */
+#define NOTIFY		   4	/* asynchronous notify */
+#define SENDNB             5    /* nonblocking send */
+#define MINIX_KERNINFO     6    /* request kernel info structure */
+#define SENDA		   16	/* asynchronous send */
+#define IPCNO_HIGHEST	SENDA
+/* Check that the message payload type doesn't grow past the maximum IPC payload size.
+ * This is a compile time check. */
+#define _ASSERT_MSG_SIZE(msg_type) \
+    typedef int _ASSERT_##msg_type[/* CONSTCOND */sizeof(msg_type) == 56 ? 1 : -1]
+
+/* Macros for IPC status code manipulation. */
+#define IPC_STATUS_CALL_SHIFT	0
+#define IPC_STATUS_CALL_MASK	0x3F
+#define IPC_STATUS_CALL(status)	\
+	(((status) >> IPC_STATUS_CALL_SHIFT) & IPC_STATUS_CALL_MASK)
+#define IPC_STATUS_CALL_TO(call) \
+	(((call) & IPC_STATUS_CALL_MASK) << IPC_STATUS_CALL_SHIFT)
+
+#define IPC_FLG_MSG_FROM_KERNEL	1 /* this message originated in the kernel on
+				     behalf of a process, this is a trusted
+				     message, never reply to the sender
+				 */
+#define IPC_STATUS_FLAGS_SHIFT	16
+#define IPC_STATUS_FLAGS(flgs)	((flgs) << IPC_STATUS_FLAGS_SHIFT)
+#define IPC_STATUS_FLAGS_TEST(status, flgs)	\
+		(((status) >> IPC_STATUS_FLAGS_SHIFT) & (flgs))
+#endif /* IPC_CONST_H */
diff -ruNp srclimpio/minix/include/minix/minix/keymap.h proj/minix/include/minix/minix/keymap.h
--- srclimpio/minix/include/minix/minix/keymap.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/keymap.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,169 @@
+/*	keymap.h - defines for keymapping		Author: Marcus Hampel
+ */
+#ifndef _SYS__KEYMAP_H
+#define _SYS__KEYMAP_H
+
+#define K(k)	[INPUT_KEY_ ## k]	/* Map to key entry */
+
+#define	C(c)	((c) & 0x1F)	/* Map to control code		*/
+#define A(c)	((c) | 0x80)	/* Set eight bit (ALT)		*/
+#define CA(c)	A(C(c))		/* Control-Alt			*/
+#define	N(c)	((c) | HASNUM)	/* Add "Num Lock has effect" attribute */
+#define	L(c)	((c) | HASCAPS)	/* Add "Caps Lock has effect" attribute */
+
+#define EXT	0x0100		/* Normal function keys		*/
+#define CTRLKEY	0x0200		/* Control key			*/
+#define SHIFT	0x0400		/* Shift key			*/
+#define ALT	0x0800		/* Alternate key		*/
+#define HASNUM	0x4000		/* Num Lock has effect		*/
+#define HASCAPS	0x8000		/* Caps Lock has effect		*/
+
+/* The left and right versions for the actual keys in the keymap. */
+#define LCTRL	CTRLKEY
+#define RCTRL	(CTRLKEY | EXT)
+#define LSHIFT	SHIFT
+#define RSHIFT	(SHIFT | EXT)
+#define LALT	ALT
+#define RALT	(ALT | EXT)
+
+/* Delete key */
+#define DEL	0177
+
+/* Numeric keypad */
+#define HOME	(0x01 + EXT)
+#define END	(0x02 + EXT)
+#define UP	(0x03 + EXT)
+#define DOWN	(0x04 + EXT)
+#define LEFT	(0x05 + EXT)
+#define RIGHT	(0x06 + EXT)
+#define PGUP	(0x07 + EXT)
+#define PGDN	(0x08 + EXT)
+#define MID	(0x09 + EXT)
+/* UNUSED	(0x0A + EXT) */
+/* UNUSED	(0x0B + EXT) */
+#define INSRT	(0x0C + EXT)
+
+/* Keys affected by Num Lock */
+#define NHOME	N(HOME)
+#define NEND	N(END)
+#define NUP	N(UP)
+#define NDOWN	N(DOWN)
+#define NLEFT	N(LEFT)
+#define NRIGHT	N(RIGHT)
+#define NPGUP	N(PGUP)
+#define NPGDN	N(PGDN)
+#define NMID	N(MID)
+#define NINSRT	N(INSRT)
+#define NDEL	N(DEL)
+
+/* Alt + Numeric keypad */
+#define AHOME	(0x01 + ALT)
+#define AEND	(0x02 + ALT)
+#define AUP	(0x03 + ALT)
+#define ADOWN	(0x04 + ALT)
+#define ALEFT	(0x05 + ALT)
+#define ARIGHT	(0x06 + ALT)
+#define APGUP	(0x07 + ALT)
+#define APGDN	(0x08 + ALT)
+#define AMID	(0x09 + ALT)
+#define AMIN	(0x0A + ALT)
+#define APLUS	(0x0B + ALT)
+#define AINSRT	(0x0C + ALT)
+
+/* Ctrl + Numeric keypad */
+#define CHOME	(0x01 + CTRLKEY)
+#define CEND	(0x02 + CTRLKEY)
+#define CUP	(0x03 + CTRLKEY)
+#define CDOWN	(0x04 + CTRLKEY)
+#define CLEFT	(0x05 + CTRLKEY)
+#define CRIGHT	(0x06 + CTRLKEY)
+#define CPGUP	(0x07 + CTRLKEY)
+#define CPGDN	(0x08 + CTRLKEY)
+#define CMID	(0x09 + CTRLKEY)
+#define CNMIN	(0x0A + CTRLKEY)
+#define CPLUS	(0x0B + CTRLKEY)
+#define CINSRT	(0x0C + CTRLKEY)
+
+/* Lock keys */
+#define CALOCK	(0x0D + EXT)	/* caps lock	*/
+#define	NLOCK	(0x0E + EXT)	/* number lock	*/
+#define SLOCK	(0x0F + EXT)	/* scroll lock	*/
+
+/* Function keys */
+#define F1	(0x10 + EXT)
+#define F2	(0x11 + EXT)
+#define F3	(0x12 + EXT)
+#define F4	(0x13 + EXT)
+#define F5	(0x14 + EXT)
+#define F6	(0x15 + EXT)
+#define F7	(0x16 + EXT)
+#define F8	(0x17 + EXT)
+#define F9	(0x18 + EXT)
+#define F10	(0x19 + EXT)
+#define F11	(0x1A + EXT)
+#define F12	(0x1B + EXT)
+
+/* Alt+Fn */
+#define AF1	(0x10 + ALT)
+#define AF2	(0x11 + ALT)
+#define AF3	(0x12 + ALT)
+#define AF4	(0x13 + ALT)
+#define AF5	(0x14 + ALT)
+#define AF6	(0x15 + ALT)
+#define AF7	(0x16 + ALT)
+#define AF8	(0x17 + ALT)
+#define AF9	(0x18 + ALT)
+#define AF10	(0x19 + ALT)
+#define AF11	(0x1A + ALT)
+#define AF12	(0x1B + ALT)
+
+/* Ctrl+Fn */
+#define CF1	(0x10 + CTRLKEY)
+#define CF2	(0x11 + CTRLKEY)
+#define CF3	(0x12 + CTRLKEY)
+#define CF4	(0x13 + CTRLKEY)
+#define CF5	(0x14 + CTRLKEY)
+#define CF6	(0x15 + CTRLKEY)
+#define CF7	(0x16 + CTRLKEY)
+#define CF8	(0x17 + CTRLKEY)
+#define CF9	(0x18 + CTRLKEY)
+#define CF10	(0x19 + CTRLKEY)
+#define CF11	(0x1A + CTRLKEY)
+#define CF12	(0x1B + CTRLKEY)
+
+/* Shift+Fn */
+#define SF1	(0x10 + SHIFT)
+#define SF2	(0x11 + SHIFT)
+#define SF3	(0x12 + SHIFT)
+#define SF4	(0x13 + SHIFT)
+#define SF5	(0x14 + SHIFT)
+#define SF6	(0x15 + SHIFT)
+#define SF7	(0x16 + SHIFT)
+#define SF8	(0x17 + SHIFT)
+#define SF9	(0x18 + SHIFT)
+#define SF10	(0x19 + SHIFT)
+#define SF11	(0x1A + SHIFT)
+#define SF12	(0x1B + SHIFT)
+
+/* Alt+Shift+Fn */
+#define ASF1	(0x10 + ALT + SHIFT)
+#define ASF2	(0x11 + ALT + SHIFT)
+#define ASF3	(0x12 + ALT + SHIFT)
+#define ASF4	(0x13 + ALT + SHIFT)
+#define ASF5	(0x14 + ALT + SHIFT)
+#define ASF6	(0x15 + ALT + SHIFT)
+#define ASF7	(0x16 + ALT + SHIFT)
+#define ASF8	(0x17 + ALT + SHIFT)
+#define ASF9	(0x18 + ALT + SHIFT)
+#define ASF10	(0x19 + ALT + SHIFT)
+#define ASF11	(0x1A + ALT + SHIFT)
+#define ASF12	(0x1B + ALT + SHIFT)
+
+#define MAP_COLS	6	/* Number of columns in keymap */
+#define NR_SCAN_CODES	0xE8	/* Number of scan codes (rows in keymap) */
+
+typedef uint16_t keymap_t[NR_SCAN_CODES][MAP_COLS];
+
+#define KEY_MAGIC	"KMAZ"	/* Magic number of keymap file */
+
+#endif /* _SYS__KEYMAP_H */
diff -ruNp srclimpio/minix/include/minix/minix/libminixfs.h proj/minix/include/minix/minix/libminixfs.h
--- srclimpio/minix/include/minix/minix/libminixfs.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/libminixfs.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,82 @@
+/* Prototypes for -lminixfs. */
+
+#ifndef _MINIX_FSLIB_H
+#define _MINIX_FSLIB_H
+
+#include <minix/safecopies.h>
+#include <minix/sef.h>
+#include <minix/vfsif.h>
+
+struct buf {
+  /* Data portion of the buffer. */
+  void *data;
+
+  /* Header portion of the buffer - internal to libminixfs. */
+  struct buf *lmfs_next;       /* used to link all free bufs in a chain */
+  struct buf *lmfs_prev;       /* used to link all free bufs the other way */
+  struct buf *lmfs_hash;       /* used to link bufs on hash chains */
+  block_t lmfs_blocknr;        /* block number of its (minor) device */
+  dev_t lmfs_dev;              /* major | minor device where block resides */
+  char lmfs_count;             /* number of users of this buffer */
+  char lmfs_needsetcache;      /* to be identified to VM */
+  unsigned int lmfs_bytes;     /* Number of bytes allocated in bp */
+  u32_t lmfs_flags;            /* Flags shared between VM and FS */
+
+  /* If any, which inode & offset does this block correspond to?
+   * If none, VMC_NO_INODE
+   */
+  ino_t lmfs_inode;
+  u64_t lmfs_inode_offset;
+};
+
+int fs_lookup_credentials(vfs_ucred_t *credentials,
+        uid_t *caller_uid, gid_t *caller_gid, cp_grant_id_t grant2, size_t cred_size);
+
+void lmfs_markdirty(struct buf *bp);
+void lmfs_markclean(struct buf *bp);
+int lmfs_isclean(struct buf *bp);
+dev_t lmfs_dev(struct buf *bp);
+int lmfs_bytes(struct buf *bp);
+int lmfs_bufs_in_use(void);
+int lmfs_nr_bufs(void);
+void lmfs_flushall(void);
+int lmfs_fs_block_size(void);
+void lmfs_may_use_vmcache(int); 
+void lmfs_set_blocksize(int blocksize, int major); 
+void lmfs_reset_rdwt_err(void); 
+int lmfs_rdwt_err(void); 
+void lmfs_buf_pool(int new_nr_bufs);
+struct buf *lmfs_get_block(dev_t dev, block_t block,int only_search);
+struct buf *lmfs_get_block_ino(dev_t dev, block_t block,int only_search,
+	ino_t ino, u64_t off);
+void lmfs_invalidate(dev_t device);
+void lmfs_put_block(struct buf *bp, int block_type);
+void lmfs_rw_scattered(dev_t, struct buf **, int, int);
+void lmfs_setquiet(int q);
+int lmfs_do_bpeek(message *);
+void lmfs_cache_reevaluate(dev_t dev);
+void lmfs_blockschange(dev_t dev, int delta);
+
+/* calls that libminixfs does into fs */
+void fs_blockstats(u64_t *blocks, u64_t *free, u64_t *used);
+int fs_sync(void);
+
+/* get_block arguments */
+#define NORMAL             0    /* forces get_block to do disk read */
+#define NO_READ            1    /* prevents get_block from doing disk read */
+#define PREFETCH           2    /* tells get_block not to read or mark dev */
+
+/* When a block is released, the type of usage is passed to put_block(). */
+#define ONE_SHOT      0200 /* set if block not likely to be needed soon */
+
+#define INODE_BLOCK        0                             /* inode block */
+#define DIRECTORY_BLOCK    1                             /* directory block */
+#define INDIRECT_BLOCK     2                             /* pointer block */
+#define MAP_BLOCK          3                             /* bit map */
+#define FULL_DATA_BLOCK    5                             /* data, fully used */
+#define PARTIAL_DATA_BLOCK 6                             /* data, partly used*/
+
+#define END_OF_FILE   (-104)        /* eof detected */
+
+#endif /* _MINIX_FSLIB_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/log.h proj/minix/include/minix/minix/log.h
--- srclimpio/minix/include/minix/minix/log.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/log.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,117 @@
+#ifndef __LOG_H__
+#define __LOG_H__
+/*
+ * Simple logging functions
+ */
+
+#include <stdarg.h>
+
+/*
+ * LEVEL_NONE  do not log anything.
+ * LEVEL_WARN  Information that needs to be known.
+ * LEVEL_INFO  Basic information like startup messages and occasional events.
+ * LEVEL_DEBUG debug statements about things happening that are less expected.
+ * LEVEL_TRACE Way to much information for anybody.
+ */
+
+#define LEVEL_NONE 0
+#define LEVEL_WARN 1
+#define LEVEL_INFO 2
+#define LEVEL_DEBUG 3
+#define LEVEL_TRACE 4
+
+static const char *level_string[5] = {
+	"none",
+	"warn",
+	"info",
+	"debug",
+	"trace"
+};
+
+/*
+ * struct to be initialized by the user of the logging system.
+ *
+ * name: The name attribute is used in logging statements do differentiate
+ * drivers
+ *
+ * log_level The level attribute describes the requested logging level. a level
+ * of 1 will only print warnings while a level of 4 will print all the trace
+ * information.
+ *
+ * log_func The logging function to use to log, log.h provides default_log
+ * to display information on the kernel output buffer. As a bonus if the
+ * requested log level is debug or trace the method , file and line number will
+ * be printed to the steam.
+ */
+struct log
+{
+	const char *name;
+	int log_level;
+
+	/* the logging function itself */
+	void (*log_func) (struct log * driver,
+	    int level,
+	    const char *file,
+	    const char *function, int line, const char *fmt, ...);
+
+};
+
+#define __log(driver,log_level, fmt, args...) \
+		((driver)->log_func(driver,log_level, \
+				__FILE__, __FUNCTION__, __LINE__,\
+				fmt, ## args))
+
+/* Log a warning */
+#define log_warn(driver, fmt, args...) \
+		__log(driver, LEVEL_WARN, fmt, ## args)
+
+/* Log an information message  */
+#define log_info(driver, fmt, args...) \
+		__log(driver, LEVEL_INFO, fmt, ## args)
+
+/* log debugging output  */
+#define log_debug(driver, fmt, args...) \
+		__log(driver, LEVEL_DEBUG, fmt, ## args)
+
+/* log trace output  */
+#define log_trace(driver, fmt, args...) \
+		__log(driver, LEVEL_TRACE, fmt, ## args)
+
+#endif /* __LOG_H__ */
+
+static void
+default_log(struct log *driver,
+    int level,
+    const char *file, const char *function, int line, const char *fmt, ...)
+{
+	va_list args;
+
+	if (level > driver->log_level) {
+		return;
+	}
+	/* If the wanted level is debug also display line/method information */
+	if (driver->log_level >= LEVEL_DEBUG) {
+		printf("%s(%s):%s+%d(%s):", driver->name,
+		    level_string[level], file, line, function);
+	} else {
+		printf("%s(%s)", driver->name, level_string[level]);
+	}
+
+	va_start(args, fmt);
+	vprintf(fmt, args);
+	va_end(args);
+}
+
+#ifdef hacks
+static void
+hexdump(unsigned char *d, unsigned int size)
+{
+	int s;
+	for (s = 0; s < size; s += 4) {
+		fprintf(stdout, "0x%04x 0x%02X%02X%02X%02X %c%c%c%c\n", s,
+		    (unsigned int) d[s], (unsigned int) d[s + 1],
+		    (unsigned int) d[s + 2], (unsigned int) d[s + 3], d[s],
+		    d[s + 1], d[s + 2], d[s + 3]);
+	}
+}
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/minlib.h proj/minix/include/minix/minix/minlib.h
--- srclimpio/minix/include/minix/minix/minlib.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/minlib.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,30 @@
+#ifndef _MINLIB
+#define _MINLIB
+
+#include <sys/mount.h>
+
+/* Miscellaneous BSD. */
+char *itoa(int _n);
+
+/* Miscellaneous MINIX. */
+void std_err(const char *_s);
+void prints(const char *_s, ...);
+int fsversion(char *_dev, char *_prog);
+int getprocessor(void);
+void _cpuid(u32_t *eax, u32_t *ebx, u32_t *ecx, u32_t *edx);
+int load_mtab(char *_prog_name);
+uint8_t fs_mode_to_type(mode_t mode);
+int get_mtab_entry(char dev[PATH_MAX], char mount_point[PATH_MAX],
+			char type[MNTNAMELEN], char flags[MNTFLAGLEN]);
+
+/* read_tsc() and friends */
+void read_tsc(u32_t *hi, u32_t *lo);
+void read_tsc_64(u64_t *t);
+
+/* return values for fsversion */
+#define FSVERSION_MFS1	0x00001
+#define FSVERSION_MFS2	0x00002
+#define FSVERSION_MFS3	0x00003
+#define FSVERSION_EXT2	0x10002
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/mmio.h proj/minix/include/minix/minix/mmio.h
--- srclimpio/minix/include/minix/minix/mmio.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/mmio.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,62 @@
+#ifndef __MMIO_H__
+#define __MMIO_H__
+
+#define REG16(x)(*((volatile uint16_t *)(x)))
+#define REG(x)(*((volatile uint32_t *)(x)))
+#define BIT(x)(0x1 << x)
+
+/* Write a uint32_t value to a memory address. */
+static inline void
+write32(uint32_t address, uint32_t value)
+{
+	REG(address) = value;
+}
+
+/* Read an uint32_t from a memory address */
+static inline uint32_t
+read32(uint32_t address)
+{
+	return REG(address);
+}
+
+/* Set a 32 bits value depending on a mask */
+static inline void
+set32(uint32_t address, uint32_t mask, uint32_t value)
+{
+	uint32_t val;
+	val = read32(address);
+	/* clear the bits */
+	val &= ~(mask);
+	/* apply the value using the mask */
+	val |= (value & mask);
+	write32(address, val);
+}
+
+/* Write a uint16_t value to a memory address. */
+static inline void
+write16(uint32_t address, uint16_t value)
+{
+	REG16(address) = value;
+}
+
+/* Read an uint16_t from a memory address */
+static inline uint16_t
+read16(uint32_t address)
+{
+	return REG16(address);
+}
+
+/* Set a 16 bits value depending on a mask */
+static inline void
+set16(uint32_t address, uint16_t mask, uint16_t value)
+{
+	uint16_t val;
+	val = read16(address);
+	/* clear the bits */
+	val &= ~(mask);
+	/* apply the value using the mask */
+	val |= (value & mask);
+	write16(address, val);
+}
+
+#endif /* __MMIO_H__ */
diff -ruNp srclimpio/minix/include/minix/minix/mthread.h proj/minix/include/minix/minix/mthread.h
--- srclimpio/minix/include/minix/minix/mthread.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/mthread.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,239 @@
+#ifndef _MTHREAD_H
+#define _MTHREAD_H
+
+#include <minix/config.h>	/* MUST be first */
+#include <minix/const.h>
+#include <sys/types.h>
+#include <stdio.h>
+#include <ucontext.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <sys/signal.h>
+
+typedef int mthread_thread_t;
+typedef int mthread_once_t;
+typedef int mthread_key_t;
+typedef void * mthread_condattr_t;
+typedef void * mthread_mutexattr_t;
+
+struct __mthread_tcb;
+typedef struct {
+  struct __mthread_tcb *mq_head;
+  struct __mthread_tcb *mq_tail;
+} mthread_queue_t;
+
+struct __mthread_mutex {
+  mthread_queue_t mm_queue;	/* Queue of threads blocked on this mutex */
+  mthread_thread_t mm_owner;	/* Thread ID that currently owns mutex */
+#ifdef MTHREAD_STRICT
+  struct __mthread_mutex *mm_prev;
+  struct __mthread_mutex *mm_next;
+#endif
+  unsigned int mm_magic;
+};
+typedef struct __mthread_mutex *mthread_mutex_t;
+
+struct __mthread_cond {
+  struct __mthread_mutex *mc_mutex;	/* Associate mutex with condition */
+#ifdef MTHREAD_STRICT
+  struct __mthread_cond *mc_prev;
+  struct __mthread_cond *mc_next;
+#endif
+  unsigned int mc_magic;
+};
+typedef struct __mthread_cond *mthread_cond_t;
+
+struct __mthread_attr {
+  size_t ma_stacksize;
+  char *ma_stackaddr;
+  int ma_detachstate;
+  struct __mthread_attr *ma_prev;
+  struct __mthread_attr *ma_next;
+}; 
+typedef struct __mthread_attr *mthread_attr_t;
+
+typedef struct {
+  mthread_mutex_t mutex;
+  mthread_cond_t cond;
+} mthread_event_t;
+
+typedef struct {
+  unsigned int readers;
+  mthread_thread_t writer;
+  mthread_mutex_t queue;
+  mthread_event_t drain;
+} mthread_rwlock_t; 
+
+#define MTHREAD_CREATE_JOINABLE 001
+#define MTHREAD_CREATE_DETACHED 002
+#define MTHREAD_ONCE_INIT 0
+#define MTHREAD_STACK_MIN MINSIGSTKSZ
+#define MTHREAD_KEYS_MAX 128
+
+__BEGIN_DECLS
+/* allocate.c */
+int mthread_create(mthread_thread_t *thread, mthread_attr_t *tattr, void
+	*(*proc)(void *), void *arg);
+int mthread_detach(mthread_thread_t thread);
+int mthread_equal(mthread_thread_t l, mthread_thread_t r);
+void mthread_exit(void *value);
+int mthread_join(mthread_thread_t thread, void **value);
+int mthread_once(mthread_once_t *once, void (*proc)(void));
+mthread_thread_t mthread_self(void);
+
+/* attribute.c */
+int mthread_attr_destroy(mthread_attr_t *tattr);
+int mthread_attr_getdetachstate(mthread_attr_t *tattr, int
+	*detachstate);
+int mthread_attr_getstack(mthread_attr_t *tattr, void **stackaddr,
+	size_t *stacksize);
+int mthread_attr_getstacksize(mthread_attr_t *tattr, size_t *stacksize);
+int mthread_attr_init(mthread_attr_t *tattr);
+int mthread_attr_setdetachstate(mthread_attr_t *tattr, int detachstate);
+int mthread_attr_setstack(mthread_attr_t *tattr, void *stackaddr, size_t
+	stacksize);
+int mthread_attr_setstacksize(mthread_attr_t *tattr, size_t stacksize);
+
+
+/* condition.c */
+int mthread_cond_broadcast(mthread_cond_t *cond);
+int mthread_cond_destroy(mthread_cond_t *cond);
+int mthread_cond_init(mthread_cond_t *cond, mthread_condattr_t *cattr);
+int mthread_cond_signal(mthread_cond_t *cond);
+int mthread_cond_wait(mthread_cond_t *cond, mthread_mutex_t *mutex);
+
+/* key.c */
+int mthread_key_create(mthread_key_t *key, void (*destructor)(void *));
+int mthread_key_delete(mthread_key_t key);
+void *mthread_getspecific(mthread_key_t key);
+int mthread_setspecific(mthread_key_t key, void *value);
+
+/* misc.c */
+void mthread_stats(void);
+void mthread_verify_f(char *f, int l);
+#define mthread_verify() mthread_verify_f(__FILE__, __LINE__)
+void mthread_stacktrace(mthread_thread_t t);
+void mthread_stacktraces(void);
+
+/* mutex.c */
+int mthread_mutex_destroy(mthread_mutex_t *mutex);
+int mthread_mutex_init(mthread_mutex_t *mutex, mthread_mutexattr_t
+	*mattr);
+int mthread_mutex_lock(mthread_mutex_t *mutex);
+int mthread_mutex_trylock(mthread_mutex_t *mutex);
+int mthread_mutex_unlock(mthread_mutex_t *mutex);
+
+/* event.c */
+int mthread_event_destroy(mthread_event_t *event);
+int mthread_event_init(mthread_event_t *event);
+int mthread_event_wait(mthread_event_t *event);
+int mthread_event_fire(mthread_event_t *event);
+int mthread_event_fire_all(mthread_event_t *event);
+
+/* rwlock.c */
+int mthread_rwlock_destroy(mthread_rwlock_t *rwlock);
+int mthread_rwlock_init(mthread_rwlock_t *rwlock);
+int mthread_rwlock_rdlock(mthread_rwlock_t *rwlock);
+int mthread_rwlock_wrlock(mthread_rwlock_t *rwlock);
+int mthread_rwlock_unlock(mthread_rwlock_t *rwlock);
+
+/* schedule.c */
+int mthread_yield(void);
+void mthread_yield_all(void);
+__END_DECLS
+
+#if defined(_MTHREADIFY_PTHREADS)
+typedef mthread_thread_t pthread_t;
+typedef mthread_once_t pthread_once_t;
+typedef mthread_key_t pthread_key_t;
+typedef mthread_cond_t pthread_cond_t;
+typedef mthread_mutex_t pthread_mutex_t;
+typedef mthread_condattr_t pthread_condattr_t;
+typedef mthread_mutexattr_t pthread_mutexattr_t;
+typedef mthread_attr_t pthread_attr_t;
+typedef mthread_event_t pthread_event_t;
+typedef mthread_rwlock_t pthread_rwlock_t;
+
+/* LSC: No equivalent, so void* for now. */
+typedef void *pthread_rwlockattr_t;
+
+#define PTHREAD_ONCE_INIT 0
+#define PTHREAD_MUTEX_INITIALIZER ((pthread_mutex_t) -1)
+#define PTHREAD_COND_INITIALIZER ((pthread_cond_t) -1)
+
+__BEGIN_DECLS
+/* allocate.c */
+int pthread_create(pthread_t *thread, pthread_attr_t *tattr, void
+	*(*proc)(void *), void *arg);
+int pthread_detach(pthread_t thread);
+int pthread_equal(pthread_t l, pthread_t r);
+void pthread_exit(void *value);
+int pthread_join(pthread_t thread, void **value);
+int pthread_once(pthread_once_t *once, void (*proc)(void));
+pthread_t pthread_self(void);
+
+/* attribute.c */
+int pthread_attr_destroy(pthread_attr_t *tattr);
+int pthread_attr_getdetachstate(pthread_attr_t *tattr, int
+	*detachstate);
+int pthread_attr_getstack(pthread_attr_t *tattr, void **stackaddr,
+	size_t *stacksize);
+int pthread_attr_getstacksize(pthread_attr_t *tattr, size_t *stacksize);
+int pthread_attr_init(pthread_attr_t *tattr);
+int pthread_attr_setdetachstate(pthread_attr_t *tattr, int detachstate);
+int pthread_attr_setstack(pthread_attr_t *tattr, void *stackaddr, size_t
+	stacksize);
+int pthread_attr_setstacksize(pthread_attr_t *tattr, size_t stacksize);
+
+/* condition.c */
+int pthread_cond_broadcast(pthread_cond_t *cond);
+int pthread_cond_destroy(pthread_cond_t *cond);
+int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cattr);
+int pthread_cond_signal(pthread_cond_t *cond);
+int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
+
+/* key.c */
+int pthread_key_create(pthread_key_t *key, void (*destructor)(void *));
+int pthread_key_delete(pthread_key_t key);
+void *pthread_getspecific(pthread_key_t key);
+int pthread_setspecific(pthread_key_t key, void *value);
+
+/* mutex.c */
+int pthread_mutex_destroy(pthread_mutex_t *mutex);
+int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t
+	*mattr);
+int pthread_mutex_lock(pthread_mutex_t *mutex);
+int pthread_mutex_trylock(pthread_mutex_t *mutex);
+int pthread_mutex_unlock(pthread_mutex_t *mutex);
+
+/* event.c */
+int pthread_event_destroy(pthread_event_t *event);
+int pthread_event_init(pthread_event_t *event);
+int pthread_event_wait(pthread_event_t *event);
+int pthread_event_fire(pthread_event_t *event);
+int pthread_event_fire_all(pthread_event_t *event);
+
+/* rwlock.c */
+int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
+int pthread_rwlock_init(pthread_rwlock_t *rwlock,
+	pthread_rwlockattr_t *UNUSED(attr));
+int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
+int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
+int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
+
+/* schedule.c */
+int pthread_yield(void);
+int sched_yield(void);
+void pthread_yield_all(void);
+
+/* LSC: FIXME: Maybe we should really do something with those... */
+#define pthread_mutexattr_init(u) (0)
+#define pthread_mutexattr_destroy(u) (0)
+
+#define PTHREAD_MUTEX_RECURSIVE 0
+#define pthread_mutexattr_settype(x, y) (EINVAL)
+__END_DECLS
+
+#endif /* defined(_MTHREADIFY_PTHREADS) */
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/netdriver.h proj/minix/include/minix/minix/netdriver.h
--- srclimpio/minix/include/minix/minix/netdriver.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/netdriver.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,13 @@
+/* Prototypes and definitions for network drivers. */
+
+#ifndef _MINIX_NETDRIVER_H
+#define _MINIX_NETDRIVER_H
+
+#include <minix/endpoint.h>
+#include <minix/ipc.h>
+
+/* Functions defined by netdriver.c: */
+void netdriver_announce(void);
+int netdriver_receive(endpoint_t src, message *m_ptr, int *status_ptr);
+
+#endif /* _MINIX_NETDRIVER_H */
diff -ruNp srclimpio/minix/include/minix/minix/netsock.h proj/minix/include/minix/minix/netsock.h
--- srclimpio/minix/include/minix/minix/netsock.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/netsock.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,160 @@
+#ifndef __NET_SERVER_SOCKET_H__
+#define __NET_SERVER_SOCKET_H__
+
+#include <stdlib.h>
+
+#include <minix/ipc.h>
+#include <minix/endpoint.h>
+#include <minix/chardriver.h>
+
+/*
+ * User can set this variable to make the debugging output differ between
+ * various users, e.g. "TCP" or "UDP"
+ */
+extern char * netsock_user_name;
+
+#define SOCK_TYPE_IP	0
+#define SOCK_TYPE_TCP	1
+#define SOCK_TYPE_UDP	2
+#define SOCK_TYPES	3
+
+struct socket;
+struct sock_req;
+
+typedef int (* sock_op_opcl_t)(struct socket *);
+typedef int (* sock_op_io_t)(struct socket *, struct sock_req *, int blk);
+typedef int (* sock_op_select_t)(struct socket *, unsigned int);
+typedef int (* sock_op_select_reply_t)(struct socket *);
+
+struct sock_ops {
+	sock_op_opcl_t		open;
+	sock_op_opcl_t		close;
+	sock_op_io_t		read;
+	sock_op_io_t		write;
+	sock_op_io_t		ioctl;
+	sock_op_select_t	select;
+	sock_op_select_reply_t	select_reply;
+};
+
+struct recv_q {
+	struct recv_q *	next;
+	void *		data;
+};
+
+#define SOCK_FLG_OP_PENDING	0x1
+#define SOCK_FLG_OP_IOCTL	0x10
+#define SOCK_FLG_OP_LISTENING	0x100	/* tcp socket is in a listening mode */
+#define	SOCK_FLG_OP_CONNECTING	0x200	/* set when waiting for a connect */
+#define SOCK_FLG_OP_READING	0x400	/* reading operation in progress */
+#define SOCK_FLG_OP_WRITING	0x800	/* writing operation in progress */
+#define SOCK_FLG_CLOSED		0x1000	/* tcp socket has been closed do not
+					   expect any more data */
+/* select() flags - they say what action do we monitor */
+#define SOCK_FLG_SEL_WRITE	0x100000
+#define SOCK_FLG_SEL_READ	0x200000
+#define SOCK_FLG_SEL_ERROR	0x400000
+
+#define sock_select_set(sock)	((sock)->flags & (SOCK_FLG_SEL_WRITE |	\
+				SOCK_FLG_SEL_READ | SOCK_FLG_SEL_ERROR))
+#define sock_select_read_set(sock)	((sock)->flags & SOCK_FLG_SEL_READ)
+#define sock_select_write_set(sock)	((sock)->flags & SOCK_FLG_SEL_WRITE)
+#define sock_select_rw_set(sock)	((sock)->flags & (SOCK_FLG_SEL_READ | \
+							SOCK_FLG_SEL_WRITE))
+#define sock_select_error_set(sock)	((sock)->flags & SOCK_FLG_SEL_ERROR)
+#define sock_clear_select(sock)	do {					\
+	(sock)->flags &= ~(SOCK_FLG_SEL_READ | SOCK_FLG_SEL_WRITE |	\
+						SOCK_FLG_SEL_ERROR);	\
+} while (0)
+
+struct sock_req {
+	enum {
+		SOCK_REQ_READ,
+		SOCK_REQ_WRITE,
+		SOCK_REQ_IOCTL
+	}			type;
+	devminor_t		minor;
+	endpoint_t		endpt;
+	cp_grant_id_t		grant;
+	union {
+		size_t		size;	/* for SOCK_REQ_READ, SOCK_REQ_WRITE */
+		unsigned long	req;	/* for SOCK_REQ_IOCTL */
+	};
+	int			flags;
+	cdev_id_t		id;
+};
+
+struct socket {
+	int			type;
+	u32_t			flags;
+	unsigned long		usr_flags;
+	void *			pcb;
+	struct sock_ops *	ops;
+	void *			buf;
+	size_t			buf_size;
+	struct sock_req		req;
+	void *			shm;
+	size_t			shm_size;
+	endpoint_t		select_ep;
+	struct recv_q *		recv_head;
+	struct recv_q *		recv_tail;
+	unsigned		recv_data_size; /* sum of data enqueued */
+	void *			data;
+};
+
+/*
+ * Each component needs to provide a method how to initially open a socket.
+ * The rest is handled byt the socket library.
+ */
+int socket_open(devminor_t minor);
+
+#define get_sock_num(x) ((long int) ((x) - socket))
+#define is_valid_sock_num(x) (x < MAX_SOCKETS)
+#define get_sock(x) &socket[x]
+
+#define MAX_SOCKETS 255 /* FIXME as log as the sockets are identified by the
+			   minor device number 255 is ok */
+#define MAX_DEVS 5
+#define RESERVED (SOCK_TYPES + MAX_DEVS) /* rounded to 8 */
+
+extern struct socket socket[MAX_SOCKETS];
+
+void socket_request(message * m, int ipc_status);
+void mq_process(void);
+
+struct socket * get_unused_sock(void);
+struct socket * get_nic_sock(unsigned dev);
+
+void send_req_reply(struct sock_req * req, int status);
+
+typedef void (* recv_data_free_fn)(void *);
+
+int sock_enqueue_data(struct socket * sock, void * data, unsigned size);
+void * sock_dequeue_data(struct socket * sock);
+void sock_dequeue_data_all(struct socket * sock,
+				recv_data_free_fn data_free);
+
+void sock_select_notify(struct socket * sock);
+
+static inline void * debug_malloc(size_t s)
+{
+	void * ret;
+
+	ret = malloc(s);
+	// printf("allocated %p size %d\n", ret, s);
+	return ret;
+}
+
+#define debug_free(x) do {							\
+	if (0)									\
+		printf("free called from %s:%d %s freeing %p\n", __FILE__,	\
+						__LINE__, __func__, (x));	\
+	free(x);								\
+} while(0)
+
+int generic_op_select(struct socket * sock, unsigned int sel);
+int generic_op_select_reply(struct socket * sock);
+
+/* a function thr user has to provide to reply to the posix server */
+void posix_reply(endpoint_t ep, message * m);
+
+#endif /* __NET_SERVER_SOCKET_H__ */
diff -ruNp srclimpio/minix/include/minix/minix/optset.h proj/minix/include/minix/minix/optset.h
--- srclimpio/minix/include/minix/minix/optset.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/optset.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,30 @@
+#ifndef _MINIX_OPTSET_H
+#define _MINIX_OPTSET_H
+
+typedef enum {
+  OPT_BOOL,
+  OPT_STRING,
+  OPT_INT
+} optset_type;
+
+/* An entry for the parser of an options set. The 'os_name' field must point
+ * to a string, which is treated case-insensitively; the last entry of a table
+ * must have NULL name. The 'os_type' field must be set to one of the OPT_
+ * values defined above. The 'os_ptr' field must point to the field that is to
+ * receive the value of a recognized option. For OPT_STRING, it must point to a
+ * string of a size set in 'os_val'; the resulting string may be truncated, but
+ * will always be null-terminated. For OPT_BOOL, it must point to an int which
+ * will be set to the value in 'os_val' if the option is present. For OPT_INT,
+ * it must point to an int which will be set to the provided option value;
+ * 'os_val' is then a base passed to strtol().
+ */
+struct optset {
+  const char *os_name;
+  optset_type os_type;
+  void *os_ptr;
+  int os_val;
+};
+
+void optset_parse(struct optset *table, char *string);
+
+#endif /* _MINIX_OPTSET_H */
diff -ruNp srclimpio/minix/include/minix/minix/padconf.h proj/minix/include/minix/minix/padconf.h
--- srclimpio/minix/include/minix/minix/padconf.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/padconf.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,322 @@
+#ifndef __MINIX_PADCONF_H
+#define __MINIX_PADCONF_H
+
+/* Define the start address of the padconf registers and the size of the block.
+ * The base must be page aligned, so we round down and the kernel adds the
+ * offset. The size must be a multiple of ARM_PAGE_SIZE, so we round up to 4KB.
+ */
+#define PADCONF_AM335X_REGISTERS_BASE 0x44E10000
+#define PADCONF_AM335X_REGISTERS_OFFSET 0x0000
+#define PADCONF_AM335X_REGISTERS_SIZE 0x1000 /* OFFSET + highest reg, rounded up */
+#define PADCONF_DM37XX_REGISTERS_BASE 0x48002000
+#define PADCONF_DM37XX_REGISTERS_OFFSET 0x0030
+#define PADCONF_DM37XX_REGISTERS_SIZE 0x1000 /* OFFSET + highest reg, rounded up */
+
+#define PADCONF_MUXMODE(X)  (X & 0x7)	/* mode 1 til 7 [2:0] */
+#define PADCONF_PULL_MODE(X)  ((X & 0x3) << 3)	/* 2 bits[4:3] */
+#define PADCONF_PULL_MODE_PD_DIS PADCONF_PULL_MODE(0)	/* pull down disabled */
+#define PADCONF_PULL_MODE_PD_EN PADCONF_PULL_MODE(1)	/* pull down enabled */
+#define PADCONF_PULL_MODE_PU_DIS PADCONF_PULL_MODE(2)	/* pull up disabled */
+#define PADCONF_PULL_MODE_PU_EN PADCONF_PULL_MODE(3)	/* pull up enabled */
+#define PADCONF_INPUT_ENABLE(X)  ((X & 0x1) << 8)	/* 1 bits[8] */
+#define PADCONF_OFF_MODE(X)  ((X & 0xFE) << 9)	/* 5 bits[13:9] */
+
+/* padconf pin definitions */
+#define CONTROL_PADCONF_SDRC_D0 (0x00000000)
+#define CONTROL_PADCONF_SDRC_D2 (0x00000004)
+#define CONTROL_PADCONF_SDRC_D4 (0x00000008)
+#define CONTROL_PADCONF_SDRC_D6 (0x0000000C)
+#define CONTROL_PADCONF_SDRC_D8 (0x00000010)
+#define CONTROL_PADCONF_SDRC_D10 (0x00000014)
+#define CONTROL_PADCONF_SDRC_D12 (0x00000018)
+#define CONTROL_PADCONF_SDRC_D14 (0x0000001C)
+#define CONTROL_PADCONF_SDRC_D16 (0x00000020)
+#define CONTROL_PADCONF_SDRC_D18 (0x00000024)
+#define CONTROL_PADCONF_SDRC_D20 (0x00000028)
+#define CONTROL_PADCONF_SDRC_D22 (0x0000002C)
+#define CONTROL_PADCONF_SDRC_D24 (0x00000030)
+#define CONTROL_PADCONF_SDRC_D26 (0x00000034)
+#define CONTROL_PADCONF_SDRC_D28 (0x00000038)
+#define CONTROL_PADCONF_SDRC_D30 (0x0000003C)
+#define CONTROL_PADCONF_SDRC_CLK (0x00000040)
+#define CONTROL_PADCONF_SDRC_DQS1 (0x00000044)
+#define CONTROL_PADCONF_SDRC_DQS3 (0x00000048)
+#define CONTROL_PADCONF_GPMC_A2 (0x0000004C)
+#define CONTROL_PADCONF_GPMC_A4 (0x00000050)
+#define CONTROL_PADCONF_GPMC_A6 (0x00000054)
+#define CONTROL_PADCONF_GPMC_A8 (0x00000058)
+#define CONTROL_PADCONF_GPMC_A10 (0x0000005C)
+#define CONTROL_PADCONF_GPMC_D1 (0x00000060)
+#define CONTROL_PADCONF_GPMC_D3 (0x00000064)
+#define CONTROL_PADCONF_GPMC_D5 (0x00000068)
+#define CONTROL_PADCONF_GPMC_D7 (0x0000006C)
+#define CONTROL_PADCONF_GPMC_D9 (0x00000070)
+#define CONTROL_PADCONF_GPMC_D11 (0x00000074)
+#define CONTROL_PADCONF_GPMC_D13 (0x00000078)
+#define CONTROL_PADCONF_GPMC_D15 (0x0000007C)
+#define CONTROL_PADCONF_GPMC_NCS1 (0x00000080)
+#define CONTROL_PADCONF_GPMC_NCS3 (0x00000084)
+#define CONTROL_PADCONF_GPMC_NCS5 (0x00000088)
+#define CONTROL_PADCONF_GPMC_NCS7 (0x0000008C)
+#define CONTROL_PADCONF_GPMC_NADV_ALE (0x00000090)
+#define CONTROL_PADCONF_GPMC_NWE (0x00000094)
+#define CONTROL_PADCONF_GPMC_NBE1 (0x00000098)
+#define CONTROL_PADCONF_GPMC_WAIT0 (0x0000009C)
+#define CONTROL_PADCONF_GPMC_WAIT2 (0x000000A0)
+#define CONTROL_PADCONF_DSS_PCLK (0x000000A4)
+#define CONTROL_PADCONF_DSS_VSYNC (0x000000A8)
+#define CONTROL_PADCONF_DSS_DATA0 (0x000000AC)
+#define CONTROL_PADCONF_DSS_DATA2 (0x000000B0)
+#define CONTROL_PADCONF_DSS_DATA4 (0x000000B4)
+#define CONTROL_PADCONF_DSS_DATA6 (0x000000B8)
+#define CONTROL_PADCONF_DSS_DATA8 (0x000000BC)
+#define CONTROL_PADCONF_DSS_DATA10 (0x000000C0)
+#define CONTROL_PADCONF_DSS_DATA12 (0x000000C4)
+#define CONTROL_PADCONF_DSS_DATA14 (0x000000C8)
+#define CONTROL_PADCONF_DSS_DATA16 (0x000000CC)
+#define CONTROL_PADCONF_DSS_DATA18 (0x000000D0)
+#define CONTROL_PADCONF_DSS_DATA20 (0x000000D4)
+#define CONTROL_PADCONF_DSS_DATA22 (0x000000D8)
+#define CONTROL_PADCONF_CAM_HS (0x000000DC)
+#define CONTROL_PADCONF_CAM_XCLKA (0x000000E0)
+#define CONTROL_PADCONF_CAM_FLD (0x000000E4)
+#define CONTROL_PADCONF_CAM_D1 (0x000000E8)
+#define CONTROL_PADCONF_CAM_D3 (0x000000EC)
+#define CONTROL_PADCONF_CAM_D5 (0x000000F0)
+#define CONTROL_PADCONF_CAM_D7 (0x000000F4)
+#define CONTROL_PADCONF_CAM_D9 (0x000000F8)
+#define CONTROL_PADCONF_CAM_D11 (0x000000FC)
+#define CONTROL_PADCONF_CAM_WEN (0x00000100)
+#define CONTROL_PADCONF_CSI2_DX0 (0x00000104)
+#define CONTROL_PADCONF_CSI2_DX1 (0x00000108)
+#define CONTROL_PADCONF_MCBSP2_FSX (0x0000010C)
+#define CONTROL_PADCONF_MCBSP2_DR (0x00000110)
+#define CONTROL_PADCONF_MMC1_CLK (0x00000114)
+#define CONTROL_PADCONF_MMC1_DAT0 (0x00000118)
+#define CONTROL_PADCONF_MMC1_DAT2 (0x0000011C)
+#define CONTROL_PADCONF_MMC2_CLK (0x00000128)
+#define CONTROL_PADCONF_MMC2_DAT0 (0x0000012C)
+#define CONTROL_PADCONF_MMC2_DAT2 (0x00000130)
+#define CONTROL_PADCONF_MMC2_DAT4 (0x00000134)
+#define CONTROL_PADCONF_MMC2_DAT6 (0x00000138)
+#define CONTROL_PADCONF_MCBSP3_DX (0x0000013C)
+#define CONTROL_PADCONF_MCBSP3_CLKX (0x00000140)
+#define CONTROL_PADCONF_UART2_CTS (0x00000144)
+#define CONTROL_PADCONF_UART2_TX (0x00000148)
+#define CONTROL_PADCONF_UART1_TX (0x0000014C)
+#define CONTROL_PADCONF_UART1_CTS (0x00000150)
+#define CONTROL_PADCONF_MCBSP4_CLKX (0x00000154)
+#define CONTROL_PADCONF_MCBSP4_DX (0x00000158)
+#define CONTROL_PADCONF_MCBSP1_CLKR (0x0000015C)
+#define CONTROL_PADCONF_MCBSP1_DX (0x00000160)
+#define CONTROL_PADCONF_MCBSP_CLKS (0x00000164)
+#define CONTROL_PADCONF_MCBSP1_CLKX (0x00000168)
+#define CONTROL_PADCONF_UART3_RTS_SD (0x0000016C)
+#define CONTROL_PADCONF_UART3_TX_IRTX (0x00000170)
+#define CONTROL_PADCONF_HSUSB0_STP (0x00000174)
+#define CONTROL_PADCONF_HSUSB0_NXT (0x00000178)
+#define CONTROL_PADCONF_HSUSB0_DATA1 (0x0000017C)
+#define CONTROL_PADCONF_HSUSB0_DATA3 (0x00000180)
+#define CONTROL_PADCONF_HSUSB0_DATA5 (0x00000184)
+#define CONTROL_PADCONF_HSUSB0_DATA7 (0x00000188)
+#define CONTROL_PADCONF_I2C1_SDA (0x0000018C)
+#define CONTROL_PADCONF_I2C2_SDA (0x00000190)
+#define CONTROL_PADCONF_I2C3_SDA (0x00000194)
+#define CONTROL_PADCONF_MCSPI1_CLK (0x00000198)
+#define CONTROL_PADCONF_MCSPI1_SOMI (0x0000019C)
+#define CONTROL_PADCONF_MCSPI1_CS1 (0x000001A0)
+#define CONTROL_PADCONF_MCSPI1_CS3 (0x000001A4)
+#define CONTROL_PADCONF_MCSPI2_SIMO (0x000001A8)
+#define CONTROL_PADCONF_MCSPI2_CS0 (0x000001AC)
+#define CONTROL_PADCONF_SYS_NIRQ (0x000001B0)
+#define CONTROL_PADCONF_SAD2D_MCAD0 (0x000001B4)
+#define CONTROL_PADCONF_SAD2D_MCAD2 (0x000001B8)
+#define CONTROL_PADCONF_SAD2D_MCAD4 (0x000001BC)
+#define CONTROL_PADCONF_SAD2D_MCAD6 (0x000001C0)
+#define CONTROL_PADCONF_SAD2D_MCAD8 (0x000001C4)
+#define CONTROL_PADCONF_SAD2D_MCAD10 (0x000001C8)
+#define CONTROL_PADCONF_SAD2D_MCAD12 (0x000001CC)
+#define CONTROL_PADCONF_SAD2D_MCAD14 (0x000001D0)
+#define CONTROL_PADCONF_SAD2D_MCAD16 (0x000001D4)
+#define CONTROL_PADCONF_SAD2D_MCAD18 (0x000001D8)
+#define CONTROL_PADCONF_SAD2D_MCAD20 (0x000001DC)
+#define CONTROL_PADCONF_SAD2D_MCAD22 (0x000001E0)
+#define CONTROL_PADCONF_SAD2D_MCAD24 (0x000001E4)
+#define CONTROL_PADCONF_SAD2D_MCAD26 (0x000001E8)
+#define CONTROL_PADCONF_SAD2D_MCAD28 (0x000001EC)
+#define CONTROL_PADCONF_SAD2D_MCAD30 (0x000001F0)
+#define CONTROL_PADCONF_SAD2D_MCAD32 (0x000001F4)
+#define CONTROL_PADCONF_SAD2D_MCAD34 (0x000001F8)
+#define CONTROL_PADCONF_SAD2D_MCAD36 (0x000001FC)
+#define CONTROL_PADCONF_SAD2D_NRESPWRON (0x00000200)
+#define CONTROL_PADCONF_SAD2D_ARMNIRQ (0x00000204)
+#define CONTROL_PADCONF_SAD2D_SPINT (0x00000208)
+#define CONTROL_PADCONF_SAD2D_DMAREQ0 (0x0000020C)
+#define CONTROL_PADCONF_SAD2D_DMAREQ2 (0x00000210)
+#define CONTROL_PADCONF_SAD2D_NTRST (0x00000214)
+#define CONTROL_PADCONF_SAD2D_TDO (0x00000218)
+#define CONTROL_PADCONF_SAD2D_TCK (0x0000021C)
+#define CONTROL_PADCONF_SAD2D_MSTDBY (0x00000220)
+#define CONTROL_PADCONF_SAD2D_IDLEACK (0x00000224)
+#define CONTROL_PADCONF_SAD2D_SWRITE (0x00000228)
+#define CONTROL_PADCONF_SAD2D_SREAD (0x0000022C)
+#define CONTROL_PADCONF_SAD2D_SBUSFLAG (0x00000230)
+#define CONTROL_PADCONF_SDRC_CKE1 (0x00000234)
+#define CONTROL_PADCONF_SDRC_BA0 (0x00000570)
+#define CONTROL_PADCONF_SDRC_A0 (0x00000574)
+#define CONTROL_PADCONF_SDRC_A2 (0x00000578)
+#define CONTROL_PADCONF_SDRC_A4 (0x0000057C)
+#define CONTROL_PADCONF_SDRC_A6 (0x00000580)
+#define CONTROL_PADCONF_SDRC_A8 (0x00000584)
+#define CONTROL_PADCONF_SDRC_A10 (0x00000588)
+#define CONTROL_PADCONF_SDRC_A12 (0x0000058C)
+#define CONTROL_PADCONF_SDRC_A14 (0x00000590)
+#define CONTROL_PADCONF_SDRC_NCS1 (0x00000594)
+#define CONTROL_PADCONF_SDRC_NRAS (0x00000598)
+#define CONTROL_PADCONF_SDRC_NWE (0x0000059C)
+#define CONTROL_PADCONF_SDRC_DM1 (0x000005A0)
+#define CONTROL_PADCONF_SDRC_DM3 (0x000005A4)
+#define CONTROL_PADCONF_ETK_CLK (0x000005A8)
+#define CONTROL_PADCONF_ETK_D0 (0x000005AC)
+#define CONTROL_PADCONF_ETK_D2 (0x000005B0)
+#define CONTROL_PADCONF_ETK_D4 (0x000005B4)
+#define CONTROL_PADCONF_ETK_D6 (0x000005B8)
+#define CONTROL_PADCONF_ETK_D8 (0x000005BC)
+#define CONTROL_PADCONF_ETK_D10 (0x000005C0)
+#define CONTROL_PADCONF_ETK_D12 (0x000005C4)
+#define CONTROL_PADCONF_ETK_D14 (0x000005C8)
+
+/* conf pin descriptions (am335x) */
+#define CONTROL_CONF_GPMC_AD0 (0x00000800)
+#define CONTROL_CONF_GPMC_AD1 (0x00000804)
+#define CONTROL_CONF_GPMC_AD2 (0x00000808)
+#define CONTROL_CONF_GPMC_AD3 (0x0000080C)
+#define CONTROL_CONF_GPMC_AD4 (0x00000810)
+#define CONTROL_CONF_GPMC_AD5 (0x00000814)
+#define CONTROL_CONF_GPMC_AD6 (0x00000818)
+#define CONTROL_CONF_GPMC_AD7 (0x0000081C)
+#define CONTROL_CONF_GPMC_AD8 (0x00000820)
+#define CONTROL_CONF_GPMC_AD9 (0x00000824)
+#define CONTROL_CONF_GPMC_AD10 (0x00000828)
+#define CONTROL_CONF_GPMC_AD11 (0x0000082C)
+#define CONTROL_CONF_GPMC_AD12 (0x00000830)
+#define CONTROL_CONF_GPMC_AD13 (0x00000834)
+#define CONTROL_CONF_GPMC_AD14 (0x00000838)
+#define CONTROL_CONF_GPMC_AD15 (0x0000083C)
+#define CONTROL_CONF_GPMC_A0 (0x00000840)
+#define CONTROL_CONF_GPMC_A1 (0x00000844)
+#define CONTROL_CONF_GPMC_A2 (0x00000848)
+#define CONTROL_CONF_GPMC_A3 (0x0000084C)
+#define CONTROL_CONF_GPMC_A4 (0x00000850)
+#define CONTROL_CONF_GPMC_A5 (0x00000854)
+#define CONTROL_CONF_GPMC_A6 (0x00000858)
+#define CONTROL_CONF_GPMC_A7 (0x0000085C)
+#define CONTROL_CONF_GPMC_A8 (0x00000860)
+#define CONTROL_CONF_GPMC_A9 (0x00000864)
+#define CONTROL_CONF_GPMC_A10 (0x00000868)
+#define CONTROL_CONF_GPMC_A11 (0x0000086C)
+#define CONTROL_CONF_GPMC_WAIT0 (0x00000870)
+#define CONTROL_CONF_GPMC_WPN (0x00000874)
+#define CONTROL_CONF_GPMC_BEN1 (0x00000878)
+#define CONTROL_CONF_GPMC_CSN0 (0x0000087C)
+#define CONTROL_CONF_GPMC_CSN1 (0x00000880)
+#define CONTROL_CONF_GPMC_CSN2 (0x00000884)
+#define CONTROL_CONF_GPMC_CSN3 (0x00000888)
+#define CONTROL_CONF_GPMC_CLK (0x0000088C)
+#define CONTROL_CONF_GPMC_ADVN_ALE (0x00000890)
+#define CONTROL_CONF_GPMC_OEN_REN (0x00000894)
+#define CONTROL_CONF_GPMC_WEN (0x00000898)
+#define CONTROL_CONF_GPMC_BEN0_CLE (0x0000089C)
+#define CONTROL_CONF_LCD_DATA0 (0x000008A0)
+#define CONTROL_CONF_LCD_DATA1 (0x000008A4)
+#define CONTROL_CONF_LCD_DATA2 (0x000008A8)
+#define CONTROL_CONF_LCD_DATA3 (0x000008AC)
+#define CONTROL_CONF_LCD_DATA4 (0x000008B0)
+#define CONTROL_CONF_LCD_DATA5 (0x000008B4)
+#define CONTROL_CONF_LCD_DATA6 (0x000008B8)
+#define CONTROL_CONF_LCD_DATA7 (0x000008BC)
+#define CONTROL_CONF_LCD_DATA8 (0x000008C0)
+#define CONTROL_CONF_LCD_DATA9 (0x000008C4)
+#define CONTROL_CONF_LCD_DATA10 (0x000008C8)
+#define CONTROL_CONF_LCD_DATA11 (0x000008CC)
+#define CONTROL_CONF_LCD_DATA12 (0x000008D0)
+#define CONTROL_CONF_LCD_DATA13 (0x000008D4)
+#define CONTROL_CONF_LCD_DATA14 (0x000008D8)
+#define CONTROL_CONF_LCD_DATA15 (0x000008DC)
+#define CONTROL_CONF_LCD_VSYNC (0x000008E0)
+#define CONTROL_CONF_LCD_HSYNC (0x000008E4)
+#define CONTROL_CONF_LCD_PCLK (0x000008E8)
+#define CONTROL_CONF_LCD_AC_BIAS_EN (0x000008EC)
+#define CONTROL_CONF_MMC0_DAT3 (0x000008F0)
+#define CONTROL_CONF_MMC0_DAT2 (0x000008F4)
+#define CONTROL_CONF_MMC0_DAT1 (0x000008F8)
+#define CONTROL_CONF_MMC0_DAT0 (0x000008FC)
+#define CONTROL_CONF_MMC0_CLK (0x00000900)
+#define CONTROL_CONF_MMC0_CMD (0x00000904)
+#define CONTROL_CONF_MII1_COL (0x00000908)
+#define CONTROL_CONF_MII1_CRS (0x0000090C)
+#define CONTROL_CONF_MII1_RX_ER (0x00000910)
+#define CONTROL_CONF_MII1_TX_EN (0x00000914)
+#define CONTROL_CONF_MII1_RX_DV (0x00000918)
+#define CONTROL_CONF_MII1_TXD3 (0x0000091C)
+#define CONTROL_CONF_MII1_TXD2 (0x00000920)
+#define CONTROL_CONF_MII1_TXD1 (0x00000924)
+#define CONTROL_CONF_MII1_TXD0 (0x00000928)
+#define CONTROL_CONF_MII1_TX_CLK (0x0000092C)
+#define CONTROL_CONF_MII1_RX_CLK (0x00000930)
+#define CONTROL_CONF_MII1_RXD3 (0x00000934)
+#define CONTROL_CONF_MII1_RXD2 (0x00000938)
+#define CONTROL_CONF_MII1_RXD1 (0x0000093C)
+#define CONTROL_CONF_MII1_RXD0 (0x00000940)
+#define CONTROL_CONF_RMII1_REF_CLK (0x00000944)
+#define CONTROL_CONF_MDIO (0x00000948)
+#define CONTROL_CONF_MDC (0x0000094C)
+#define CONTROL_CONF_SPI0_SCLK (0x00000950)
+#define CONTROL_CONF_SPI0_D0 (0x00000954)
+#define CONTROL_CONF_SPI0_D1 (0x00000958)
+#define CONTROL_CONF_SPI0_CS0 (0x0000095C)
+#define CONTROL_CONF_SPI0_CS1 (0x00000960)
+#define CONTROL_CONF_ECAP0_IN_PWM0_OUT (0x00000964)
+#define CONTROL_CONF_UART0_CTSN (0x00000968)
+#define CONTROL_CONF_UART0_RTSN (0x0000096C)
+#define CONTROL_CONF_UART0_RXD (0x00000970)
+#define CONTROL_CONF_UART0_TXD (0x00000974)
+#define CONTROL_CONF_UART1_CTSN (0x00000978)
+#define CONTROL_CONF_UART1_RTSN (0x0000097C)
+#define CONTROL_CONF_UART1_RXD (0x00000980)
+#define CONTROL_CONF_UART1_TXD (0x00000984)
+#define CONTROL_CONF_I2C0_SDA (0x00000988)
+#define CONTROL_CONF_I2C0_SCL (0x0000098C)
+#define CONTROL_CONF_MCASP0_ACLKX (0x00000990)
+#define CONTROL_CONF_MCASP0_FSX (0x00000994)
+#define CONTROL_CONF_MCASP0_AXR0 (0x00000998)
+#define CONTROL_CONF_MCASP0_AHCLKR (0x0000099C)
+#define CONTROL_CONF_MCASP0_ACLKR (0x000009A0)
+#define CONTROL_CONF_MCASP0_FSR (0x000009A4)
+#define CONTROL_CONF_MCASP0_AXR1 (0x000009A8)
+#define CONTROL_CONF_MCASP0_AHCLKX (0x000009AC)
+#define CONTROL_CONF_XDMA_EVENT_INTR0 (0x000009B0)
+#define CONTROL_CONF_XDMA_EVENT_INTR1 (0x000009B4)
+#define CONTROL_CONF_WARMRSTN (0x000009B8)
+#define CONTROL_CONF_NNMI (0x000009C0)
+#define CONTROL_CONF_TMS (0x000009D0)
+#define CONTROL_CONF_TDI (0x000009D4)
+#define CONTROL_CONF_TDO (0x000009D8)
+#define CONTROL_CONF_TCK (0x000009DC)
+#define CONTROL_CONF_TRSTN (0x000009E0)
+#define CONTROL_CONF_EMU0 (0x000009E4)
+#define CONTROL_CONF_EMU1 (0x000009E8)
+#define CONTROL_CONF_RTC_PWRONRSTN (0x000009F8)
+#define CONTROL_CONF_PMIC_POWER_EN (0x000009FC)
+#define CONTROL_CONF_EXT_WAKEUP (0x00000A00)
+#define CONTROL_CONF_RTC_KALDO_ENN (0x00000A04)
+#define CONTROL_CONF_USB0_DRVVBUS (0x00000A1C)
+#define CONTROL_CONF_USB1_DRVVBUS (0x00000A34)
+
+#define CONTROL_CONF_SLEWCTRL (1<<6)
+#define CONTROL_CONF_RXACTIVE (1<<5)
+#define CONTROL_CONF_PUTYPESEL (1<<4)
+#define CONTROL_CONF_PUDEN (1<<3)
+#define CONTROL_CONF_MUXMODE(X) (X&0x7)
+
+#endif /* __MINIX_PADCONF_H */
diff -ruNp srclimpio/minix/include/minix/minix/param.h proj/minix/include/minix/minix/param.h
--- srclimpio/minix/include/minix/minix/param.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/param.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,50 @@
+
+#ifndef _MINIX_PARAM_H
+#define _MINIX_PARAM_H 1
+
+#include <minix/com.h>
+#include <minix/const.h>
+
+/* Number of processes contained in the system image. */
+#define NR_BOOT_PROCS   (NR_TASKS + LAST_SPECIAL_PROC_NR + 1)
+
+#ifdef _MINIX_SYSTEM
+/* This is used to obtain system information through SYS_GETINFO. */
+#define MAXMEMMAP 40
+typedef struct kinfo {
+        /* Straight multiboot-provided info */
+        multiboot_info_t        mbi;
+        multiboot_module_t      module_list[MULTIBOOT_MAX_MODS];
+        multiboot_memory_map_t  memmap[MAXMEMMAP]; /* free mem list */
+        phys_bytes              mem_high_phys;
+        int                     mmap_size;
+
+        /* Multiboot-derived */
+        int                     mods_with_kernel; /* no. of mods incl kernel */
+        int                     kern_mod; /* which one is kernel */
+
+        /* Minix stuff, started at bootstrap phase */
+        int                     freepde_start;  /* lowest pde unused kernel pde */
+        char                    param_buf[MULTIBOOT_PARAM_BUF_SIZE];
+
+        /* Minix stuff */
+        struct kmessages *kmessages;
+        int do_serial_debug;    /* system serial output */
+        int serial_debug_baud;  /* serial baud rate */
+        int minix_panicing;     /* are we panicing? */
+        vir_bytes               user_sp; /* where does kernel want stack set */
+        vir_bytes               user_end; /* upper proc limit */
+        vir_bytes               vir_kern_start; /* kernel addrspace starts */
+        vir_bytes               bootstrap_start, bootstrap_len;
+        struct boot_image       boot_procs[NR_BOOT_PROCS];
+        int nr_procs;           /* number of user processes */
+        int nr_tasks;           /* number of kernel tasks */
+        char release[6];        /* kernel release number */
+        char version[6];        /* kernel version number */
+	int vm_allocated_bytes; /* allocated by kernel to load vm */
+	int kernel_allocated_bytes;		/* used by kernel */
+	int kernel_allocated_bytes_dynamic;	/* used by kernel (runtime) */
+} kinfo_t;
+#endif /* _MINIX_SYSTEM */
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/partition.h proj/minix/include/minix/minix/partition.h
--- srclimpio/minix/include/minix/minix/partition.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/partition.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,23 @@
+/*	minix/partition.h				Author: Kees J. Bot
+ *								7 Dec 1995
+ * Place of a partition on disk and the disk geometry,
+ * for use with the DIOCGETP and DIOCSETP ioctl's.
+ */
+#ifndef _MINIX__PARTITION_H
+#define _MINIX__PARTITION_H
+
+#include <sys/types.h>
+
+#include <minix/u64.h>
+
+int minix_sizeup(char *name, u64_t *bytes);
+
+struct part_geom {
+  u64_t base;		/* byte offset to the partition start */
+  u64_t size;		/* number of bytes in the partition */
+  unsigned cylinders;	/* disk geometry */
+  unsigned heads;
+  unsigned sectors;
+};
+
+#endif /* _MINIX__PARTITION_H */
diff -ruNp srclimpio/minix/include/minix/minix/paths.h proj/minix/include/minix/minix/paths.h
--- srclimpio/minix/include/minix/minix/paths.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/paths.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,24 @@
+#ifndef _MINIX_PATHS_H_
+#define _MINIX_PATHS_H_
+
+#define _PATH_SERVICE	"/bin/service"
+#define _PATH_PROC	"/proc/"
+
+#define _PATH_SYSTEM_CONF "/etc/system.conf"
+#define _PATH_SYSTEM_CONF_DIR "/etc/system.conf.d"
+#define _PATH_SYSTEM_CONF_PKG_DIR       "/usr/pkg/etc/system.conf.d"
+
+#define _PATH_DHCPCONF	"/etc/dhcp.conf"
+#define _PATH_DHCPPID	"/usr/run/dhcpd.pid"
+#define _PATH_DHCPCACHE	"/usr/adm/dhcp.cache"
+#define _PATH_DHCPPOOL	"/usr/adm/dhcp.pool"
+
+#define _PATH_RAMDISK	"/dev/ram"
+
+#define _PATH_DRIVERS	"/service"
+
+#define	_PATH_SERVACCES	"/etc/serv.access"
+
+#define _PATH_HOSTNAME_FILE "/etc/hostname.file"
+
+#endif /* _MINIX_PATHS_H_ */
diff -ruNp srclimpio/minix/include/minix/minix/portio.h proj/minix/include/minix/minix/portio.h
--- srclimpio/minix/include/minix/minix/portio.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/portio.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,21 @@
+/*
+minix/portio.h
+
+Created:	Jan 15, 1992 by Philip Homburg
+*/
+
+#ifndef _PORTIO_H_
+#define _PORTIO_H_
+
+#include <sys/types.h>
+
+unsigned inb(u16_t _port);
+unsigned inw(u16_t _port);
+unsigned inl(u16_t _port);
+void outb(u16_t _port, u8_t _value);
+void outw(u16_t _port, u16_t _value);
+void outl(u16_t _port, u32_t _value);
+void intr_disable(void);
+void intr_enable(void);
+
+#endif /* _PORTIO_H_ */
diff -ruNp srclimpio/minix/include/minix/minix/priv.h proj/minix/include/minix/minix/priv.h
--- srclimpio/minix/include/minix/minix/priv.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/priv.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,99 @@
+/* Privilege-related definitions. */
+
+#ifndef _MINIX_PRIV_H
+#define _MINIX_PRIV_H
+
+#include <minix/com.h>
+#include <minix/config.h>
+
+/* Static privilege id definitions. */
+#define NR_STATIC_PRIV_IDS         NR_BOOT_PROCS
+#define is_static_priv_id(id)	   (id >= 0 && id < NR_STATIC_PRIV_IDS)
+#define static_priv_id(n)          (NR_TASKS + (n))
+
+/* Unprivileged user processes all share the privilege structure of the
+ * user processesess.
+ * This id must be fixed because it is used to check send mask entries.
+ */
+#define USER_PRIV_ID	static_priv_id(ROOT_USR_PROC_NR)
+/* Specifies a null privilege id.
+ */
+#define NULL_PRIV_ID	(-1)
+
+/* Allowed targets. */
+#define NO_M      (-1)              /* no targets allowed */
+#define ALL_M     (-2)              /* all targets allowed */
+
+/* Allowed calls. */
+#define NO_C      (-1)              /* no calls allowed */
+#define ALL_C     (-2)              /* all calls allowed */
+#define NULL_C    (-3)              /* null call entry */
+
+/*
+ * Default privilege settings used in the system
+ */
+/* privilege flags */
+#define IDL_F     (SYS_PROC | BILLABLE) /* idle task is not preemptible as we
+                                         * don't want it to interfere with the
+                                         * timer tick interrupt handler code.
+                                         * Unlike other processes idle task is
+                                         * handled in a special way and is
+                                         * preempted always if timer tick occurs
+                                         * and there is another runnable process
+                                         */
+#define TSK_F     (SYS_PROC)                       /* other kernel tasks */
+#define SRV_F     (SYS_PROC | PREEMPTIBLE)         /* system services */
+#define DSRV_F    (SRV_F | DYN_PRIV_ID)            /* dynamic system services */
+#define RSYS_F    (SRV_F | ROOT_SYS_PROC)          /* root sys proc */
+#define VM_F      (SYS_PROC | VM_SYS_PROC)         /* vm */
+#define USR_F     (BILLABLE | PREEMPTIBLE)         /* user processes */
+#define IMM_F     (ROOT_SYS_PROC | VM_SYS_PROC | PREEMPTIBLE) /* immutable */
+
+/* allowed traps */
+#define CSK_T     (1 << RECEIVE)                   /* clock and system */
+#define TSK_T     0                                /* other kernel tasks */
+#define SRV_T     (~0)                             /* system services */
+#define DSRV_T    (~0)                             /* dynamic system services */
+#define USR_T     (1 << SENDREC)                   /* user processes */
+
+/* allowed targets */
+#define TSK_M     NO_M                             /* all kernel tasks */
+#define SRV_M     ALL_M                            /* system services */
+#define DSRV_M    ALL_M                            /* dynamic system services */
+#define USR_M     ALL_M                            /* user processes */
+
+/* allowed kernel calls */
+#define TSK_KC    NO_C                             /* all kernel tasks */
+#define SRV_KC    ALL_C                            /* dynamic system services */
+#define DSRV_KC   ALL_C                            /* default sys proc */
+#define USR_KC    NO_C                             /* user processes */
+
+/* allowed vm calls */
+#define SRV_VC    ALL_C                            /* dynamic system services */
+#define DSRV_VC   ALL_C                            /* default sys proc */
+#define USR_VC    ALL_C                            /* user processes */
+
+/* signal manager */
+#define SRV_SM    ROOT_SYS_PROC_NR                 /* system services */
+#define DSRV_SM   ROOT_SYS_PROC_NR                 /* dynamic system services */
+#define USR_SM    PM_PROC_NR                       /* user processes */
+
+/* scheduler */
+#define SRV_SCH   KERNEL                           /* system services */
+#define DSRV_SCH  SCHED_PROC_NR                    /* dynamic system services */
+#define USR_SCH   NONE                             /* user processes */
+
+/* scheduling priority queue. */
+#define SRV_Q     USER_Q                           /* system services */
+#define DSRV_Q    USER_Q                           /* dynamic system services */
+#define USR_Q     USER_Q                           /* user processes */
+
+/* scheduling quantum. */
+#define SRV_QT    USER_QUANTUM                     /* system services */
+#define DSRV_QT   USER_QUANTUM                     /* dynamic system services */
+#define USR_QT    USER_QUANTUM                     /* user processes */
+
+/* default CPU */
+#define DSRV_CPU USER_DEFAULT_CPU
+
+#endif /* _MINIX_PRIV_H */
diff -ruNp srclimpio/minix/include/minix/minix/procfs.h proj/minix/include/minix/minix/procfs.h
--- srclimpio/minix/include/minix/minix/procfs.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/procfs.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,40 @@
+#ifndef _MINIX_PROCFS_H
+#define _MINIX_PROCFS_H
+
+/* The compatibility model is as follows. The current format should be retained
+ * for as long as possible; new fields can be added at the end of the line,
+ * because ps/top only read as much as they know of from the start of the line.
+ * Once fields (really) have to be removed, or the whole line becomes too big
+ * of a mess, a completely new format string can be put in, but with an
+ * increased PSINFO_VERSION at the beginning. That way, older ps/top copies
+ * will not misinterpret the new fields, but rather fail cleanly.
+ */
+#define PSINFO_VERSION	0
+
+/* Process types. */
+#define TYPE_TASK	'T'
+#define TYPE_SYSTEM	'S'
+#define TYPE_USER	'U'
+
+/* General process states. */
+#define STATE_SLEEP	'S'
+#define STATE_WAIT	'W'
+#define STATE_ZOMBIE	'Z'
+#define STATE_RUN	'R'
+#define STATE_STOP	'T'
+
+/* PM sleep states. */
+#define PSTATE_NONE	'-'
+#define PSTATE_WAITING	'W'
+#define PSTATE_SIGSUSP	'S'
+
+/* VFS block states. */
+#define FSTATE_NONE	'-'
+#define FSTATE_PIPE	'P'
+#define FSTATE_LOCK	'L'
+#define FSTATE_POPEN	'O'
+#define FSTATE_SELECT	'S'
+#define FSTATE_TASK	'T'
+#define FSTATE_UNKNOWN	'?'
+
+#endif /* _MINIX_PROCFS_H */
diff -ruNp srclimpio/minix/include/minix/minix/profile.h proj/minix/include/minix/minix/profile.h
--- srclimpio/minix/include/minix/minix/profile.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/profile.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,106 @@
+#ifndef _PROFILE_H
+#define _PROFILE_H
+
+#include <minix/type.h>
+#include <sys/types.h>
+
+/*
+ * Types relating to system profiling.  Types are supplied for both
+ * statistical profiling and call profiling.
+ */
+
+#  define PROF_START       0    /* start statistical profiling */
+#  define PROF_STOP        1    /* stop statistical profiling */
+
+#define PROF_RTC	0 /* RTC based profiling */
+#define PROF_NMI	1 /* NMI based profiling, profiles kernel too */
+
+/* Info struct to be copied to from kernel to user program. */
+struct sprof_info_s {
+  int mem_used;
+  int total_samples;
+  int idle_samples;
+  int system_samples;
+  int user_samples;
+};
+
+/* What a profiling sample looks like (used for sizeof()). */
+struct sprof_sample {
+	endpoint_t	proc;
+	void *		pc;
+};
+
+struct sprof_proc {
+	endpoint_t	proc;
+	char		name[PROC_NAME_LEN];
+};
+
+#  define PROF_GET         2    /* get call profiling tables */
+#  define PROF_RESET       3    /* reset call profiling tables */
+
+/* Hash table size in each profiled process is table size + index size.
+ *
+ * Table size = CPROF_TABLE_SIZE * (CPROF_CPATH_MAX_LEN + 16).
+ * Index size = CPROF_INDEX_SIZE * 4;
+ *
+ * Making CPROF_CPATH_MAX_LEN too small may cause call path overruns.
+ * Making CPROF_TABLE_SIZE too small may cause table overruns.
+ * 
+ * There are some restrictions: processes in the boot image are loaded
+ * below 16 MB and the kernel is loaded in lower memory (below 640 kB). The
+ * latter is reason to use a different size for the kernel table.
+ */
+#define CPROF_TABLE_SIZE_OTHER	3000	/* nr of slots in hash table */
+#define CPROF_TABLE_SIZE_KERNEL	1500	/* kernel has a smaller table */
+#define CPROF_CPATH_MAX_LEN	256	/* len of cpath string field: */
+					/* MUST BE MULTIPLE OF WORDSIZE */
+
+#define CPROF_INDEX_SIZE	(10*1024)/* size of index to hash table */
+#define CPROF_STACK_SIZE	24	/* size of call stack */
+#define CPROF_PROCNAME_LEN	8	/* len of proc name field */
+
+#define CPROF_CPATH_OVERRUN	0x1	/* call path overrun */
+#define CPROF_STACK_OVERRUN	0x2	/* call stack overrun */
+#define CPROF_TABLE_OVERRUN	0x4	/* hash table overrun */
+
+#define CPROF_ANNOUNCE_OTHER	1	/* processes announce their profiling
+					 * data on n-th entry of procentry */
+#define CPROF_ACCOUNCE_KERNEL	10000	/* kernel announces not directly */
+
+/* Prototype for function called by procentry to get size of table. */
+int profile_get_tbl_size(void);
+/* Prototype for function called by procentry to get announce number. */
+int profile_get_announce(void);
+/* Prototype for function called by procentry to announce control struct
+ * and table locations to the kernel. */
+void profile_register(void *ctl_ptr, void *tbl_ptr);
+
+/* Info struct to be copied from kernel to user program. */
+struct cprof_info_s {
+  int mem_used;
+  int err;
+};
+
+/* Data structures for control structure and profiling data table in the
+ * in the profiled processes. 
+ */
+struct cprof_ctl_s {
+  int reset;				/* kernel sets to have table reset */
+  int slots_used;			/* proc writes nr slots used in table */
+  int err;				/* proc writes errors that occurred */
+};
+
+struct cprof_tbl_s {
+  struct cprof_tbl_s *next;		/* next in chain */
+  char cpath[CPROF_CPATH_MAX_LEN];	/* string with call path */
+  int calls;				/* nr of executions of path */
+  u64_t cycles;				/* execution time of path, in cycles */
+};
+
+int sprofile(int action, int size, int freq, int type, void *ctl_ptr,
+	void *mem_ptr);
+
+int cprofile(int action, int size, void *ctl_ptr, void *mem_ptr);
+
+#endif /* PROFILE_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/queryparam.h proj/minix/include/minix/minix/queryparam.h
--- srclimpio/minix/include/minix/minix/queryparam.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/queryparam.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,44 @@
+/*	queryparam.h - query program parameters		Author: Kees J. Bot
+ *								22 Apr 1994
+ */
+#ifndef _MINIX__QUERYPARAM_H
+#define _MINIX__QUERYPARAM_H
+
+
+typedef size_t _mnx_size_t;
+
+struct export_param_list {
+	char	*name;		/* "variable", "[", ".field", or NULL. */
+	void	*offset;	/* Address of a variable or field offset. */
+	size_t	size;		/* Size of the resulting object. */
+};
+
+struct export_params {
+	struct export_param_list *list;	/* List of exported parameters. */
+	struct export_params	 *next;	/* Link several sets of parameters. */
+};
+
+#ifdef __STDC__
+#define qp_stringize(var)	#var
+#define qp_dotstringize(var)	"." #var
+#else
+#define qp_stringize(var)	"var"
+#define qp_dotstringize(var)	".var"
+#endif
+#define QP_VARIABLE(var)	{ qp_stringize(var), &(var), sizeof(var) }
+#define QP_ARRAY(var)		{ "[", 0, sizeof((var)[0]) }
+#define QP_VECTOR(var,ptr,len)	{ qp_stringize(var), &(ptr), -1 },\
+				{ "[", &(len), sizeof(*(ptr)) }
+#define QP_FIELD(field, type)	{ qp_dotstringize(field), \
+					(void *)offsetof(type, field), \
+					sizeof(((type *)0)->field) }
+#define QP_END()		{ 0, 0, 0 }
+
+void qp_export(struct export_params *_ex_params);
+int queryparam(int (*_qgetc) (void), void **_paddress, _mnx_size_t
+	*_psize);
+_mnx_size_t paramvalue(char **_value, void *_address, _mnx_size_t
+	_size);
+#endif /* _MINIX__QUERYPARAM_H */
+
+/* $PchId: queryparam.h,v 1.1 2005/06/28 14:31:26 philip Exp $ */
diff -ruNp srclimpio/minix/include/minix/minix/rs.h proj/minix/include/minix/minix/rs.h
--- srclimpio/minix/include/minix/minix/rs.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/rs.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,139 @@
+#ifndef RS_H
+#define RS_H
+
+/*
+minix/rs.h
+
+Interface to the reincarnation server
+*/
+
+#include <minix/bitmap.h>
+#include <minix/com.h>
+
+#define SERVICE_LOGIN	"service"	/* passwd file entry for services */
+
+/* RSS definitions. */
+#define RSS_NR_IRQ		16
+#define RSS_NR_IO		16
+#define RSS_IRQ_ALL		(RSS_NR_IRQ+1)
+#define RSS_IO_ALL		(RSS_NR_IO+1)
+#define RSS_IPC_ALL		"IPC_ALL"
+#define RSS_IPC_ALL_SYS		"IPC_ALL_SYS"
+
+/* RSS flags. */
+#define RSS_COPY	0x01	/* keep an in-memory copy of the binary */
+#define RSS_REUSE	0x04	/* Try to reuse previously copied binary */
+#define RSS_NOBLOCK	0x08	/* unblock caller immediately */
+#define RSS_REPLICA	0x10	/* keep a replica of the service */
+#define RSS_SELF_LU	0x20	/* perform self update */
+#define RSS_SYS_BASIC_CALLS	0x40	/* include basic kernel calls */
+#define RSS_VM_BASIC_CALLS	0x80	/* include basic vm calls */
+#define RSS_NO_BIN_EXP	0x100	/* suppress binary exponential offset */
+
+/* Common definitions. */
+#define RS_NR_CONTROL		 8
+#define RS_NR_PCI_DEVICE	32
+#define RS_NR_PCI_CLASS		 4
+#define RS_MAX_LABEL_LEN	16
+
+/* CPU special values */
+#define RS_CPU_DEFAULT		-1 /* use the default cpu or do not change the current one */
+#define RS_CPU_BSP		-2 /* use the bootstrap cpu */
+
+/* Labels are copied over separately. */
+struct rss_label
+{
+	char *l_addr;
+	size_t l_len;
+};
+
+struct rs_pci_id {
+	u16_t vid;
+	u16_t did;
+	u16_t sub_vid;
+	u16_t sub_did;
+};
+#define NO_SUB_VID	0xffff
+#define NO_SUB_DID	0xffff
+
+struct rs_pci_class {
+	u32_t pciclass;
+	u32_t mask;
+};
+
+/* Arguments needed to start a new driver or server */
+struct rs_start
+{
+	unsigned rss_flags;
+	char *rss_cmd;
+	size_t rss_cmdlen;
+	uid_t rss_uid;
+	endpoint_t rss_sigmgr;
+	endpoint_t rss_scheduler;
+	int rss_priority;
+	int rss_quantum;
+	int rss_major;
+	long rss_period;
+	char *rss_script;
+	size_t rss_scriptlen;
+	int rss_nr_irq;
+	int rss_irq[RSS_NR_IRQ];
+	int rss_nr_io;
+	struct { unsigned base; unsigned len; } rss_io[RSS_NR_IO];
+	int rss_nr_pci_id;
+	struct rs_pci_id rss_pci_id[RS_NR_PCI_DEVICE];
+	int rss_nr_pci_class;
+	struct rs_pci_class rss_pci_class[RS_NR_PCI_CLASS];
+	bitchunk_t rss_system[SYS_CALL_MASK_SIZE];
+	struct rss_label rss_label;
+	char *rss_ipc;
+	size_t rss_ipclen;
+	bitchunk_t rss_vm[VM_CALL_MASK_SIZE];
+	int rss_nr_control;
+	struct rss_label rss_control[RS_NR_CONTROL];
+	int devman_id;
+	/*
+	 * SMP specific data
+	 *
+	 * must be at the end of the structure for binary compatibility with
+	 * non-smp sysytems
+	 */
+	int rss_cpu;
+};
+
+/* ACL information for access to PCI devices */
+struct rs_pci
+{
+	char rsp_label[RS_MAX_LABEL_LEN];
+	int rsp_endpoint;
+	int rsp_nr_device;
+	struct rs_pci_id rsp_device[RS_NR_PCI_DEVICE];
+	int rsp_nr_class;
+	struct rs_pci_class rsp_class[RS_NR_PCI_CLASS];
+};
+
+/* Definition of a public entry of the system process table. */
+struct rprocpub {
+  short in_use; 		  /* set when the entry is in use */
+  unsigned sys_flags; 		  /* sys flags */
+  endpoint_t endpoint;		  /* process endpoint number */
+
+  devmajor_t dev_nr;		  /* major device number or NO_DEV */
+
+  char label[RS_MAX_LABEL_LEN];	  /* label of this service */
+  char proc_name[RS_MAX_LABEL_LEN]; /* process name of this service */
+
+  bitchunk_t vm_call_mask[VM_CALL_MASK_SIZE]; /* vm call mask */
+
+  struct rs_pci pci_acl;	  /* pci acl */
+  int devman_id;
+};
+
+/* Return whether the given boot process is a user process, as opposed to a
+ * system process. Only usable by core services during SEF initialization.
+ */
+#define IS_RPUB_BOOT_USR(rpub) ((rpub)->endpoint == INIT_PROC_NR)
+
+int minix_rs_lookup(const char *name, endpoint_t *value);
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/safecopies.h proj/minix/include/minix/minix/safecopies.h
--- srclimpio/minix/include/minix/minix/safecopies.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/safecopies.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,93 @@
+
+#ifndef _MINIX_SAFECOPIES_H
+#define _MINIX_SAFECOPIES_H 1
+
+#include <minix/sys_config.h>
+#include <sys/types.h>
+#include <minix/vm.h>
+#include <stdint.h>
+
+typedef struct {
+	int cp_flags;	/* CPF_* below */
+	union {
+		struct {
+			/* CPF_DIRECT */
+			endpoint_t	cp_who_to;	/* grantee */
+			vir_bytes	cp_start;	/* memory */
+			size_t		cp_len;		/* size in bytes */
+			char		cp_reserved[8]; /* future use */
+		} cp_direct;
+		struct {
+			/* CPF_INDIRECT */
+			endpoint_t	cp_who_to;	/* grantee */
+			endpoint_t	cp_who_from;	/* previous granter */
+			cp_grant_id_t	cp_grant;	/* previous grant */
+			char		cp_reserved[8];/* future use */
+		} cp_indirect;
+		struct {
+			/* CPF_MAGIC */
+			endpoint_t	cp_who_from;	/* granter */
+			endpoint_t	cp_who_to;	/* grantee */
+			vir_bytes	cp_start;	/* memory */
+			size_t		cp_len;		/* size in bytes */
+			char		cp_reserved[8]; /* future use */
+		} cp_magic;
+	} cp_u;
+	char cp_reserved[8];				/* future use */
+} cp_grant_t;
+
+/* Vectored safecopy. */
+struct vscp_vec {
+        /* Exactly one of the following must be SELF. */
+        endpoint_t      v_from;         /* source */
+        endpoint_t      v_to;           /* destination */
+  
+        cp_grant_id_t   v_gid;          /* grant id of other process */
+        size_t          v_offset;       /* offset in other grant */
+        vir_bytes       v_addr;         /* address in copier's space */
+        size_t          v_bytes;        /* no. of bytes */
+};
+
+/* Invalid grant number. */
+#define GRANT_INVALID	((cp_grant_id_t) -1)
+#define GRANT_VALID(g)	((g) > GRANT_INVALID)
+
+/* Operations: any combination is ok. */
+#define CPF_READ	0x000001 /* Granted process may read. */
+#define CPF_WRITE	0x000002 /* Granted process may write. */
+
+/* Grant flags. */
+#define CPF_TRY		0x000010 /* Fail fast on unmapped memory. */
+
+/* Internal flags. */
+#define CPF_USED	0x000100 /* Grant slot in use. */
+#define CPF_DIRECT	0x000200 /* Grant from this process to another. */
+#define CPF_INDIRECT	0x000400 /* Grant from grant to another. */
+#define CPF_MAGIC	0x000800 /* Grant from any to any. */
+#define CPF_VALID	0x001000 /* Grant slot contains valid grant. */
+
+/* Prototypes for functions in libsys. */
+cp_grant_id_t cpf_grant_direct(endpoint_t, vir_bytes, size_t, int);
+cp_grant_id_t cpf_grant_indirect(endpoint_t, endpoint_t, cp_grant_id_t);
+cp_grant_id_t cpf_grant_magic(endpoint_t, endpoint_t, vir_bytes, size_t,
+	int);
+int cpf_revoke(cp_grant_id_t grant_id);
+int cpf_lookup(cp_grant_id_t g, endpoint_t *ep, endpoint_t *ep2);
+
+int cpf_getgrants(cp_grant_id_t *grant_ids, int n);
+int cpf_setgrant_direct(cp_grant_id_t g, endpoint_t who, vir_bytes addr,
+	size_t size, int access);
+int cpf_setgrant_indirect(cp_grant_id_t g, endpoint_t who_to, endpoint_t
+	who_from, cp_grant_id_t his_g);
+int cpf_setgrant_magic(cp_grant_id_t g, endpoint_t who_to, endpoint_t
+	who_from, vir_bytes addr, size_t bytes, int access);
+int cpf_setgrant_disable(cp_grant_id_t grant_id);
+void cpf_reload(void);
+
+/* Set a process' grant table location and size (in-kernel only). */
+#define _K_SET_GRANT_TABLE(rp, ptr, entries)	\
+	priv(rp)->s_grant_table= (ptr);		\
+	priv(rp)->s_grant_entries= (entries);
+
+#endif	/* _MINIX_SAFECOPIES_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/sched.h proj/minix/include/minix/minix/sched.h
--- srclimpio/minix/include/minix/minix/sched.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/sched.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,13 @@
+#ifndef _MINIX_SCHED_H
+#define _MINIX_SCHED_H
+
+#include <minix/ipc.h>
+
+int sched_stop(endpoint_t scheduler_e, endpoint_t schedulee_e);
+int sched_start(endpoint_t scheduler_e, endpoint_t schedulee_e,
+	endpoint_t parent_e, int maxprio, int quantum, int cpu, endpoint_t
+	*newscheduler_e);
+int sched_inherit(endpoint_t scheduler_e, endpoint_t schedulee_e,
+	endpoint_t parent_e, unsigned maxprio, endpoint_t *newscheduler_e);
+
+#endif /* _MINIX_SCHED_H */
diff -ruNp srclimpio/minix/include/minix/minix/sef.h proj/minix/include/minix/minix/sef.h
--- srclimpio/minix/include/minix/minix/sef.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/sef.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,253 @@
+/* Prototypes for System Event Framework (SEF) functions. */
+
+#ifndef _SEF_H
+#define _SEF_H
+
+#include <minix/ipc.h>
+
+/* SEF entry points for system processes. */
+void sef_startup(void);
+int sef_receive_status(endpoint_t src, message *m_ptr, int *status_ptr);
+endpoint_t sef_self(void);
+void sef_cancel(void);
+void sef_exit(int status);
+#define sef_receive(src, m_ptr) sef_receive_status(src, m_ptr, NULL)
+
+/* SEF Debug. */
+#include <stdio.h>
+#define sef_dprint                      printf
+#define sef_debug_begin()               (void)(NULL)
+#define sef_debug_end()                 (void)(NULL)
+
+/*===========================================================================*
+ *				  SEF Init				     *
+ *===========================================================================*/
+/* What to intercept. */
+#define INTERCEPT_SEF_INIT_REQUESTS 1
+#define IS_SEF_INIT_REQUEST(mp) ((mp)->m_type == RS_INIT \
+    && (mp)->m_source == RS_PROC_NR)
+
+/* Type definitions. */
+typedef struct {
+    cp_grant_id_t rproctab_gid;
+    endpoint_t endpoint;
+    endpoint_t old_endpoint;
+} sef_init_info_t;
+
+/* Callback type definitions. */
+typedef int(*sef_cb_init_t)(int type, sef_init_info_t *info);
+typedef int(*sef_cb_init_response_t)(message *m_ptr);
+
+/* Callback registration helpers. */
+void sef_setcb_init_fresh(sef_cb_init_t cb);
+void sef_setcb_init_lu(sef_cb_init_t cb);
+void sef_setcb_init_restart(sef_cb_init_t cb);
+void sef_setcb_init_response(sef_cb_init_response_t cb);
+
+/* Predefined callback implementations. */
+int sef_cb_init_null(int type, sef_init_info_t *info);
+int sef_cb_init_response_null(message *m_ptr);
+
+int sef_cb_init_fail(int type, sef_init_info_t *info);
+int sef_cb_init_reset(int type, sef_init_info_t *info);
+int sef_cb_init_crash(int type, sef_init_info_t *info);
+int sef_cb_init_response_rs_reply(message *m_ptr);
+
+/* Macros for predefined callback implementations. */
+#define SEF_CB_INIT_FRESH_NULL          sef_cb_init_null
+#define SEF_CB_INIT_LU_NULL             sef_cb_init_null
+#define SEF_CB_INIT_RESTART_NULL        sef_cb_init_null
+#define SEF_CB_INIT_RESPONSE_NULL       sef_cb_init_response_null
+
+#define SEF_CB_INIT_FRESH_DEFAULT       sef_cb_init_null
+#define SEF_CB_INIT_LU_DEFAULT          sef_cb_init_null
+#define SEF_CB_INIT_RESTART_DEFAULT     sef_cb_init_reset
+#define SEF_CB_INIT_RESPONSE_DEFAULT    sef_cb_init_response_rs_reply
+
+/* Init types. */
+#define SEF_INIT_FRESH                  0    /* init fresh */
+#define SEF_INIT_LU                     1    /* init after live update */
+#define SEF_INIT_RESTART                2    /* init after restart */
+
+/* Debug. */
+#define SEF_INIT_DEBUG_DEFAULT 0
+
+#ifndef SEF_INIT_DEBUG
+#define SEF_INIT_DEBUG                  SEF_INIT_DEBUG_DEFAULT
+#endif
+
+#define sef_init_dprint                 sef_dprint
+#define sef_init_debug_begin            sef_debug_begin
+#define sef_init_debug_end              sef_debug_end
+
+/*===========================================================================*
+ *				  SEF Ping				     *
+ *===========================================================================*/
+/* What to intercept. */
+#define INTERCEPT_SEF_PING_REQUESTS 1
+#define IS_SEF_PING_REQUEST(mp, status) (is_ipc_notify(status) \
+    && (mp)->m_source == RS_PROC_NR)
+
+/* Callback type definitions. */
+typedef void(*sef_cb_ping_reply_t)(endpoint_t source);
+
+/* Callback registration helpers. */
+void sef_setcb_ping_reply(sef_cb_ping_reply_t cb);
+
+/* Predefined callback implementations. */
+void sef_cb_ping_reply_null(endpoint_t source);
+
+void sef_cb_ping_reply_pong(endpoint_t source);
+
+/* Macros for predefined callback implementations. */
+#define SEF_CB_PING_REPLY_NULL          sef_cb_ping_reply_null
+
+#define SEF_CB_PING_REPLY_DEFAULT       sef_cb_ping_reply_pong
+
+/* Debug. */
+#define SEF_PING_DEBUG_DEFAULT 0
+
+#ifndef SEF_PING_DEBUG
+#define SEF_PING_DEBUG                  SEF_PING_DEBUG_DEFAULT
+#endif
+
+#define sef_ping_dprint                 sef_dprint
+#define sef_ping_debug_begin            sef_debug_begin
+#define sef_ping_debug_end              sef_debug_end
+
+/*===========================================================================*
+ *				SEF Live update				     *
+ *===========================================================================*/
+/* What to intercept. */
+#define INTERCEPT_SEF_LU_REQUESTS 1
+#define IS_SEF_LU_REQUEST(mp, status) ((mp)->m_type == RS_LU_PREPARE \
+    && (mp)->m_source == RS_PROC_NR)
+
+/* Callback type definitions. */
+typedef  int(*sef_cb_lu_prepare_t)(int);
+typedef  int(*sef_cb_lu_state_isvalid_t)(int);
+typedef void(*sef_cb_lu_state_changed_t)(int, int);
+typedef void(*sef_cb_lu_state_dump_t)(int);
+typedef  int(*sef_cb_lu_state_save_t)(int);
+typedef  int(*sef_cb_lu_response_t)(message *m_ptr);
+
+/* Callback registration helpers. */
+void sef_setcb_lu_prepare(sef_cb_lu_prepare_t cb);
+void sef_setcb_lu_state_isvalid(sef_cb_lu_state_isvalid_t cb);
+void sef_setcb_lu_state_changed(sef_cb_lu_state_changed_t cb);
+void sef_setcb_lu_state_dump(sef_cb_lu_state_dump_t cb);
+void sef_setcb_lu_state_save(sef_cb_lu_state_save_t cb);
+void sef_setcb_lu_response(sef_cb_lu_response_t cb);
+
+/* Predefined callback implementations. */
+int sef_cb_lu_prepare_null(int state);
+int sef_cb_lu_state_isvalid_null(int state);
+void sef_cb_lu_state_changed_null(int old_state, int state);
+void sef_cb_lu_state_dump_null(int state);
+int sef_cb_lu_state_save_null(int state);
+int sef_cb_lu_response_null(message *m_ptr);
+
+int sef_cb_lu_prepare_always_ready(int state);
+int sef_cb_lu_prepare_never_ready(int state);
+int sef_cb_lu_prepare_crash(int state);
+int sef_cb_lu_state_isvalid_standard(int state);
+int sef_cb_lu_state_isvalid_workfree(int state);
+int sef_cb_lu_response_rs_reply(message *m_ptr);
+
+/* Macros for predefined callback implementations. */
+#define SEF_CB_LU_PREPARE_NULL          sef_cb_lu_prepare_null
+#define SEF_CB_LU_STATE_ISVALID_NULL    sef_cb_lu_state_isvalid_null
+#define SEF_CB_LU_STATE_CHANGED_NULL    sef_cb_lu_state_changed_null
+#define SEF_CB_LU_STATE_DUMP_NULL       sef_cb_lu_state_dump_null
+#define SEF_CB_LU_STATE_SAVE_NULL       sef_cb_lu_state_save_null
+#define SEF_CB_LU_RESPONSE_NULL         sef_cb_lu_response_null
+
+#define SEF_CB_LU_PREPARE_DEFAULT       sef_cb_lu_prepare_null
+#define SEF_CB_LU_STATE_ISVALID_DEFAULT sef_cb_lu_state_isvalid_null
+#define SEF_CB_LU_STATE_CHANGED_DEFAULT sef_cb_lu_state_changed_null
+#define SEF_CB_LU_STATE_DUMP_DEFAULT    sef_cb_lu_state_dump_null
+#define SEF_CB_LU_STATE_SAVE_DEFAULT    sef_cb_lu_state_save_null
+#define SEF_CB_LU_RESPONSE_DEFAULT      sef_cb_lu_response_rs_reply
+
+/* Standard live update states. */
+#define SEF_LU_STATE_NULL               0    /* null state */
+#define SEF_LU_STATE_WORK_FREE          1    /* no work in progress */
+#define SEF_LU_STATE_REQUEST_FREE       2    /* no request in progress */
+#define SEF_LU_STATE_PROTOCOL_FREE      3    /* no protocol in progress */
+#define SEF_LU_STATE_CUSTOM_BASE        (SEF_LU_STATE_PROTOCOL_FREE+1)
+#define SEF_LU_STATE_IS_STANDARD(s)     ((s) > SEF_LU_STATE_NULL \
+    && (s) < SEF_LU_STATE_CUSTOM_BASE)
+
+/* Debug. */
+#define SEF_LU_DEBUG_DEFAULT 1
+
+#ifndef SEF_LU_DEBUG
+#define SEF_LU_DEBUG            SEF_LU_DEBUG_DEFAULT
+#endif
+
+#define sef_lu_dprint           sef_dprint
+#define sef_lu_debug_begin      sef_debug_begin
+#define sef_lu_debug_end        sef_debug_end
+
+/*===========================================================================*
+ *				  SEF Signal				     *
+ *===========================================================================*/
+/* What to intercept. */
+#define INTERCEPT_SEF_SIGNAL_REQUESTS 1
+#define IS_SEF_SIGNAL_REQUEST(mp, status) \
+    (((mp)->m_type == SIGS_SIGNAL_RECEIVED && (mp)->m_source < INIT_PROC_NR) \
+    || (is_ipc_notify(status) && (mp)->m_source == SYSTEM))
+
+/* Callback type definitions. */
+typedef void(*sef_cb_signal_handler_t)(int signo);
+typedef  int(*sef_cb_signal_manager_t)(endpoint_t target, int signo);
+typedef  int(*sef_cb_gcov_t)(message *msg);
+
+/* Callback registration helpers. */
+void sef_setcb_signal_handler(sef_cb_signal_handler_t cb);
+void sef_setcb_signal_manager(sef_cb_signal_manager_t cb);
+void sef_setcb_gcov(sef_cb_gcov_t cb);
+
+/* Predefined callback implementations. */
+void sef_cb_signal_handler_null(int signo);
+int sef_cb_signal_manager_null(endpoint_t target, int signo);
+
+void sef_cb_signal_handler_term(int signo);
+void sef_cb_signal_handler_posix_default(int signo);
+
+/* Macros for predefined callback implementations. */
+#define SEF_CB_SIGNAL_HANDLER_NULL      sef_cb_signal_handler_null
+#define SEF_CB_SIGNAL_MANAGER_NULL      sef_cb_signal_manager_null
+
+#define SEF_CB_SIGNAL_HANDLER_DEFAULT   sef_cb_signal_handler_null
+#define SEF_CB_SIGNAL_MANAGER_DEFAULT   sef_cb_signal_manager_null
+
+/* Debug. */
+#define SEF_SIGNAL_DEBUG_DEFAULT 0
+
+#ifndef SEF_SIGNAL_DEBUG
+#define SEF_SIGNAL_DEBUG                SEF_SIGNAL_DEBUG_DEFAULT
+#endif
+
+#define sef_signal_dprint               sef_dprint
+#define sef_signal_debug_begin          sef_debug_begin
+#define sef_signal_debug_end            sef_debug_end
+
+/*===========================================================================*
+ *			     SEF Fault Injection			     *
+ *===========================================================================*/
+/* What to intercept. */
+#define INTERCEPT_SEF_FI_REQUESTS 1
+#define IS_SEF_FI_REQUEST(mp, status) \
+    (m_ptr->m_type == COMMON_REQ_FI_CTL)
+
+/* Fault injection tool support. */
+#define SEF_FI_ALLOW_EDFI               1
+
+#if !defined(USE_LIVEUPDATE)
+#undef INTERCEPT_SEF_LU_REQUESTS
+#undef SEF_LU_DEBUG
+#endif
+
+#endif /* _SEF_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/sffs.h proj/minix/include/minix/minix/sffs.h
--- srclimpio/minix/include/minix/minix/sffs.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/sffs.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,69 @@
+/* Part of libsffs - (c) 2012, D.C. van Moolenbroek */
+
+#ifndef _MINIX_SFFS_H
+#define _MINIX_SFFS_H
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <minix/u64.h>
+
+typedef void *sffs_file_t;		/* handle to open file */
+typedef void *sffs_dir_t;		/* handle to directory search */
+
+struct sffs_attr {
+  u32_t a_mask;				/* which fields to retrieve/set */
+  mode_t a_mode;			/* file type and permissions */
+  u64_t a_size;				/* file size */
+  struct timespec a_crtime;		/* file creation time */
+  struct timespec a_atime;		/* file access time */
+  struct timespec a_mtime;		/* file modification time */
+  struct timespec a_ctime;		/* file change time */
+};
+
+#define SFFS_ATTR_SIZE		0x01	/* get/set file size */
+#define SFFS_ATTR_CRTIME	0x02	/* get/set file creation time */
+#define SFFS_ATTR_ATIME		0x04	/* get/set file access time */
+#define SFFS_ATTR_MTIME		0x08	/* get/set file modification time */
+#define SFFS_ATTR_CTIME		0x10	/* get/set file change time */
+#define SFFS_ATTR_MODE		0x20	/* get/set file mode */
+
+struct sffs_table {
+  int (*t_open)(char *path, int flags, int mode, sffs_file_t *handle);
+  ssize_t (*t_read)(sffs_file_t handle, char *buf, size_t size, u64_t pos);
+  ssize_t (*t_write)(sffs_file_t handle, char *buf, size_t size, u64_t pos);
+  int (*t_close)(sffs_file_t handle);
+
+  size_t (*t_readbuf)(char **ptr);
+  size_t (*t_writebuf)(char **ptr);
+
+  int (*t_opendir)(char *path, sffs_dir_t *handle);
+  int (*t_readdir)(sffs_dir_t handle, unsigned int index, char *buf,
+	size_t size, struct sffs_attr *attr);
+  int (*t_closedir)(sffs_dir_t handle);
+
+  int (*t_getattr)(char *path, struct sffs_attr *attr);
+  int (*t_setattr)(char *path, struct sffs_attr *attr);
+
+  int (*t_mkdir)(char *path, int mode);
+  int (*t_unlink)(char *path);
+  int (*t_rmdir)(char *path);
+  int (*t_rename)(char *opath, char *npath);
+
+  int (*t_queryvol)(char *path, u64_t *free, u64_t *total);
+};
+
+struct sffs_params {
+  char p_prefix[PATH_MAX];	/* prefix for all paths used */
+  uid_t p_uid;			/* UID that owns all files */
+  gid_t p_gid;			/* GID that owns all files */
+  unsigned int p_file_mask;	/* AND-mask to apply to file permissions */
+  unsigned int p_dir_mask;	/* AND-mask to apply to directory perms */
+  int p_case_insens;		/* case insensitivity flag */
+};
+
+int sffs_init(char *name, const struct sffs_table *table,
+  struct sffs_params *params);
+void sffs_signal(int signo);
+void sffs_loop(void);
+
+#endif /* _MINIX_SFFS_H */
diff -ruNp srclimpio/minix/include/minix/minix/sound.h proj/minix/include/minix/minix/sound.h
--- srclimpio/minix/include/minix/minix/sound.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/sound.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,45 @@
+/* Definitions used by /dev/audio and /dev/mixer.
+ *
+ *  Feb 13 1995			Author: Michel R. Prevenier 
+ */
+
+#ifndef SOUND_H
+#define SOUND_H
+
+/* ------- Mixer stuff ------- */
+
+/* Available devices */
+enum Device
+{
+  Master,     /* Master volume */
+  Dac,        /* DSP, digitized sound */
+  Fm,         /* Fm synthesized sound */
+  Cd,         /* Compact */
+  Line,       /* Line in */
+  Mic,        /* Microphone */
+  Speaker,    /* Pc speaker */
+  Treble,     /* Treble */
+  Bass        /* Bass */
+};
+
+enum InputState
+{
+  ON, OFF
+};
+
+/* Volume levels range from 0 to 31, bass & treble range from 0 to 15 */
+struct volume_level
+{
+  enum Device	device; 
+  int 	 	left;   	
+  int 	 	right;
+};
+
+struct inout_ctrl
+{
+  enum Device   	device;
+  enum InputState 	left;
+  enum InputState 	right;
+};
+
+#endif /* SOUND_H */
diff -ruNp srclimpio/minix/include/minix/minix/spin.h proj/minix/include/minix/minix/spin.h
--- srclimpio/minix/include/minix/minix/spin.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/spin.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,38 @@
+/* Prototypes for condition spinning helper functions (part of libsys). */
+#ifndef _MINIX_SPIN_H
+#define _MINIX_SPIN_H
+
+/* Opaque spin state structure. */
+typedef struct {
+	int s_state;
+	u32_t s_usecs;
+	u64_t s_base_tsc;
+	clock_t s_base_uptime;
+	int s_timeout;
+} spin_t;
+
+/* Functions. */
+void spin_init(spin_t *s, u32_t usecs);
+int spin_check(spin_t *s);
+
+/* Macros. */
+
+/* Execute a loop for at least 'u' microseconds, using spin object 's'.
+ * The body of the loop is guaranteed to be executed at least once.
+ */
+#define SPIN_FOR(s,u)							\
+	for (spin_init((s), (u)); spin_check((s)); )
+
+/* Return whether spin object 's' timed out after a loop. */
+#define SPIN_TIMEOUT(s) ((s)->s_timeout)
+
+/* Spin until the given condition becomes true, or 'u' microseconds expired.
+ * The condition is guaranteed to be checked at least once.
+ */
+#define SPIN_UNTIL(c,u) do {						\
+	spin_t s;							\
+	SPIN_FOR(&s,(u))						\
+		if (c) break;						\
+} while (0)
+
+#endif /* _MINIX_SPIN_H */
diff -ruNp srclimpio/minix/include/minix/minix/sys_config.h proj/minix/include/minix/minix/sys_config.h
--- srclimpio/minix/include/minix/minix/sys_config.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/sys_config.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,27 @@
+#ifndef _MINIX_SYS_CONFIG_H
+#define _MINIX_SYS_CONFIG_H 1
+
+/*===========================================================================*
+ *		This section contains user-settable parameters		     *
+ *===========================================================================*/
+
+#define _NR_PROCS	256
+#define _NR_SYS_PROCS	64
+
+/* Set the FP_FORMAT type based on the machine selected, either hw or sw    */
+#define _FP_NONE		  0	/* no floating point support                */
+#define _FP_IEEE		  1	/* conform IEEE floating point standard     */
+
+#ifndef _MINIX_FP_FORMAT
+#define _MINIX_FP_FORMAT   _FP_NONE
+#endif
+
+/* Kernel debug checks */
+#define DEBUG_LOCK_CHECK 1	/* Interrupt Lock/unlock sanity checking. */
+
+#define _KMESS_BUF_SIZE  10000
+
+/* Default stack size (limit) */
+#define DEFAULT_STACK_LIMIT (4 * 1024 * 1024)
+
+#endif /* _MINIX_SYS_CONFIG_H */
diff -ruNp srclimpio/minix/include/minix/minix/sysinfo.h proj/minix/include/minix/minix/sysinfo.h
--- srclimpio/minix/include/minix/minix/sysinfo.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/sysinfo.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,18 @@
+
+#ifndef _MINIX_SYSINFO_H
+#define _MINIX_SYSINFO_H
+
+#include <minix/endpoint.h>
+#include <minix/type.h>
+
+int getsysinfo(endpoint_t who, int what, void *where, size_t size);
+
+/* What system info to retrieve with sysgetinfo(). */
+#define SI_PROC_TAB	   2	/* copy of entire process table */
+#define SI_DMAP_TAB	   3	/* get device <-> driver mappings */
+#define SI_DATA_STORE	   5	/* get copy of data store mappings */
+#define SI_CALL_STATS	   9	/* system call statistics */
+#define SI_PROCPUB_TAB	   11	/* copy of public entries of process table */
+
+#endif
+
diff -ruNp srclimpio/minix/include/minix/minix/syslib.h proj/minix/include/minix/minix/syslib.h
--- srclimpio/minix/include/minix/minix/syslib.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/syslib.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,281 @@
+/* Prototypes for system library functions. */
+
+#ifndef _SYSLIB_H
+#define _SYSLIB_H
+
+#include <sys/types.h>
+#include <sys/sigtypes.h>
+
+#include <minix/ipc.h>
+#include <minix/u64.h>
+#include <minix/devio.h>
+
+#include <minix/safecopies.h>
+#include <minix/sef.h>
+#include <machine/mcontext.h>
+
+/* Forward declaration */
+struct reg86u;
+struct rs_pci;
+struct rusage;
+
+#define SYSTASK SYSTEM
+
+/*==========================================================================* 
+ * Minix system library. 						    *
+ *==========================================================================*/ 
+int sys_sample(unsigned flags, endpoint_t proc_ep);
+
+int _taskcall(endpoint_t who, int syscallnr, message *msgptr);
+int _kernel_call(int syscallnr, message *msgptr);
+
+int sys_abort(int how);
+int sys_enable_iop(endpoint_t proc_ep);
+int sys_exec(endpoint_t proc_ep, vir_bytes stack_ptr, vir_bytes progname,
+	vir_bytes pc, vir_bytes ps_str);
+int sys_fork(endpoint_t parent, endpoint_t child, endpoint_t *, 
+	u32_t vm, vir_bytes *);
+int sys_clear(endpoint_t proc_ep);
+int sys_exit(void);
+int sys_trace(int req, endpoint_t proc_ep, long addr, long *data_p);
+
+int sys_schedule(endpoint_t proc_ep, int priority, int quantum, int
+	cpu);
+int sys_schedctl(unsigned flags, endpoint_t proc_ep, int priority, int
+	quantum, int cpu);
+
+/* Shorthands for sys_runctl() system call. */
+#define sys_stop(proc_ep) sys_runctl(proc_ep, RC_STOP, 0)
+#define sys_delay_stop(proc_ep) sys_runctl(proc_ep, RC_STOP, RC_DELAY)
+#define sys_resume(proc_ep) sys_runctl(proc_ep, RC_RESUME, 0)
+int sys_runctl(endpoint_t proc_ep, int action, int flags);
+
+int sys_update(endpoint_t src_ep, endpoint_t dst_ep);
+int sys_statectl(int request);
+int sys_privctl(endpoint_t proc_ep, int req, void *p);
+int sys_privquery_mem(endpoint_t proc_ep, phys_bytes physstart,
+	phys_bytes physlen);
+int sys_setgrant(cp_grant_t *grants, int ngrants);
+
+int sys_int86(struct reg86u *reg86p);
+int sys_vm_setbuf(phys_bytes base, phys_bytes size, phys_bytes high);
+int sys_vm_map(endpoint_t proc_ep, int do_map, phys_bytes base,
+	phys_bytes size, phys_bytes offset);
+int sys_vmctl(endpoint_t who, int param, u32_t value);
+int sys_vmctl_get_pdbr(endpoint_t who, u32_t *pdbr);
+int sys_vmctl_get_memreq(endpoint_t *who, vir_bytes *mem, vir_bytes
+	*len, int *wrflag, endpoint_t *who_s, vir_bytes *mem_s, endpoint_t *);
+int sys_vmctl_enable_paging(void * data);
+
+int sys_readbios(phys_bytes address, void *buf, size_t size);
+int sys_settime(int now, clockid_t clk_id, time_t sec, long nsec);
+int sys_stime(time_t boottime);
+int sys_vmctl_get_mapping(int index, phys_bytes *addr, phys_bytes *len,
+	int *flags);
+int sys_vmctl_reply_mapping(int index, vir_bytes addr);
+int sys_vmctl_set_addrspace(endpoint_t who, phys_bytes ptroot, void
+	*ptroot_v);
+
+
+/* Shorthands for sys_sdevio() system call. */
+#define sys_insb(port, proc_ep, buffer, count) \
+  sys_sdevio(DIO_INPUT_BYTE, port, proc_ep, buffer, count, 0)
+#define sys_insw(port, proc_ep, buffer, count) \
+  sys_sdevio(DIO_INPUT_WORD, port, proc_ep, buffer, count, 0)
+#define sys_outsb(port, proc_ep, buffer, count) \
+  sys_sdevio(DIO_OUTPUT_BYTE, port, proc_ep, buffer, count, 0)
+#define sys_outsw(port, proc_ep, buffer, count) \
+  sys_sdevio(DIO_OUTPUT_WORD, port, proc_ep, buffer, count, 0)
+#define sys_safe_insb(port, ept, grant, offset, count) \
+  sys_sdevio(DIO_SAFE_INPUT_BYTE, port, ept, (void*)grant, count, offset)
+#define sys_safe_outsb(port, ept, grant, offset, count) \
+  sys_sdevio(DIO_SAFE_OUTPUT_BYTE, port, ept, (void*)grant, count, offset)
+#define sys_safe_insw(port, ept, grant, offset, count) \
+  sys_sdevio(DIO_SAFE_INPUT_WORD, port, ept, (void*)grant, count, offset)
+#define sys_safe_outsw(port, ept, grant, offset, count) \
+  sys_sdevio(DIO_SAFE_OUTPUT_WORD, port, ept, (void*)grant, count, offset)
+int sys_sdevio(int req, long port, endpoint_t proc_ep, void *buffer, int
+	count, vir_bytes offset);
+void *alloc_contig(size_t len, int flags, phys_bytes *phys);
+int free_contig(void *addr, size_t len);
+
+#define AC_ALIGN4K	0x01
+#define AC_LOWER16M	0x02
+#define AC_ALIGN64K	0x04
+#define AC_LOWER1M	0x08
+
+/* Clock functionality: get system times, (un)schedule an alarm call, or
+ * retrieve/set a process-virtual timer.
+ */
+int sys_times(endpoint_t proc_ep, clock_t *user_time, clock_t *sys_time,
+	clock_t *uptime, time_t *boottime);
+int sys_setalarm(clock_t exp_time, int abs_time);
+int sys_vtimer(endpoint_t proc_nr, int which, clock_t *newval, clock_t
+	*oldval);
+
+/* Shorthands for sys_irqctl() system call. */
+#define sys_irqdisable(hook_id) \
+    sys_irqctl(IRQ_DISABLE, 0, 0, hook_id) 
+#define sys_irqenable(hook_id) \
+    sys_irqctl(IRQ_ENABLE, 0, 0, hook_id) 
+#define sys_irqsetpolicy(irq_vec, policy, hook_id) \
+    sys_irqctl(IRQ_SETPOLICY, irq_vec, policy, hook_id)
+#define sys_irqrmpolicy(hook_id) \
+    sys_irqctl(IRQ_RMPOLICY, 0, 0, hook_id)
+int sys_irqctl(int request, int irq_vec, int policy, int *irq_hook_id);
+
+/* Shorthands for sys_vircopy() and sys_physcopy() system calls. */
+#define sys_datacopy(p1, v1, p2, v2, len) sys_vircopy(p1, v1, p2, v2, len, 0)
+#define sys_datacopy_try(p1, v1, p2, v2, len) sys_vircopy(p1, v1, p2, v2, len, CP_FLAG_TRY)
+int sys_vircopy(endpoint_t src_proc, vir_bytes src_v,
+	endpoint_t dst_proc, vir_bytes dst_vir, phys_bytes bytes, int flags);
+
+#define sys_abscopy(src_phys, dst_phys, bytes) \
+	sys_physcopy(NONE, src_phys, NONE, dst_phys, bytes, 0)
+int sys_physcopy(endpoint_t src_proc, vir_bytes src_vir,
+	endpoint_t dst_proc, vir_bytes dst_vir, phys_bytes bytes, int flags);
+
+
+/* Grant-based copy functions. */
+int sys_safecopyfrom(endpoint_t source, cp_grant_id_t grant, vir_bytes
+	grant_offset, vir_bytes my_address, size_t bytes);
+int sys_safecopyto(endpoint_t dest, cp_grant_id_t grant, vir_bytes
+	grant_offset, vir_bytes my_address, size_t bytes);
+int sys_vsafecopy(struct vscp_vec *copyvec, int elements);
+
+int sys_safememset(endpoint_t source, cp_grant_id_t grant, vir_bytes
+	grant_offset, int pattern, size_t bytes);
+
+int sys_memset(endpoint_t who, unsigned long pattern,
+	phys_bytes base, phys_bytes bytes);
+
+int sys_vumap(endpoint_t endpt, struct vumap_vir *vvec,
+	int vcount, size_t offset, int access, struct vumap_phys *pvec,
+	int *pcount);
+int sys_umap(endpoint_t proc_ep, int seg, vir_bytes vir_addr, vir_bytes
+	bytes, phys_bytes *phys_addr);
+int sys_umap_data_fb(endpoint_t proc_ep, vir_bytes vir_addr, vir_bytes
+	bytes, phys_bytes *phys_addr);
+int sys_umap_remote(endpoint_t proc_ep, endpoint_t grantee, int seg,
+	vir_bytes vir_addr, vir_bytes bytes, phys_bytes *phys_addr);
+
+/* Shorthands for sys_diagctl() system call. */
+#define sys_diagctl_diag(buf,len) \
+	sys_diagctl(DIAGCTL_CODE_DIAG, buf, len)
+#define sys_diagctl_stacktrace(ep) \
+	sys_diagctl(DIAGCTL_CODE_STACKTRACE, NULL, ep)
+#define sys_diagctl_register()	\
+	sys_diagctl(DIAGCTL_CODE_REGISTER, NULL, 0)
+#define sys_diagctl_unregister() \
+	sys_diagctl(DIAGCTL_CODE_UNREGISTER, NULL, 0)
+int sys_diagctl(int ctl, char *arg1, int arg2);
+
+/* Shorthands for sys_getinfo() system call. */
+#define sys_getkinfo(dst)	sys_getinfo(GET_KINFO, dst, 0,0,0)
+#define sys_getloadinfo(dst)	sys_getinfo(GET_LOADINFO, dst, 0,0,0)
+#define sys_getmachine(dst)	sys_getinfo(GET_MACHINE, dst, 0,0,0)
+#define sys_getcpuinfo(dst)     sys_getinfo(GET_CPUINFO, dst, 0,0,0)
+#define sys_getproctab(dst)	sys_getinfo(GET_PROCTAB, dst, 0,0,0)
+#define sys_getprivtab(dst)	sys_getinfo(GET_PRIVTAB, dst, 0,0,0)
+#define sys_getproc(dst,nr)	sys_getinfo(GET_PROC, dst, 0,0, nr)
+#define sys_getrandomness(dst)	sys_getinfo(GET_RANDOMNESS, dst, 0,0,0)
+#define sys_getrandom_bin(d,b)	sys_getinfo(GET_RANDOMNESS_BIN, d, 0,0,b)
+#define sys_getimage(dst)	sys_getinfo(GET_IMAGE, dst, 0,0,0)
+#define sys_getirqhooks(dst)	sys_getinfo(GET_IRQHOOKS, dst, 0,0,0)
+#define sys_getirqactids(dst)	sys_getinfo(GET_IRQACTIDS, dst, 0,0,0)
+#define sys_getmonparams(v,vl)	sys_getinfo(GET_MONPARAMS, v,vl, 0,0)
+#define sys_getschedinfo(v1,v2)	sys_getinfo(GET_SCHEDINFO, v1,0, v2,0)
+#define sys_getpriv(dst, nr)	sys_getinfo(GET_PRIV, dst, 0,0, nr)
+#define sys_getidletsc(dst)	sys_getinfo(GET_IDLETSC, dst, 0,0,0)
+#define sys_getregs(dst,nr)	sys_getinfo(GET_REGS, dst, 0,0, nr)
+#define sys_getrusage(dst, nr)  sys_getinfo(GET_RUSAGE, dst, 0,0, nr)
+int sys_getinfo(int request, void *val_ptr, int val_len, void *val_ptr2,
+	int val_len2);
+int sys_whoami(endpoint_t *ep, char *name, int namelen, int
+	*priv_flags);
+
+/* Signal control. */
+int sys_kill(endpoint_t proc_ep, int sig);
+int sys_sigsend(endpoint_t proc_ep, struct sigmsg *sig_ctxt);
+int sys_sigreturn(endpoint_t proc_ep, struct sigmsg *sig_ctxt);
+int sys_getksig(endpoint_t *proc_ep, sigset_t *k_sig_map);
+int sys_endksig(endpoint_t proc_ep);
+
+/* NOTE: two different approaches were used to distinguish the device I/O
+ * types 'byte', 'word', 'long': the latter uses #define and results in a
+ * smaller implementation, but looses the static type checking.
+ */
+int sys_voutb(pvb_pair_t *pvb_pairs, int nr_ports);
+int sys_voutw(pvw_pair_t *pvw_pairs, int nr_ports);
+int sys_voutl(pvl_pair_t *pvl_pairs, int nr_ports);
+int sys_vinb(pvb_pair_t *pvb_pairs, int nr_ports);
+int sys_vinw(pvw_pair_t *pvw_pairs, int nr_ports);
+int sys_vinl(pvl_pair_t *pvl_pairs, int nr_ports);
+
+/* Shorthands for sys_out() system call. */
+#define sys_outb(p,v)	sys_out((p), (u32_t) (v), _DIO_BYTE)
+#define sys_outw(p,v)	sys_out((p), (u32_t) (v), _DIO_WORD)
+#define sys_outl(p,v)	sys_out((p), (u32_t) (v), _DIO_LONG)
+int sys_out(int port, u32_t value, int type);
+
+/* Shorthands for sys_in() system call. */
+#define sys_inb(p,v)	sys_in((p), (v), _DIO_BYTE)
+#define sys_inw(p,v)	sys_in((p), (v), _DIO_WORD)
+#define sys_inl(p,v)	sys_in((p), (v), _DIO_LONG)
+int sys_in(int port, u32_t *value, int type);
+
+/* arm pinmux */
+int sys_padconf(u32_t padconf, u32_t mask, u32_t value);
+
+/* pci.c */
+void pci_init(void);
+int pci_first_dev(int *devindp, u16_t *vidp, u16_t *didp);
+int pci_next_dev(int *devindp, u16_t *vidp, u16_t *didp);
+int pci_find_dev(u8_t bus, u8_t dev, u8_t func, int *devindp);
+void pci_reserve(int devind);
+int pci_reserve_ok(int devind);
+void pci_ids(int devind, u16_t *vidp, u16_t *didp);
+void pci_rescan_bus(u8_t busnr);
+u8_t pci_attr_r8(int devind, int port);
+u16_t pci_attr_r16(int devind, int port);
+u32_t pci_attr_r32(int devind, int port);
+void pci_attr_w8(int devind, int port, u8_t value);
+void pci_attr_w16(int devind, int port, u16_t value);
+void pci_attr_w32(int devind, int port, u32_t value);
+char *pci_dev_name(u16_t vid, u16_t did);
+char *pci_slot_name(int devind);
+int pci_set_acl(struct rs_pci *rs_pci);
+int pci_del_acl(endpoint_t proc_ep);
+int pci_get_bar(int devind, int port, u32_t *base, u32_t *size, int
+	*ioflag);
+
+/* Profiling. */
+int sys_sprof(int action, int size, int freq, int type, endpoint_t
+	endpt, void *ctl_ptr, void *mem_ptr);
+int sys_cprof(int action, int size, endpoint_t endpt, void *ctl_ptr,
+	void *mem_ptr);
+int sys_profbuf(void *ctl_ptr, void *mem_ptr);
+
+/* machine context */
+int sys_getmcontext(endpoint_t proc, vir_bytes mcp);
+int sys_setmcontext(endpoint_t proc, vir_bytes mcp);
+
+/* input */
+int tty_input_inject(int type, int code, int val);
+
+/* Miscellaneous calls from servers and drivers. */
+pid_t srv_fork(uid_t reuid, gid_t regid);
+int srv_kill(pid_t pid, int sig);
+int getprocnr(pid_t pid, endpoint_t *proc_ep);
+int mapdriver(char *label, devmajor_t major);
+pid_t getnpid(endpoint_t proc_ep);
+uid_t getnuid(endpoint_t proc_ep);
+gid_t getngid(endpoint_t proc_ep);
+int checkperms(endpoint_t endpt, char *path, size_t size);
+int copyfd(endpoint_t endpt, int fd, int what);
+#define COPYFD_FROM	0	/* copy file descriptor from remote process */
+#define COPYFD_TO	1	/* copy file descriptor to remote process */
+#define COPYFD_CLOSE	2	/* close file descriptor in remote process */
+
+#endif /* _SYSLIB_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/sysutil.h proj/minix/include/minix/minix/sysutil.h
--- srclimpio/minix/include/minix/minix/sysutil.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/sysutil.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,104 @@
+#ifndef _MINIX_SYSUTIL_H
+#define _MINIX_SYSUTIL_H 1
+
+#include <minix/ipc.h>
+#include <sys/cdefs.h>
+
+/* Extra system library definitions to support device drivers and servers.
+ *
+ * Created:
+ *	Mar 15, 2004 by Jorrit N. Herder
+ *
+ * Changes:
+ *	May 31, 2005: added printf, kputc (relocated from syslib)
+ *	May 31, 2005: added getuptime
+ *	Mar 18, 2005: added tickdelay
+ *	Oct 01, 2004: added env_parse, env_prefix, env_panic
+ *	Jul 13, 2004: added fkey_ctl
+ *	Apr 28, 2004: added report, panic 
+ *	Mar 31, 2004: setup like other libraries, such as syslib
+ */
+
+/*==========================================================================* 
+ * Miscellaneous helper functions.
+ *==========================================================================*/ 
+
+/* Environment parsing return values. */
+#define EP_BUF_SIZE   128	/* local buffer for env value */
+#define EP_UNSET	0	/* variable not set */
+#define EP_OFF		1	/* var = off */
+#define EP_ON		2	/* var = on (or field left blank) */
+#define EP_SET		3	/* var = 1:2:3 (nonblank field) */
+#define EP_EGETKENV	4	/* sys_getkenv() failed ... */
+
+extern int env_argc;
+extern char **env_argv;
+
+void env_setargs(int argc, char *argv[]);
+int env_get_param(const char *key, char *value, int max_size);
+int env_prefix(char *env, char *prefix);
+void env_panic(const char *key);
+int env_parse(const char *env, const char *fmt, int field,
+	long *param, long min, long max);
+
+#define fkey_map(fkeys, sfkeys) fkey_ctl(FKEY_MAP, (fkeys), (sfkeys))
+#define fkey_unmap(fkeys, sfkeys) fkey_ctl(FKEY_UNMAP, (fkeys), (sfkeys))
+#define fkey_events(fkeys, sfkeys) fkey_ctl(FKEY_EVENTS, (fkeys), (sfkeys))
+int fkey_ctl(int req, int *fkeys, int *sfkeys);
+
+int printf(const char *fmt, ...);
+void kputc(int c);
+__dead void panic(const char *fmt, ...)
+     __attribute__((__format__(__printf__,1,2)));
+void panic_hook(void);
+void __panic_hook(void);
+int getuptime(clock_t *ticks, clock_t *realtime, time_t *boottime);
+int getticks(clock_t *ticks);
+int tickdelay(clock_t ticks);
+int tsc_calibrate(void);
+u32_t sys_hz(void);
+double getidle(void);
+void util_stacktrace(void);
+int micro_delay(u32_t micros);
+u32_t tsc_64_to_micros(u64_t tsc);
+u32_t tsc_to_micros(u32_t low, u32_t high);
+u32_t tsc_get_khz(void);
+u32_t micros_to_ticks(u32_t micros);
+#if defined(__arm__)
+void read_frclock(u32_t *frclk);
+u32_t delta_frclock(u32_t base, u32_t cur);
+#endif
+void read_frclock_64(u64_t *frclk);
+u64_t delta_frclock_64(u64_t base, u64_t cur);
+u32_t frclock_64_to_micros(u64_t tsc);
+void ser_putc(char c);
+void get_randomness(struct k_randomness *, int);
+u32_t sqrt_approx(u32_t);
+
+int stime(time_t *_top);
+
+#define asynsend(ep, msg) asynsend3(ep, msg, 0)
+int asynsend3(endpoint_t ep, message *msg, int flags);
+int asyn_geterror(endpoint_t *dst, message *msg, int *err);
+
+#define ASSERT(c) if(!(c)) { panic("%s:%d: assert %s failed", __FILE__, __LINE__, #c); }
+
+/* timing library */
+#define TIMING_CATEGORIES       20
+
+#define TIMING_POINTS           20      /* timing resolution */
+#define TIMING_CATEGORIES       20
+#define TIMING_NAME             10
+
+struct util_timingdata {
+        char names[TIMING_NAME];
+        unsigned long lock_timings[TIMING_POINTS]; 
+        unsigned long lock_timings_range[2];
+        unsigned long binsize, resets, misses, measurements;
+	unsigned long starttimes[2];	/* nonzero if running */
+};
+
+typedef struct util_timingdata util_timingdata_t;
+
+#endif /* _MINIX_SYSUTIL_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/timers.h proj/minix/include/minix/minix/timers.h
--- srclimpio/minix/include/minix/minix/timers.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/timers.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,117 @@
+/* This library provides generic watchdog timer management functionality.
+ * The functions operate on a timer queue provided by the caller. Note that
+ * the timers must use absolute time to allow sorting. The library provides:
+ *
+ *    tmrs_settimer:     (re)set a new watchdog timer in the timers queue
+ *    tmrs_clrtimer:     remove a timer from both the timers queue
+ *    tmrs_exptimers:    check for expired timers and run watchdog functions
+ *
+ * Author:
+ *    Jorrit N. Herder <jnherder@cs.vu.nl>
+ *    Adapted from tmr_settimer and tmr_clrtimer in src/kernel/clock.c.
+ *    Last modified: September 30, 2004.
+ */
+#ifndef _MINIX_TIMERS_H
+#define _MINIX_TIMERS_H
+
+#include <limits.h>
+
+#include <sys/types.h>
+#include <minix/u64.h>
+#include <minix/minlib.h>
+#include <minix/endpoint.h>
+
+struct minix_timer;
+typedef void (*tmr_func_t)(struct minix_timer *tp);
+typedef union { int ta_int; long ta_long; void *ta_ptr; } tmr_arg_t;
+
+/* A minix_timer_t variable must be declare for each distinct timer to be used.
+ * The timers watchdog function and expiration time are automatically set
+ * by the library function tmrs_settimer, but its argument is not.
+ */
+typedef struct minix_timer
+{
+  struct minix_timer	*tmr_next;	/* next in a timer chain */
+  clock_t 	tmr_exp_time;	/* expiration time */
+  tmr_func_t	tmr_func;	/* function to call when expired */
+  tmr_arg_t	tmr_arg;	/* random argument */
+} minix_timer_t;
+
+/* Used when the timer is not active. */
+#define TMR_NEVER    ((clock_t) -1 < 0) ? ((clock_t) LONG_MAX) : ((clock_t) -1)
+#undef TMR_NEVER
+#define TMR_NEVER	((clock_t) LONG_MAX)
+
+/* These definitions can be used to set or get data from a timer variable. */
+#define tmr_arg(tp) (&(tp)->tmr_arg)
+#define tmr_exp_time(tp) (&(tp)->tmr_exp_time)
+
+/* Timers should be initialized once before they are being used. Be careful
+ * not to reinitialize a timer that is in a list of timers, or the chain
+ * will be broken.
+ */
+#define tmr_inittimer(tp) (void)((tp)->tmr_exp_time = TMR_NEVER, \
+	(tp)->tmr_next = NULL)
+
+/* The following generic timer management functions are available. They
+ * can be used to operate on the lists of timers. Adding a timer to a list
+ * automatically takes care of removing it.
+ */
+clock_t tmrs_clrtimer(minix_timer_t **tmrs, minix_timer_t *tp, clock_t *new_head);
+void tmrs_exptimers(minix_timer_t **tmrs, clock_t now, clock_t *new_head);
+clock_t tmrs_settimer(minix_timer_t **tmrs, minix_timer_t *tp, clock_t exp_time,
+	tmr_func_t watchdog, clock_t *new_head);
+
+#define PRINT_STATS(cum_spenttime, cum_instances) {		\
+		if(ex64hi(cum_spenttime)) { util_stacktrace(); printf(" ( ??? %lu %lu)\n",	\
+			ex64hi(cum_spenttime), ex64lo(cum_spenttime)); } \
+		printf("%s:%d,%lu,%lu\n", \
+			__FILE__, __LINE__, cum_instances,	\
+			 ex64lo(cum_spenttime)); \
+	}
+
+#define RESET_STATS(starttime, cum_instances, cum_spenttime, cum_starttime) { \
+		cum_instances = 0;				\
+		cum_starttime = starttime;			\
+		cum_spenttime = make64(0,0);			\
+}
+
+#define TIME_BLOCK_VAR(timed_code_block, time_interval) do {	\
+	static u64_t _cum_spenttime, _cum_starttime;		\
+	static int _cum_instances;				\
+	u64_t _next_cum_spent, _starttime, _endtime, _dt, _cum_dt;	\
+	u32_t _dt_micros;					\
+	read_tsc_64(&_starttime);				\
+	do { timed_code_block } while(0);			\
+	read_tsc_64(&_endtime);					\
+	_dt = _endtime - _starttime;				\
+	if(_cum_instances == 0) {				\
+		RESET_STATS(_starttime, _cum_instances, _cum_spenttime, _cum_starttime); \
+	 }							\
+	_next_cum_spent = add64(_cum_spenttime, _dt);		\
+	if(ex64hi(_next_cum_spent)) { 				\
+		PRINT_STATS(_cum_spenttime, _cum_instances);	\
+		RESET_STATS(_starttime, _cum_instances, _cum_spenttime, _cum_starttime); \
+	} 							\
+	_cum_spenttime = add64(_cum_spenttime, _dt);		\
+	_cum_instances++;					\
+	_cum_dt = _endtime - _cum_starttime;			\
+	if(_cum_dt > make64(0, 120)) {				\
+		PRINT_STATS(_cum_spenttime, _cum_instances);	\
+		RESET_STATS(_starttime, _cum_instances, _cum_spenttime, _cum_starttime); 	\
+	} 							\
+} while(0)
+
+#define TIME_BLOCK(timed_code_block) TIME_BLOCK_VAR(timed_code_block, 100)
+#define TIME_BLOCK_T(timed_code_block, t) TIME_BLOCK_VAR(timed_code_block, t)
+
+/* Timers abstraction for system processes. This would be in minix/sysutil.h
+ * if it weren't for naming conflicts.
+ */
+
+void init_timer(minix_timer_t *tp);
+void set_timer(minix_timer_t *tp, int ticks, tmr_func_t watchdog, int arg);
+void cancel_timer(minix_timer_t *tp);
+void expire_timers(clock_t now);
+
+#endif /* _MINIX_TIMERS_H */
diff -ruNp srclimpio/minix/include/minix/minix/type.h proj/minix/include/minix/minix/type.h
--- srclimpio/minix/include/minix/minix/type.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/type.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,191 @@
+#ifndef _TYPE_H
+#define _TYPE_H
+
+#include <sys/types.h>
+
+#include <machine/multiboot.h>
+
+#ifndef _MINIX_SYS_CONFIG_H
+#include <minix/sys_config.h>
+#endif
+
+#include <sys/sigtypes.h>
+
+#include <stdint.h>
+
+/* Type definitions. */
+typedef unsigned int vir_clicks; 	/*  virtual addr/length in clicks */
+typedef unsigned long phys_bytes;	/* physical addr/length in bytes */
+typedef unsigned int phys_clicks;	/* physical addr/length in clicks */
+typedef int endpoint_t;			/* process identifier */
+typedef int32_t cp_grant_id_t;		/* A grant ID. */
+typedef long unsigned int vir_bytes;	/* virtual addresses/lengths in bytes */
+
+/* Structure for virtual copying by means of a vector with requests. */
+struct vir_addr {
+  endpoint_t proc_nr_e; /* NONE for phys, otherwise process endpoint */
+  vir_bytes offset;
+};
+
+#define phys_cp_req vir_cp_req 
+struct vir_cp_req {
+  struct vir_addr src;
+  struct vir_addr dst;
+  phys_bytes count;
+};
+
+/* Structures for SYS_VUMAP. */
+struct vumap_vir {
+  union {
+	cp_grant_id_t u_grant;	/* grant identifier, for non-SELF endpoint */
+	vir_bytes u_addr;	/* local virtual address, for SELF endpoint */
+  } vv_u;
+  size_t vv_size;		/* size in bytes */
+};
+#define vv_grant	vv_u.u_grant
+#define vv_addr		vv_u.u_addr
+
+struct vumap_phys {
+  phys_bytes vp_addr;		/* physical address */
+  size_t vp_size;		/* size in bytes */
+};
+
+/* I/O vector structures used in protocols between services. */
+typedef struct {
+  vir_bytes iov_addr;		/* address of an I/O buffer */
+  vir_bytes iov_size;		/* sizeof an I/O buffer */
+} iovec_t;
+
+typedef struct {
+  cp_grant_id_t iov_grant;	/* grant ID of an I/O buffer */
+  vir_bytes iov_size;		/* sizeof an I/O buffer */
+} iovec_s_t;
+
+/* PM passes the address of a structure of this type to KERNEL when
+ * sys_sigsend() is invoked as part of the signal catching mechanism.
+ * The structure contain all the information that KERNEL needs to build
+ * the signal stack.
+ */
+struct sigmsg {
+  int sm_signo;			/* signal number being caught */
+  sigset_t sm_mask;		/* mask to restore when handler returns */
+  vir_bytes sm_sighandler;	/* address of handler */
+  vir_bytes sm_sigreturn;	/* address of _sigreturn in C library */
+  vir_bytes sm_stkptr;		/* user stack pointer */
+};
+
+/* Load data accounted every this no. of seconds. */
+#define _LOAD_UNIT_SECS		 6 	/* Changing this breaks ABI. */
+
+/* Load data history is kept for this long. */
+#define _LOAD_HISTORY_MINUTES	15	/* Changing this breaks ABI. */
+#define _LOAD_HISTORY_SECONDS	(60*_LOAD_HISTORY_MINUTES)
+
+/* We need this many slots to store the load history. */
+#define _LOAD_HISTORY	(_LOAD_HISTORY_SECONDS/_LOAD_UNIT_SECS)
+
+/* Runnable processes and other load-average information. */
+struct loadinfo {
+  u16_t proc_load_history[_LOAD_HISTORY];	/* history of proc_s_cur */
+  u16_t proc_last_slot;
+  clock_t last_clock;
+};
+
+struct machine {
+  unsigned processors_count;	/* how many cpus are available */
+  unsigned bsp_id;		/* id of the bootstrap cpu */
+  int padding;			/* used to be protected */
+  int apic_enabled; /* does the kernel use APIC or not? */
+  phys_bytes	acpi_rsdp; /* where is the acpi RSDP */
+  unsigned int board_id;   /* Identifier for the board see   */
+                           /* include/minix/board.h for more */
+                           /* information.                   */
+};
+
+struct io_range
+{
+	unsigned ior_base;	/* Lowest I/O port in range */
+	unsigned ior_limit;	/* Highest I/O port in range */
+};
+
+struct minix_mem_range
+{
+	phys_bytes mr_base;	/* Lowest memory address in range */
+	phys_bytes mr_limit;	/* Highest memory address in range */
+};
+
+#define PROC_NAME_LEN   16
+
+/* List of boot-time processes set in kernel/table.c. */
+struct boot_image {
+  int proc_nr;                    	/* process number to use */
+  char proc_name[PROC_NAME_LEN];        /* name in process table */
+  endpoint_t endpoint;                  /* endpoint number when started */
+  phys_bytes start_addr;		/* Where it's in memory */
+  phys_bytes len;
+};
+
+/* Memory chunks. */
+struct memory {
+	phys_bytes	base;
+	phys_bytes	size;
+};
+
+#define STATICINIT(v, n) \
+	if(!(v)) {	\
+		if(!((v) = alloc_contig(sizeof(*(v)) * (n), 0, NULL))) { \
+			panic("allocating " #v " failed: %d", n);	\
+		}	\
+	}
+
+/* The kernel outputs diagnostic messages in a circular buffer. */
+struct kmessages {
+  int km_next;                          /* next index to write */
+  int km_size;                          /* current size in buffer */
+  char km_buf[_KMESS_BUF_SIZE];          /* buffer for messages */
+  char kmess_buf[80*25];           /* printable copy of message buffer */
+  int blpos;				/* kmess_buf position */
+};
+
+#include <minix/config.h>
+#include <machine/interrupt.h>
+
+/* randomness struct: random sources after interrupts: */
+#define RANDOM_SOURCES			16
+#define RANDOM_ELEMENTS			64
+
+typedef unsigned short rand_t;
+
+struct k_randomness {
+  int random_elements, random_sources;
+  struct k_randomness_bin {
+        int r_next;                             /* next index to write */
+        int r_size;                             /* number of random elements */
+        rand_t r_buf[RANDOM_ELEMENTS]; /* buffer for random info */
+  } bin[RANDOM_SOURCES];
+};
+
+struct minix_kerninfo {
+	/* Binaries will depend on the offsets etc. in this
+	 * structure, so it can't be changed willy-nilly. In
+	 * other words, it is ABI-restricted.
+	 */
+#define KERNINFO_MAGIC 0xfc3b84bf
+	u32_t kerninfo_magic;
+	u32_t minix_feature_flags;	/* features in minix kernel */
+	u32_t ki_flags;			/* what is present in this struct */
+	u32_t minix_frclock_tcrr;
+	u32_t flags_unused3;
+	u32_t flags_unused4;
+	struct kinfo		*kinfo;
+	struct machine		*machine;
+	struct kmessages	*kmessages;
+	struct loadinfo		*loadinfo;
+	struct minix_ipcvecs	*minix_ipcvecs;
+	u64_t minix_arm_frclock_hz;	/* minix_frclock_tcrr frequency */
+} __packed;
+
+#define MINIX_KIF_IPCVECS	(1L << 0)
+
+#endif /* _TYPE_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/u64.h proj/minix/include/minix/minix/u64.h
--- srclimpio/minix/include/minix/minix/u64.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/u64.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,25 @@
+/*	minix/u64.h					Author: Kees J. Bot
+ *								7 Dec 1995
+ * Functions to manipulate 64 bit disk addresses.
+ */
+#ifndef _MINIX__U64_H
+#define _MINIX__U64_H
+
+#include <sys/types.h>
+
+static inline unsigned long ex64lo(u64_t i)
+{
+	return (unsigned long)i;
+}
+
+static inline unsigned long ex64hi(u64_t i)
+{
+	return (unsigned long)(i>>32);
+}
+
+static inline u64_t make64(unsigned long lo, unsigned long hi)
+{
+	return ((u64_t)hi << 32) | (u64_t)lo;
+}
+
+#endif /* _MINIX__U64_H */
diff -ruNp srclimpio/minix/include/minix/minix/usb.h proj/minix/include/minix/minix/usb.h
--- srclimpio/minix/include/minix/minix/usb.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/usb.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,158 @@
+#ifndef _MINIX_USB_H
+#define _MINIX_USB_H
+
+#include <sys/types.h>
+#include <minix/com.h>
+#include <minix/ipc.h>
+#include <stdio.h>
+
+#define USB_URBSIZE(data_size, iso_count) \
+	(data_size + sizeof(struct usb_urb) + iso_count * \
+	sizeof(struct usb_iso_packet_desc))
+
+#define USB_PREPARE_URB(urb, data_size, iso_count) \
+	do { \
+		if(iso_count)\
+			urb->iso_data.iso_desc = data_size;\
+			urb->urb_size = data_size+sizeof(struct usb_urb)+iso_count * \
+			sizeof(struct usb_iso_packet_desc); \
+	} while (0)
+
+
+struct usb_urb;
+
+struct usb_driver {
+	void (*urb_completion)(struct usb_urb *urb);
+	void (*connect_device)(unsigned dev_id, unsigned int interfaces);
+	void (*disconnect_device)(unsigned dev_id);
+};
+
+struct usb_device_id {
+	u16_t idVendor;
+	u16_t idProduct;
+	u32_t bcdDevice;
+
+	u8_t  bDeviceClass;
+	u8_t  bDeviceSubClass;
+	u8_t  bDeviceProtocol;
+
+	u8_t  bInterfaceClass;
+	u8_t  bInterfaceSubClass;
+	u8_t  bInterfaceProtocol;
+};
+
+struct usb_iso_packet_desc {
+	unsigned int offset;
+	unsigned int length;		/* expected length */
+	unsigned int actual_length;
+	unsigned int status;
+};
+	
+/** isochronous transfer */
+#define USB_TRANSFER_ISO 0
+/** interrupt transfer */
+#define USB_TRANSFER_INT 1
+/** control transfer */
+#define USB_TRANSFER_CTL 2
+/** bulk transfer */
+#define USB_TRANSFER_BLK 3
+
+#define USB_IN  0
+#define USB_OUT 1
+
+#define USB_INVALID_URB_ID 0
+
+struct usb_urb {
+	/* private */
+	struct usb_urb *next;
+
+	/** ID identifying the device on HCD side */
+	int dev_id;
+	int type;
+	int endpoint;
+	int direction;
+	int status;
+	int error_count;
+	size_t size;
+	size_t actual_length;
+	void *priv;
+	int interval;
+
+	unsigned long transfer_flags;
+
+	
+	/* housekeeping information needed by usb library */
+	unsigned urb_id;
+	size_t urb_size;
+	cp_grant_id_t gid;
+
+	size_t iso_desc_offset;
+	int number_of_packets;
+	int start_frame;
+	char setup_packet[8];
+
+	/* data allways starts here */
+	char buffer[1];
+};
+
+struct usb_ctrlrequest {
+        u8_t bRequestType; 
+        u8_t bRequest;
+        u16_t wValue;
+		u16_t wIndex;
+        u16_t wLength;
+} __attribute__ ((packed));
+
+#ifdef DEBUG
+static void dump_urb(struct usb_urb *urb) {
+	printf("================\n");
+	printf("DUMP: urb (0x%p)\n", urb);
+	printf("================\n");
+	printf("= dev_id: %d\n", urb->dev_id);
+	printf("= type: %d\n", urb->type);
+	printf("= endpoint: %d\n", urb->endpoint);
+	printf("= direction: %d\n", urb->direction);
+	printf("= status: %d\n", urb->status);
+	printf("= error_count: %d\n", urb->error_count);
+	printf("= size: %d\n", urb->size);
+	printf("= actual_length: %d\n", urb->actual_length);
+	printf("= interval %d\n", urb->interval);
+	printf("= transfer_flags %x\n", urb->transfer_flags);
+	printf("= urb_id = %d\n", urb->urb_id);
+	printf("= urb_size = 0x%x\n", urb->urb_size);
+	printf("= setup_packet: \n");
+	printf("=   bRequestType: 0x%x \n",
+	    ((struct usb_ctrlrequest *)urb->setup_packet)->bRequestType);
+	printf("=   bRequest 0x%x \n",
+	    ((struct usb_ctrlrequest *)urb->setup_packet)->bRequest);
+	printf("=   wValue: 0x%x \n",
+	    ((struct usb_ctrlrequest *)urb->setup_packet)->wValue);
+	printf("=   wIndex: 0x%x \n",
+	    ((struct usb_ctrlrequest *)urb->setup_packet)->wIndex);
+	printf("=   wLength: 0x%x \n",
+	    ((struct usb_ctrlrequest *)urb->setup_packet)->wLength);
+	printf("===============\n");
+}
+#else
+#define dumb_urb(x) 
+#endif
+
+/** Submit a URB */
+int usb_send_urb(struct usb_urb* urb);
+
+/** Cancels an URB */ 
+int usb_cancle_urb(struct usb_urb* urb);
+
+/** Gets the USB device ID of an USB device **/
+int usb_get_device_id(int dev_id, struct usb_device_id *usb_device_id);
+
+/* this initializes a session with the HCD */
+int usb_init(char *name);
+
+/** This functions handles a message from the HCD */
+int usb_handle_msg(struct usb_driver *ubd, message *msg);
+
+/** Lets device driver send HCD various information */
+int usb_send_info(long, long);
+
+#endif /* _MINIX_USB_H */
diff -ruNp srclimpio/minix/include/minix/minix/usb_ch9.h proj/minix/include/minix/minix/usb_ch9.h
--- srclimpio/minix/include/minix/minix/usb_ch9.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/usb_ch9.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,217 @@
+#ifndef MINIX_USB_CH9_H
+#define MINIX_USB_CH9_H
+/*
+ * Copyright (c) 1998 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Lennart Augustsson (lennart@augustsson.net) at
+ * Carlstedt Research & Technology.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *        This product includes software developed by the NetBSD
+ *        Foundation, Inc. and its contributors.
+ * 4. Neither the name of The NetBSD Foundation nor the names of its
+ *    contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/* USB DESCRIPTORS */
+/*
+ * The USB records contain some unaligned little-endian word
+ * components.  The U[SG]ETW macros take care of both the alignment
+ * and endian problem and should always be used to access non-byte
+ * values.
+ */
+
+#include <sys/types.h>
+
+typedef u8_t uByte;
+typedef u8_t uWord[2];
+typedef u8_t uDWord[4];
+
+#define USETW2(w,h,l) ((w)[0] = (u_int8_t)(l), (w)[1] = (u_int8_t)(h))
+
+#if 1
+#define UGETW(w) ((w)[0] | ((w)[1] << 8))
+#define USETW(w,v) ((w)[0] = (u_int8_t)(v), (w)[1] = (u_int8_t)((v) >> 8))
+#define UGETDW(w) ((w)[0] | ((w)[1] << 8) | ((w)[2] << 16) | ((w)[3] << 24))
+#define USETDW(w,v) ((w)[0] = (u_int8_t)(v), \
+		     (w)[1] = (u_int8_t)((v) >> 8), \
+		     (w)[2] = (u_int8_t)((v) >> 16), \
+		     (w)[3] = (u_int8_t)((v) >> 24))
+#else
+/*
+ * On little-endian machines that can handle unanliged accesses
+ * (e.g. i386) these macros can be replaced by the following.
+ */
+#define UGETW(w) (*(u_int16_t *)(w))
+#define USETW(w,v) (*(u_int16_t *)(w) = (v))
+#define UGETDW(w) (*(u_int32_t *)(w))
+#define USETDW(w,v) (*(u_int32_t *)(w) = (v))
+#endif
+
+#define UPACKED __attribute__((__packed__))
+
+/* Requests */
+#define	UR_GET_STATUS		0x00
+#define	UR_CLEAR_FEATURE	0x01
+#define	UR_SET_FEATURE		0x03
+#define	UR_SET_ADDRESS		0x05
+#define	UR_GET_DESCRIPTOR	0x06
+#define	UDESC_DEVICE		0x01
+#define	UDESC_CONFIG		0x02
+#define	UDESC_STRING		0x03
+#define	USB_LANGUAGE_TABLE	0x00	/* language ID string index */
+#define	UDESC_INTERFACE		0x04
+#define	UDESC_ENDPOINT		0x05
+#define	UDESC_DEVICE_QUALIFIER	0x06
+#define	UDESC_OTHER_SPEED_CONFIGURATION 0x07
+#define	UDESC_INTERFACE_POWER	0x08
+#define	UDESC_OTG		0x09
+#define	UDESC_DEBUG		0x0A
+#define	UDESC_IFACE_ASSOC	0x0B	/* interface association */
+#define	UDESC_BOS		0x0F	/* binary object store */
+#define	UDESC_DEVICE_CAPABILITY	0x10
+#define	UDESC_CS_DEVICE		0x21	/* class specific */
+#define	UDESC_CS_CONFIG		0x22
+#define	UDESC_CS_STRING		0x23
+#define	UDESC_CS_INTERFACE	0x24
+#define	UDESC_CS_ENDPOINT	0x25
+#define	UDESC_HUB		0x29
+#define	UDESC_ENDPOINT_SS_COMP	0x30	/* super speed */
+#define	UR_SET_DESCRIPTOR	0x07
+#define	UR_GET_CONFIG		0x08
+#define	UR_SET_CONFIG		0x09
+#define	UR_GET_INTERFACE	0x0a
+#define	UR_SET_INTERFACE	0x0b
+#define	UR_SYNCH_FRAME		0x0c
+#define	UR_SET_SEL		0x30
+#define	UR_ISOCH_DELAY		0x31
+
+
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uByte		bDescriptorSubtype;
+} UPACKED usb_descriptor_t;
+
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uWord		bcdUSB;
+#define UD_USB_2_0		0x0200
+#define UD_IS_USB2(d) (UGETW((d)->bcdUSB) >= UD_USB_2_0)
+	uByte		bDeviceClass;
+	uByte		bDeviceSubClass;
+	uByte		bDeviceProtocol;
+	uByte		bMaxPacketSize;
+	/* The fields below are not part of the initial descriptor. */
+	uWord		idVendor;
+	uWord		idProduct;
+	uWord		bcdDevice;
+	uByte		iManufacturer;
+	uByte		iProduct;
+	uByte		iSerialNumber;
+	uByte		bNumConfigurations;
+} UPACKED usb_device_descriptor_t;
+#define USB_DEVICE_DESCRIPTOR_SIZE 18
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uWord		wTotalLength;
+	uByte		bNumInterface;
+	uByte		bConfigurationValue;
+	uByte		iConfiguration;
+	uByte		bmAttributes;
+#define UC_BUS_POWERED		0x80
+#define UC_SELF_POWERED		0x40
+#define UC_REMOTE_WAKEUP	0x20
+	uByte		bMaxPower; /* max current in 2 mA units */
+#define UC_POWER_FACTOR 2
+} UPACKED usb_config_descriptor_t;
+#define USB_CONFIG_DESCRIPTOR_SIZE 9
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uByte		bInterfaceNumber;
+	uByte		bAlternateSetting;
+	uByte		bNumEndpoints;
+	uByte		bInterfaceClass;
+	uByte		bInterfaceSubClass;
+	uByte		bInterfaceProtocol;
+	uByte		iInterface;
+} UPACKED usb_interface_descriptor_t;
+#define USB_INTERFACE_DESCRIPTOR_SIZE 9
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uByte		bEndpointAddress;
+#define UE_GET_DIR(a)	((a) & 0x80)
+#define UE_SET_DIR(a,d)	((a) | (((d)&1) << 7))
+#define UE_DIR_IN	0x80
+#define UE_DIR_OUT	0x00
+#define UE_ADDR		0x0f
+#define UE_GET_ADDR(a)	((a) & UE_ADDR)
+	uByte		bmAttributes;
+#define UE_XFERTYPE	0x03
+#define  UE_CONTROL	0x00
+#define  UE_ISOCHRONOUS	0x01
+#define  UE_BULK	0x02
+#define  UE_INTERRUPT	0x03
+#define UE_GET_XFERTYPE(a)	((a) & UE_XFERTYPE)
+#define UE_ISO_TYPE	0x0c
+#define  UE_ISO_ASYNC	0x04
+#define  UE_ISO_ADAPT	0x08
+#define  UE_ISO_SYNC	0x0c
+#define UE_GET_ISO_TYPE(a)	((a) & UE_ISO_TYPE)
+	uWord		wMaxPacketSize;
+	uByte		bInterval;
+} UPACKED usb_endpoint_descriptor_t;
+#define USB_ENDPOINT_DESCRIPTOR_SIZE 7
+
+typedef struct {
+	uByte		bLength;
+	uByte		bDescriptorType;
+	uWord		bString[127];
+} UPACKED usb_string_descriptor_t;
+
+#define USB_MAX_STRING_LEN 128
+#define USB_MAX_ENCODED_STRING_LEN (USB_MAX_STRING_LEN * 3) /* UTF8 */
+
+struct usb_device_request {
+	uByte	bmRequestType;
+	uByte	bRequest;
+	uWord	wValue;
+	uWord	wIndex;
+	uWord	wLength;
+} UPACKED;
+typedef struct usb_device_request usb_device_request_t;
+
+
+#endif
diff -ruNp srclimpio/minix/include/minix/minix/vbox.h proj/minix/include/minix/minix/vbox.h
--- srclimpio/minix/include/minix/minix/vbox.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/vbox.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,27 @@
+#ifndef _MINIX_VBOX_H
+#define _MINIX_VBOX_H
+
+#include <minix/vboxtype.h>
+
+typedef int vbox_conn_t;
+
+extern int vbox_init(void);
+
+extern vbox_conn_t vbox_open(char *name);
+extern int vbox_close(vbox_conn_t conn);
+extern int vbox_call(vbox_conn_t conn, u32_t function, vbox_param_t *param,
+	int count, int *code);
+
+extern void vbox_set_u32(vbox_param_t *param, u32_t value);
+extern void vbox_set_u64(vbox_param_t *param, u64_t value);
+extern void vbox_set_ptr(vbox_param_t *param, void *ptr, size_t size,
+	unsigned int dir);
+extern void vbox_set_grant(vbox_param_t *param, endpoint_t endpt,
+	cp_grant_id_t grant, size_t off, size_t size, unsigned int dir);
+
+extern u32_t vbox_get_u32(vbox_param_t *param);
+extern u64_t vbox_get_u64(vbox_param_t *param);
+
+extern void vbox_put(vbox_param_t *param, int count);
+
+#endif /* _MINIX_VBOX_H */
diff -ruNp srclimpio/minix/include/minix/minix/vboxfs.h proj/minix/include/minix/minix/vboxfs.h
--- srclimpio/minix/include/minix/minix/vboxfs.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/vboxfs.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,12 @@
+/* Part of libvboxfs - (c) 2012, D.C. van Moolenbroek */
+
+#ifndef _MINIX_VBOXFS_H
+#define _MINIX_VBOXFS_H
+
+#include <minix/sffs.h>
+
+int vboxfs_init(char *share, const struct sffs_table **tablep,
+	int *case_insens, int *read_only);
+void vboxfs_cleanup(void);
+
+#endif /* _MINIX_VBOXFS_H */
diff -ruNp srclimpio/minix/include/minix/minix/vboxif.h proj/minix/include/minix/minix/vboxif.h
--- srclimpio/minix/include/minix/minix/vboxif.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/vboxif.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,33 @@
+#ifndef _MINIX_VBOXIF_H
+#define _MINIX_VBOXIF_H
+
+/*===========================================================================*
+ *			Messages for VBOX device			     *
+ *===========================================================================*/
+
+/* Base type for VBOX requests and responses. */
+#define VBOX_RQ_BASE	0x1600
+#define VBOX_RS_BASE	0x1680
+
+#define IS_VBOX_RQ(type) (((type) & ~0x7f) == VBOX_RQ_BASE)
+#define IS_VBOX_RS(type) (((type) & ~0x7f) == VBOX_RS_BASE)
+
+/* Message types for VBOX requests. */
+#define VBOX_OPEN	(VBOX_RQ_BASE + 0)	/* open a connection */
+#define VBOX_CLOSE	(VBOX_RQ_BASE + 1)	/* close a connection */
+#define VBOX_CALL	(VBOX_RQ_BASE + 2)	/* perform a call */
+#define VBOX_CANCEL	(VBOX_RQ_BASE + 3)	/* cancel an ongoing call */
+
+/* Message types for VBOX responses. */
+#define VBOX_REPLY	(VBOX_RS_BASE + 0)	/* general reply code */
+
+/* Field names for VBOX messages. */
+#define VBOX_CONN	m2_i1	/* connection identifier */
+#define VBOX_GRANT	m2_i2	/* grant ID of buffer or name */
+#define VBOX_COUNT	m2_i3	/* number of bytes or elements */
+#define VBOX_RESULT	m2_i1	/* result or error code */
+#define VBOX_CODE	m2_i2	/* VirtualBox result code */
+#define VBOX_FUNCTION	m2_l1	/* function call number */
+#define VBOX_ID		m2_l2	/* opaque request ID */
+
+#endif /* _MINIX_VBOXIF_H */
diff -ruNp srclimpio/minix/include/minix/minix/vboxtype.h proj/minix/include/minix/minix/vboxtype.h
--- srclimpio/minix/include/minix/minix/vboxtype.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/vboxtype.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,36 @@
+#ifndef _MINIX_VBOXTYPE_H
+#define _MINIX_VBOXTYPE_H
+
+/* This header declares the type definitions shared between VBOX driver, the
+ * interface in libsys, and any caller of those interface functions.
+ */
+
+/* Call parameter type. */
+typedef enum {
+  VBOX_TYPE_INVALID,		/* invalid type */
+  VBOX_TYPE_U32,		/* 32-bit value */
+  VBOX_TYPE_U64,		/* 64-bit value */
+  VBOX_TYPE_PTR			/* pointer to granted memory area */
+} vbox_type_t;
+
+/* Call parameter transfer direction. */
+#define VBOX_DIR_IN	0x01	/* from host to guest */
+#define VBOX_DIR_OUT	0x02	/* from guest to host */
+#define VBOX_DIR_INOUT	(VBOX_DIR_IN | VBOX_DIR_OUT)
+
+/* Call parameter. */
+typedef struct {
+  vbox_type_t type;
+  union {
+	u32_t u32;
+	u64_t u64;
+	struct {
+		cp_grant_id_t grant;
+		size_t off;
+		size_t size;
+		unsigned int dir;
+	} ptr;
+  };
+} vbox_param_t;
+
+#endif /*_MINIX_VBOXTYPE_H */
diff -ruNp srclimpio/minix/include/minix/minix/vfsif.h proj/minix/include/minix/minix/vfsif.h
--- srclimpio/minix/include/minix/minix/vfsif.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/vfsif.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,84 @@
+#ifndef __MINIX_VFSIF_H
+#define __MINIX_VFSIF_H
+
+#include <sys/types.h>
+#include <limits.h>
+
+/* VFS/FS flags */
+#define REQ_RDONLY		001	/* FS is mounted read-only */
+#define REQ_ISROOT		002	/* FS is root file system */
+
+#define PATH_NOFLAGS		000
+#define PATH_RET_SYMLINK	010	/* Return a symlink object (i.e.
+					 * do not continue with the contents
+					 * of the symlink if it is the last
+					 * component in a path). */
+#define PATH_GET_UCRED		020	/* Request provides a grant ID in m9_l1
+					 * and struct ucred size in m9_s4 (as
+					 * opposed to a REQ_UID). */
+
+#define RES_NOFLAGS		000
+#define RES_THREADED		001	/* FS supports multithreading */
+#define RES_HASPEEK		002	/* FS implements REQ_PEEK/REQ_BPEEK */
+#define RES_64BIT		004	/* FS can handle 64-bit file sizes */
+
+/* VFS/FS error messages */
+#define EENTERMOUNT              (-301)
+#define ELEAVEMOUNT              (-302)
+#define ESYMLINK                 (-303)
+
+/* VFS/FS types */
+
+/* User credential structure */
+typedef struct {
+	uid_t vu_uid;
+	gid_t vu_gid;
+	int vu_ngroups;
+	gid_t vu_sgroups[NGROUPS_MAX];
+} vfs_ucred_t;
+
+/* Request numbers */
+#define REQ_GETNODE	(FS_BASE + 1)	/* Should be removed */
+#define REQ_PUTNODE	(FS_BASE + 2)
+#define REQ_SLINK	(FS_BASE + 3)
+#define REQ_FTRUNC	(FS_BASE + 4)
+#define REQ_CHOWN	(FS_BASE + 5)
+#define REQ_CHMOD	(FS_BASE + 6)
+#define REQ_INHIBREAD	(FS_BASE + 7)
+#define REQ_STAT	(FS_BASE + 8)
+#define REQ_UTIME	(FS_BASE + 9)
+#define REQ_STATVFS	(FS_BASE + 10)
+#define REQ_BREAD	(FS_BASE + 11)
+#define REQ_BWRITE	(FS_BASE + 12)
+#define REQ_UNLINK	(FS_BASE + 13)
+#define REQ_RMDIR	(FS_BASE + 14)
+#define REQ_UNMOUNT	(FS_BASE + 15)
+#define REQ_SYNC	(FS_BASE + 16)
+#define REQ_NEW_DRIVER	(FS_BASE + 17)
+#define REQ_FLUSH	(FS_BASE + 18)
+#define REQ_READ	(FS_BASE + 19)
+#define REQ_WRITE	(FS_BASE + 20)
+#define REQ_MKNOD	(FS_BASE + 21)
+#define REQ_MKDIR	(FS_BASE + 22)
+#define REQ_CREATE	(FS_BASE + 23)
+#define REQ_LINK	(FS_BASE + 24)
+#define REQ_RENAME	(FS_BASE + 25)
+#define REQ_LOOKUP	(FS_BASE + 26)
+#define REQ_MOUNTPOINT	(FS_BASE + 27)
+#define REQ_READSUPER	(FS_BASE + 28)
+#define REQ_NEWNODE	(FS_BASE + 29)
+#define REQ_RDLINK	(FS_BASE + 30)
+#define REQ_GETDENTS	(FS_BASE + 31)
+#define REQ_PEEK	(FS_BASE + 32)
+#define REQ_BPEEK	(FS_BASE + 33)
+
+#define NREQS			    34
+
+#define IS_FS_RQ(type) (((type) & ~0xff) == FS_BASE)
+
+#define TRNS_GET_ID(t)		((t) & 0xFFFF)
+#define TRNS_ADD_ID(t,id)	(((t) << 16) | ((id) & 0xFFFF))
+#define TRNS_DEL_ID(t)		((short)((t) >> 16))
+
+#endif
+
diff -ruNp srclimpio/minix/include/minix/minix/virtio.h proj/minix/include/minix/minix/virtio.h
--- srclimpio/minix/include/minix/minix/virtio.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/virtio.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,139 @@
+/*
+ * Generic virtio library for MINIX 3
+ *
+ * Copyright (c) 2013, A. Welzel, <arne.welzel@gmail.com>
+ *
+ * This software is released under the BSD license. See the LICENSE file
+ * included in the main directory of this source distribution for the
+ * license terms and conditions.
+ */
+
+#ifndef _MINIX_VIRTIO_H
+#define _MINIX_VIRTIO_H 1
+
+#include <sys/types.h>
+
+#define VIRTIO_VENDOR_ID			0x1AF4
+
+#define VIRTIO_HOST_F_OFF			0x0000
+#define VIRTIO_GUEST_F_OFF			0x0004
+#define VIRTIO_QADDR_OFF			0x0008
+
+#define VIRTIO_QSIZE_OFF			0x000C
+#define VIRTIO_QSEL_OFF				0x000E
+#define VIRTIO_QNOTFIY_OFF			0x0010
+
+#define VIRTIO_DEV_STATUS_OFF			0x0012
+#define VIRTIO_ISR_STATUS_OFF			0x0013
+#define VIRTIO_DEV_SPECIFIC_OFF			0x0014
+/* if msi is enabled, device specific headers shift by 4 */
+#define VIRTIO_MSI_ADD_OFF			0x0004
+#define VIRTIO_STATUS_ACK			0x01
+#define VIRTIO_STATUS_DRV			0x02
+#define VIRTIO_STATUS_DRV_OK			0x04
+#define VIRTIO_STATUS_FAIL			0x80
+
+
+/* Feature description */
+struct virtio_feature {
+	const char *name;
+	u8_t bit;
+	u8_t host_support;
+	u8_t guest_support;
+};
+
+/* Forward declaration of struct virtio_device.
+ *
+ * This structure is opaque to the caller.
+ */
+struct virtio_device;
+
+/* Find a virtio device with subdevice id subdevid. Returns a pointer
+ * to an opaque virtio_device instance.
+ */
+struct virtio_device *virtio_setup_device(u16_t subdevid,
+		const char *name,
+		struct virtio_feature *features,
+		int feature_count,
+		int threads, int skip);
+
+/* Attempt to allocate queue_cnt memory for queues */
+int virtio_alloc_queues(struct virtio_device *dev, int num_queues);
+
+/* Register the IRQ policy and indicate to the host we are ready to go */
+void virtio_device_ready(struct virtio_device *dev);
+
+/* Unregister the IRQ and reset the device */
+void virtio_reset_device(struct virtio_device *dev);
+
+/* Free the memory used by all queues */
+void virtio_free_queues(struct virtio_device *dev);
+
+/* Free all memory allocated for the device (except the queue memory,
+ * which has to be freed before with virtio_free_queues()).
+ *
+ * Don't touch the device afterwards! This is like free(dev).
+ */
+void virtio_free_device(struct virtio_device *dev);
+
+
+/* Feature helpers */
+int virtio_guest_supports(struct virtio_device *dev, int bit);
+int virtio_host_supports(struct virtio_device *dev, int bit);
+
+/*
+ * Use num vumap_phys elements and chain these as vring_desc elements
+ * into the vring.
+ *
+ * Kick the queue if needed.
+ *
+ * data is opaque and returned by virtio_from_queue() when the host
+ * processed the descriptor chain.
+ *
+ * Note: The last bit of vp_addr is used to flag whether an iovec is
+ *	 writable. This implies that only word aligned buffers can be
+ *	 used.
+ */
+int virtio_to_queue(struct virtio_device *dev, int qidx,
+			struct vumap_phys *bufs, size_t num, void *data);
+
+/*
+ * If the host used a chain of descriptors, return 0 and set data
+ * as was given to virtio_to_queue(). If the host has not processed
+ * any element returns -1.
+ */
+int virtio_from_queue(struct virtio_device *dev, int qidx, void **data);
+
+/* IRQ related functions */
+void virtio_irq_enable(struct virtio_device *dev);
+void virtio_irq_disable(struct virtio_device *dev);
+
+/* Checks the ISR field of the device and returns true if
+ * the interrupt was for this device.
+ */
+int virtio_had_irq(struct virtio_device *dev);
+
+
+u32_t virtio_read32(struct virtio_device *dev, i32_t offset);
+u16_t virtio_read16(struct virtio_device *dev, i32_t offset);
+u8_t virtio_read8(struct virtio_device *dev, i32_t offset);
+void virtio_write32(struct virtio_device *dev, i32_t offset, u32_t val);
+void virtio_write16(struct virtio_device *dev, i32_t offset, u16_t val);
+void virtio_write8(struct virtio_device *dev, i32_t offset, u8_t val);
+
+
+/*
+ * Device specific reads take MSI offset into account and all reads
+ * are at offset 20.
+ *
+ * Something like:
+ * read(off) --> readX(20 + (msi ? 4 : 0) + off)
+ */
+u32_t virtio_sread32(struct virtio_device *dev, i32_t offset);
+u16_t virtio_sread16(struct virtio_device *dev, i32_t offset);
+u8_t virtio_sread8(struct virtio_device *dev, i32_t offset);
+void virtio_swrite32(struct virtio_device *dev, i32_t offset, u32_t val);
+void virtio_swrite16(struct virtio_device *dev, i32_t offset, u16_t val);
+void virtio_swrite8(struct virtio_device *dev, i32_t offset, u8_t val);
+
+#endif /* _MINIX_VIRTIO_H */
diff -ruNp srclimpio/minix/include/minix/minix/vm.h proj/minix/include/minix/minix/vm.h
--- srclimpio/minix/include/minix/minix/vm.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/vm.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,91 @@
+/* Prototypes and definitions for VM interface. */
+
+#ifndef _MINIX_VM_H
+#define _MINIX_VM_H
+
+#include <sys/types.h>
+#include <minix/endpoint.h>
+
+int vm_exit(endpoint_t ep);
+int vm_fork(endpoint_t ep, int slotno, endpoint_t *child_ep);
+int vm_willexit(endpoint_t ep);
+int vm_adddma(endpoint_t proc_e, phys_bytes start, phys_bytes size);
+int vm_deldma(endpoint_t proc_e, phys_bytes start, phys_bytes size);
+int vm_getdma(endpoint_t *procp, phys_bytes *basep, phys_bytes *sizep);
+void *vm_map_phys(endpoint_t who, void *physaddr, size_t len);
+int vm_unmap_phys(endpoint_t who, void *vaddr, size_t len);
+
+int vm_notify_sig(endpoint_t ep, endpoint_t ipc_ep);
+int vm_set_priv(endpoint_t ep, void *buf, int sys_proc);
+int vm_update(endpoint_t src_e, endpoint_t dst_e);
+int vm_memctl(endpoint_t ep, int req);
+int vm_query_exit(endpoint_t *endpt);
+int vm_watch_exit(endpoint_t ep);
+int vm_forgetblock(u64_t id);
+void vm_forgetblocks(void);
+int minix_vfs_mmap(endpoint_t who, off_t offset, size_t len,
+        dev_t dev, ino_t ino, int fd, u32_t vaddr, u16_t clearend, u16_t
+	flags);
+
+void *minix_mmap_for(endpoint_t forwhom,
+        void *addr, size_t len, int prot, int flags, int fd, off_t offset);
+int minix_vfs_mmap(endpoint_t who, off_t offset, size_t len,
+        dev_t dev, ino_t ino, int fd, u32_t vaddr, u16_t clearend,
+        u16_t flags);
+
+/* minix vfs mmap flags */
+#define MVM_WRITABLE	0x8000
+
+/* VM kernel request types. */
+#define VMPTYPE_NONE		0
+#define VMPTYPE_CHECK		1
+
+struct vm_stats_info {
+  unsigned int vsi_pagesize;	/* page size */
+  unsigned long vsi_total;	/* total number of memory pages */
+  unsigned long vsi_free;	/* number of free pages */
+  unsigned long vsi_largest;	/* largest number of consecutive free pages */
+  unsigned long vsi_cached;	/* number of pages cached for file systems */
+};
+
+struct vm_usage_info {
+  vir_bytes vui_total;		/* total amount of process memory */
+  vir_bytes vui_common;		/* part of memory mapped in more than once */
+  vir_bytes vui_shared;		/* shared (non-COW) part of common memory */
+};
+
+struct vm_region_info {
+  vir_bytes vri_addr;		/* base address of region */
+  vir_bytes vri_length;		/* length of region */
+  int vri_prot;			/* protection flags (PROT_) */
+  int vri_flags;		/* memory flags (subset of MAP_) */
+};
+
+#define MAX_VRI_COUNT	64	/* max. number of regions provided at once */
+
+int vm_info_stats(struct vm_stats_info *vfi);
+int vm_info_usage(endpoint_t who, struct vm_usage_info *vui);
+int vm_info_region(endpoint_t who, struct vm_region_info *vri, int
+	count, vir_bytes *next);
+int vm_procctl_clear(endpoint_t ep);
+int vm_procctl_handlemem(endpoint_t ep, vir_bytes m1, vir_bytes m2, int wr);
+
+int vm_set_cacheblock(void *block, dev_t dev, off_t dev_offset,
+        ino_t ino, off_t ino_offset, u32_t *flags, int blocksize);
+
+void *vm_map_cacheblock(dev_t dev, off_t dev_offset,
+        ino_t ino, off_t ino_offset, u32_t *flags, int blocksize);
+
+int vm_clear_cache(dev_t dev);
+
+/* flags for vm cache functions */
+#define VMMC_FLAGS_LOCKED	0x01	/* someone is updating the flags; don't read/write */
+#define VMMC_DIRTY		0x02	/* dirty buffer and it may not be evicted */
+#define VMMC_EVICTED		0x04	/* VM has evicted the buffer and it's invalid */
+#define VMMC_BLOCK_LOCKED	0x08	/* client is using it and it may not be evicted */
+
+/* special inode number for vm cache functions */
+#define VMC_NO_INODE		0	/* to reference a disk block, no associated file */
+
+#endif /* _MINIX_VM_H */
+
diff -ruNp srclimpio/minix/include/minix/minix/vtreefs.h proj/minix/include/minix/minix/vtreefs.h
--- srclimpio/minix/include/minix/minix/vtreefs.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/minix/vtreefs.h	Thu Oct 29 22:28:03 2015
@@ -0,0 +1,57 @@
+#ifndef _MINIX_VTREEFS_H
+#define _MINIX_VTREEFS_H
+
+struct inode;
+typedef int index_t;
+typedef void *cbdata_t;
+
+#define NO_INDEX	((index_t) -1)
+
+/* Maximum file name length, excluding terminating null character. It is set
+ * to a low value to limit memory usage, but can be changed to any value.
+ */
+#define PNAME_MAX	24
+
+struct inode_stat {
+	mode_t mode;		/* file mode (type and permissions) */
+	uid_t uid;		/* user ID */
+	gid_t gid;		/* group ID */
+	off_t size;		/* file size */
+	dev_t dev;		/* device number (for char/block type files) */
+};
+
+struct fs_hooks {
+	void (*init_hook)(void);
+	void (*cleanup_hook)(void);
+	int (*lookup_hook)(struct inode *inode, char *name, cbdata_t cbdata);
+	int (*getdents_hook)(struct inode *inode, cbdata_t cbdata);
+	int (*read_hook)(struct inode *inode, off_t offset, char **ptr,
+		size_t *len, cbdata_t cbdata);
+	int (*rdlink_hook)(struct inode *inode, char *ptr, size_t max,
+		cbdata_t cbdata);
+	int (*message_hook)(message *m);
+};
+
+extern struct inode *add_inode(struct inode *parent, char *name, index_t index,
+	struct inode_stat *stat, index_t nr_indexed_entries, cbdata_t cbdata);
+extern void delete_inode(struct inode *inode);
+
+extern struct inode *get_inode_by_name(struct inode *parent, char *name);
+extern struct inode *get_inode_by_index(struct inode *parent, index_t index);
+
+extern char const *get_inode_name(struct inode *inode);
+extern index_t get_inode_index(struct inode *inode);
+extern cbdata_t get_inode_cbdata(struct inode *inode);
+
+extern struct inode *get_root_inode(void);
+extern struct inode *get_parent_inode(struct inode *inode);
+extern struct inode *get_first_inode(struct inode *parent);
+extern struct inode *get_next_inode(struct inode *previous);
+
+extern void get_inode_stat(struct inode *inode, struct inode_stat *stat);
+extern void set_inode_stat(struct inode *inode, struct inode_stat *stat);
+
+extern void start_vtreefs(struct fs_hooks *hooks, unsigned int nr_inodes,
+	struct inode_stat *stat, index_t nr_indexed_entries);
+
+#endif /* _MINIX_VTREEFS_H */
diff -ruNp srclimpio/minix/include/minix/syncvar.h proj/minix/include/minix/syncvar.h
--- srclimpio/minix/include/minix/syncvar.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/include/minix/syncvar.h	Fri Oct 30 12:56:36 2015
@@ -0,0 +1,68 @@
+#include<lib.h>
+#include<unistd.h>
+
+
+int mutex_init()
+{
+        message m;
+        return( _syscall(PM_PROC_NR, PM_MUTEX_INIT, &m));
+}
+
+int mutex_destroy(int mutex_num)
+{
+        message m;
+	m.m1_i1 = mutex_num;
+        return( _syscall(PM_PROC_NR, PM_MUTEX_DESTROY, &m));
+}
+
+int mutex_lock(int mutex_num)
+{
+        message m;
+	m.m1_i1 = mutex_num;	
+        return( _syscall(PM_PROC_NR, PM_MUTEX_LOCK, &m));
+}
+
+int mutex_unlock(int mutex_num)
+{
+        message m;
+	m.m1_i1 = mutex_num;
+        return( _syscall(PM_PROC_NR, PM_MUTEX_UNLOCK, &m));
+}
+
+int cv_init()
+{
+        message m;
+        return( _syscall(PM_PROC_NR, PM_CV_INIT, &m));
+}
+
+int cv_destroy(int cond_num)
+{
+        message m;
+        m.m1_i1 = cond_num;
+        return( _syscall(PM_PROC_NR, PM_CV_DESTROY, &m));
+}
+
+int cv_wait(int cond_num)
+{
+        message m;
+        m.m1_i1 = cond_num;
+        return( _syscall(PM_PROC_NR, PM_CV_WAIT, &m));
+}
+
+int cv_signal(int cond_num)
+{
+        message m;
+        m.m1_i1 = cond_num;
+        return( _syscall(PM_PROC_NR, PM_CV_SIGNAL, &m));
+}
+
+int cv_broadcast(int cond_num)
+{
+        message m;
+        m.m1_i1 = cond_num;
+        return( _syscall(PM_PROC_NR, PM_CV_BROADCAST, &m));
+}
+
+
+
+
diff -ruNp srclimpio/minix/kernel/table.c proj/minix/kernel/table.c
--- srclimpio/minix/kernel/table.c	Thu Oct 29 20:46:53 2015
+++ proj/minix/kernel/table.c	Thu Oct 29 22:43:19 2015
@@ -62,5 +62,6 @@ struct boot_image image[NR_BOOT_PROCS] = {
 {VM_PROC_NR,    "vm"    },
 {PFS_PROC_NR,   "pfs"   },
 {INIT_PROC_NR,  "init"  },
+{SYNC_PROC_NR,  "syncvar"    },
 };
 
diff -ruNp srclimpio/minix/servers/Makefile proj/minix/servers/Makefile
--- srclimpio/minix/servers/Makefile	Thu Oct 29 20:46:54 2015
+++ proj/minix/servers/Makefile	Thu Oct 29 22:21:29 2015
@@ -1,6 +1,6 @@
 .include <bsd.own.mk>
 
-SUBDIR+=	ds input pm rs sched vfs vm
+SUBDIR+=	ds input pm rs sched vfs vm syncvar
 
 .if ${MKIMAGEONLY} == "no"
 SUBDIR+=	ipc is devman
diff -ruNp srclimpio/minix/servers/pm/misc.c proj/minix/servers/pm/misc.c
--- srclimpio/minix/servers/pm/misc.c	Thu Oct 29 20:46:54 2015
+++ proj/minix/servers/pm/misc.c	Thu Oct 29 22:49:32 2015
@@ -59,6 +59,115 @@ static char *uts_tbl[] = {
 unsigned long calls_stats[NR_PM_CALLS];
 #endif
 
+/*======================*
+*          do_mycall    *
+*=======================*/
+int do_mycall()
+{
+	printf("hello word! this is my world\n");
+	return(0);
+}
+/*=====================*
+*        do_mycalls    *
+*=====================*/
+int do_mycalls()
+{
+	printf("HOLA AGREGUE UNA NUEVA LLAMADA AL SISTEMA\n");
+	return(0);
+}
+
+/*=====================*
+*        do_mutex_init *
+*=====================*/
+int do_mutex_init()
+{       
+        message m;
+	return (_taskcall(SYNC_PROC_NR, SYNC_MUTEX_INIT, &m));
+        
+}
+
+/*=====================*
+*    do_mutex_destroy *
+*=====================*/
+int do_mutex_destroy()
+{
+	message m;
+	m.m1_i1 = m_in.m1_i1;
+        return (_taskcall(SYNC_PROC_NR, SYNC_MUTEX_DESTROY, &m));
+}
+
+/*=====================* 
+* do_mutex_lock * 
+*=====================*/ 
+int do_mutex_lock() {
+        
+	message m;
+	m.m1_i1 = m_in.m1_i1;
+        return (_taskcall(SYNC_PROC_NR, SYNC_MUTEX_LOCK, &m));
+}
+
+/*=====================*
+*   do_mutex_unlock    *
+*=====================*/
+int do_mutex_unlock()
+{
+        message m;
+        m.m1_i1 = m_in.m1_i1;
+        return (_taskcall(SYNC_PROC_NR, SYNC_MUTEX_UNLOCK, &m));
+}
+
+/*=====================*
+*        do_cv_init *
+*=====================*/
+int do_cv_init()
+{
+        message m;
+        return (_taskcall(SYNC_PROC_NR, SYNC_CV_INIT, &m));
+
+}
+
+/*=====================*
+*    do_cv_destroy *
+*=====================*/
+int do_cv_destroy()
+{
+        message m;
+        m.m1_i1 = m_in.m1_i1;
+        return (_taskcall(SYNC_PROC_NR, SYNC_CV_DESTROY, &m));
+}
+
+/*=====================*
+*    do_cv_wait *
+*=====================*/
+int do_cv_wait()
+{
+        message m;
+        m.m1_i1 = m_in.m1_i1;
+        return (_taskcall(SYNC_PROC_NR, SYNC_CV_WAIT, &m));
+}
+
+/*=====================*
+*    do_cv_signal *
+*=====================*/
+int do_cv_signal()
+{
+        message m;
+        m.m1_i1 = m_in.m1_i1;
+        return (_taskcall(SYNC_PROC_NR, SYNC_CV_SIGNAL, &m));
+}
+
+/*=====================*
+*    do_cv_broadcast *
+*=====================*/
+int do_cv_broadcast()
+{
+        message m;
+        m.m1_i1 = m_in.m1_i1;
+        return (_taskcall(SYNC_PROC_NR, SYNC_CV_BROADCAST, &m));
+}
+
+
+
 /*===========================================================================*
  *				do_sysuname				     *
  *===========================================================================*/
diff -ruNp srclimpio/minix/servers/pm/proto.h proj/minix/servers/pm/proto.h
--- srclimpio/minix/servers/pm/proto.h	Thu Oct 29 20:46:54 2015
+++ proj/minix/servers/pm/proto.h	Fri Oct 30 10:29:24 2015
@@ -46,6 +46,18 @@ int do_getepinfo(void);
 int do_svrctl(void);
 int do_getsetpriority(void);
 int do_getrusage(void);
+int do_mycall(void);
+int do_mycalls(void);
+int do_mutex_init(void);
+int do_mutex_destroy(void);
+int do_mutex_lock(void);
+int do_mutex_unlock(void);
+int do_cv_init(void);
+int do_cv_destroy(void);
+int do_cv_wait(void);
+int do_cv_signal(void);
+int do_cv_broadcast(void);
+
 
 /* schedule.c */
 void sched_init(void);
diff -ruNp srclimpio/minix/servers/pm/table.c proj/minix/servers/pm/table.c
--- srclimpio/minix/servers/pm/table.c	Thu Oct 29 20:46:54 2015
+++ proj/minix/servers/pm/table.c	Thu Oct 29 22:49:23 2015
@@ -5,7 +5,7 @@
 #define _TABLE
 
 #include "pm.h"
-#include <minix/callnr.h>
+#include </usr/src/minix/include/minix/callnr.h>
 #include <signal.h>
 #include "mproc.h"
 
@@ -58,5 +58,17 @@ int (* const call_vec[NR_PM_CALLS])(void) = {
 	CALL(PM_EXEC_RESTART)	= do_execrestart,
 	CALL(PM_GETEPINFO)	= do_getepinfo,		/* getepinfo(2) */
 	CALL(PM_GETPROCNR)	= do_getprocnr,		/* getprocnr(2) */
-	CALL(PM_GETSYSINFO)	= do_getsysinfo		/* getsysinfo(2) */
+	CALL(PM_GETSYSINFO)	= do_getsysinfo,        /* getsysinfo(2) */
+        CALL(PM_MYCALL)         = do_mycall,            /* 48 = (stty) */
+	CALL(PM_MYCALLS)	= do_mycalls,		/* 49 = (stty) */
+	CALL(PM_MUTEX_INIT)	= do_mutex_init,	/* 50 = (stty) */
+	CALL(PM_MUTEX_DESTROY)	= do_mutex_destroy,	/* 51 = (stty) */
+	CALL(PM_MUTEX_LOCK)	= do_mutex_lock,	/* 52 = (stty) */
+	CALL(PM_MUTEX_UNLOCK)	= do_mutex_unlock,	/* 53 = (stty) */	
+	CALL(PM_CV_INIT)	= do_cv_init,		/* 54 = (stty) */	
+	CALL(PM_CV_DESTROY)	= do_cv_destroy,	/* 55 = (stty) */	
+	CALL(PM_CV_WAIT)	= do_cv_wait,		/* 56 = (stty) */	
+	CALL(PM_CV_SIGNAL)	= do_cv_signal,		/* 57 = (stty) */	
+	CALL(PM_CV_BROADCAST)	= do_cv_broadcast	/* 58 = (stty) */	
+
 };
diff -ruNp srclimpio/minix/servers/rs/table.c proj/minix/servers/rs/table.c
--- srclimpio/minix/servers/rs/table.c	Thu Oct 29 20:46:54 2015
+++ proj/minix/servers/rs/table.c	Thu Oct 29 22:41:14 2015
@@ -25,6 +25,7 @@ struct boot_image_priv boot_image_priv_table[] = {
 {MFS_PROC_NR,"fs_imgrd", SRV_F  },
 {PFS_PROC_NR,  "pfs",    SRV_F  },
 {INIT_PROC_NR, "init",   USR_F  },
+{SYNC_PROC_NR, "syncvar", SRV_F },
 {NULL_BOOT_NR, "",       0,     } /* null entry */
 };
 
@@ -37,6 +38,7 @@ struct boot_image_sys boot_image_sys_table[] = {
   { VFS_PROC_NR,      SRVR_SF                           },
   { MFS_PROC_NR,      0                                 },
   { PFS_PROC_NR,      SRV_SF                            },
+  { SYNC_PROC_NR,       SRVR_SF                           },
   { DEFAULT_BOOT_NR,  SRV_SF                            } /* default entry */
 };
 
diff -ruNp srclimpio/minix/servers/syncvar/.depend proj/minix/servers/syncvar/.depend
--- srclimpio/minix/servers/syncvar/.depend	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/.depend	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,209 @@
+main.ln main.o: main.c pm.h /usr/include/minix/config.h \
+  /usr/include/minix/sys_config.h /usr/include/sys/types.h \
+  /usr/include/sys/featuretest.h /usr/include/machine/types.h \
+  /usr/include/sys/cdefs.h /usr/include/machine/cdefs.h \
+  /usr/include/sys/cdefs_elf.h /usr/include/machine/int_types.h \
+  /usr/include/machine/ansi.h /usr/include/sys/ansi.h \
+  /usr/include/machine/endian.h /usr/include/sys/endian.h \
+  /usr/include/machine/endian_machdep.h /usr/include/machine/bswap.h \
+  /usr/include/machine/byte_swap.h /usr/include/sys/bswap.h \
+  /usr/include/sys/fd_set.h /usr/include/minix/const.h \
+  /usr/include/machine/archconst.h /usr/include/sys/null.h \
+  /usr/include/minix/type.h /usr/include/machine/multiboot.h \
+  /usr/include/sys/sigtypes.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/stdint.h /usr/include/stdint.h \
+  /usr/include/machine/int_mwgwtypes.h /usr/include/machine/int_limits.h \
+  /usr/include/machine/int_const.h /usr/include/machine/wchar_limits.h \
+  /usr/include/machine/interrupt.h /usr/include/fcntl.h \
+  /usr/include/sys/stat.h /usr/include/sys/time.h \
+  /usr/include/sys/select.h /usr/include/time.h /usr/include/unistd.h \
+  /usr/include/sys/unistd.h /usr/include/string.h /usr/include/strings.h \
+  /usr/include/minix/syslib.h /usr/include/minix/ipc.h \
+  /usr/include/minix/ipcconst.h /usr/include/machine/ipcconst.h \
+  /usr/include/sys/signal.h /usr/include/sys/siginfo.h \
+  /usr/include/machine/signal.h /usr/include/machine/fpu.h \
+  /usr/include/machine/trap.h /usr/include/x86/trap.h \
+  /usr/include/sys/ucontext.h /usr/include/machine/mcontext.h \
+  /usr/include/minix/u64.h /usr/include/minix/devio.h \
+  /usr/include/minix/safecopies.h /usr/include/minix/vm.h \
+  /usr/include/minix/endpoint.h /usr/include/minix/com.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/limits.h /usr/include/limits.h \
+  /usr/include/machine/limits.h /usr/include/sys/syslimits.h \
+  /usr/include/minix/sef.h /usr/include/stdio.h \
+  /usr/include/minix/sysutil.h /usr/include/minix/timers.h \
+  /usr/include/minix/minlib.h /usr/include/sys/mount.h \
+  /usr/include/sys/param.h /usr/include/sys/inttypes.h \
+  /usr/include/machine/int_fmtio.h /usr/include/machine/param.h \
+  /usr/include/sys/uio.h /usr/include/sys/ucred.h \
+  /usr/include/sys/fstypes.h /usr/include/sys/queue.h \
+  /usr/include/sys/rwlock.h /usr/include/machine/rwlock.h \
+  /usr/include/x86/rwlock.h /usr/include/sys/statvfs.h \
+  /usr/include/sys/specificdata.h /usr/include/sys/mutex.h \
+  /usr/include/machine/mutex.h /usr/include/x86/mutex.h \
+  /usr/include/sys/condvar.h /usr/include/minix/param.h \
+  /usr/include/errno.h /usr/include/sys/errno.h const.h type.h proto.h \
+  glo.h /usr/include/minix/callnr.h /usr/include/minix/ds.h \
+  /usr/include/signal.h /usr/include/stdlib.h \
+  /usr/include/sys/resource.h /usr/include/sys/utsname.h \
+  /usr/include/sys/wait.h /usr/include/machine/archtypes.h \
+  /usr/include/machine/stackframe.h /usr/include/env.h \
+  /usr/include/assert.h mproc.h /usr/src/minix/kernel/const.h \
+  /usr/include/minix/bitmap.h /usr/src/minix/kernel/config.h \
+  /usr/src/minix/kernel/debug.h /usr/include/minix/debug.h \
+  /usr/src/minix/kernel/proc.h /usr/include/minix/portio.h \
+  /usr/src/minix/kernel/priv.h /usr/include/minix/priv.h \
+  /usr/src/minix/kernel/type.h
+misc.ln misc.o: misc.c pm.h /usr/include/minix/config.h \
+  /usr/include/minix/sys_config.h /usr/include/sys/types.h \
+  /usr/include/sys/featuretest.h /usr/include/machine/types.h \
+  /usr/include/sys/cdefs.h /usr/include/machine/cdefs.h \
+  /usr/include/sys/cdefs_elf.h /usr/include/machine/int_types.h \
+  /usr/include/machine/ansi.h /usr/include/sys/ansi.h \
+  /usr/include/machine/endian.h /usr/include/sys/endian.h \
+  /usr/include/machine/endian_machdep.h /usr/include/machine/bswap.h \
+  /usr/include/machine/byte_swap.h /usr/include/sys/bswap.h \
+  /usr/include/sys/fd_set.h /usr/include/minix/const.h \
+  /usr/include/machine/archconst.h /usr/include/sys/null.h \
+  /usr/include/minix/type.h /usr/include/machine/multiboot.h \
+  /usr/include/sys/sigtypes.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/stdint.h /usr/include/stdint.h \
+  /usr/include/machine/int_mwgwtypes.h /usr/include/machine/int_limits.h \
+  /usr/include/machine/int_const.h /usr/include/machine/wchar_limits.h \
+  /usr/include/machine/interrupt.h /usr/include/fcntl.h \
+  /usr/include/sys/stat.h /usr/include/sys/time.h \
+  /usr/include/sys/select.h /usr/include/time.h /usr/include/unistd.h \
+  /usr/include/sys/unistd.h /usr/include/string.h /usr/include/strings.h \
+  /usr/include/minix/syslib.h /usr/include/minix/ipc.h \
+  /usr/include/minix/ipcconst.h /usr/include/machine/ipcconst.h \
+  /usr/include/sys/signal.h /usr/include/sys/siginfo.h \
+  /usr/include/machine/signal.h /usr/include/machine/fpu.h \
+  /usr/include/machine/trap.h /usr/include/x86/trap.h \
+  /usr/include/sys/ucontext.h /usr/include/machine/mcontext.h \
+  /usr/include/minix/u64.h /usr/include/minix/devio.h \
+  /usr/include/minix/safecopies.h /usr/include/minix/vm.h \
+  /usr/include/minix/endpoint.h /usr/include/minix/com.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/limits.h /usr/include/limits.h \
+  /usr/include/machine/limits.h /usr/include/sys/syslimits.h \
+  /usr/include/minix/sef.h /usr/include/stdio.h \
+  /usr/include/minix/sysutil.h /usr/include/minix/timers.h \
+  /usr/include/minix/minlib.h /usr/include/sys/mount.h \
+  /usr/include/sys/param.h /usr/include/sys/inttypes.h \
+  /usr/include/machine/int_fmtio.h /usr/include/machine/param.h \
+  /usr/include/sys/uio.h /usr/include/sys/ucred.h \
+  /usr/include/sys/fstypes.h /usr/include/sys/queue.h \
+  /usr/include/sys/rwlock.h /usr/include/machine/rwlock.h \
+  /usr/include/x86/rwlock.h /usr/include/sys/statvfs.h \
+  /usr/include/sys/specificdata.h /usr/include/sys/mutex.h \
+  /usr/include/machine/mutex.h /usr/include/x86/mutex.h \
+  /usr/include/sys/condvar.h /usr/include/minix/param.h \
+  /usr/include/errno.h /usr/include/sys/errno.h const.h type.h proto.h \
+  glo.h /usr/include/minix/callnr.h /usr/include/signal.h \
+  /usr/include/sys/svrctl.h /usr/include/minix/ioctl.h \
+  /usr/include/sys/ioccom.h /usr/include/sys/reboot.h \
+  /usr/include/sys/resource.h /usr/include/sys/utsname.h \
+  /usr/include/minix/sysinfo.h /usr/include/minix/ds.h \
+  /usr/include/machine/archtypes.h /usr/include/machine/stackframe.h \
+  /usr/include/lib.h /usr/include/assert.h mproc.h \
+  /usr/src/minix/kernel/proc.h /usr/include/minix/portio.h \
+  /usr/src/minix/kernel/const.h /usr/include/minix/bitmap.h \
+  /usr/src/minix/kernel/config.h /usr/src/minix/kernel/debug.h \
+  /usr/include/minix/debug.h /usr/src/minix/kernel/priv.h \
+  /usr/include/minix/priv.h /usr/src/minix/kernel/type.h
+table.ln table.o: table.c pm.h /usr/include/minix/config.h \
+  /usr/include/minix/sys_config.h /usr/include/sys/types.h \
+  /usr/include/sys/featuretest.h /usr/include/machine/types.h \
+  /usr/include/sys/cdefs.h /usr/include/machine/cdefs.h \
+  /usr/include/sys/cdefs_elf.h /usr/include/machine/int_types.h \
+  /usr/include/machine/ansi.h /usr/include/sys/ansi.h \
+  /usr/include/machine/endian.h /usr/include/sys/endian.h \
+  /usr/include/machine/endian_machdep.h /usr/include/machine/bswap.h \
+  /usr/include/machine/byte_swap.h /usr/include/sys/bswap.h \
+  /usr/include/sys/fd_set.h /usr/include/minix/const.h \
+  /usr/include/machine/archconst.h /usr/include/sys/null.h \
+  /usr/include/minix/type.h /usr/include/machine/multiboot.h \
+  /usr/include/sys/sigtypes.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/stdint.h /usr/include/stdint.h \
+  /usr/include/machine/int_mwgwtypes.h /usr/include/machine/int_limits.h \
+  /usr/include/machine/int_const.h /usr/include/machine/wchar_limits.h \
+  /usr/include/machine/interrupt.h /usr/include/fcntl.h \
+  /usr/include/sys/stat.h /usr/include/sys/time.h \
+  /usr/include/sys/select.h /usr/include/time.h /usr/include/unistd.h \
+  /usr/include/sys/unistd.h /usr/include/string.h /usr/include/strings.h \
+  /usr/include/minix/syslib.h /usr/include/minix/ipc.h \
+  /usr/include/minix/ipcconst.h /usr/include/machine/ipcconst.h \
+  /usr/include/sys/signal.h /usr/include/sys/siginfo.h \
+  /usr/include/machine/signal.h /usr/include/machine/fpu.h \
+  /usr/include/machine/trap.h /usr/include/x86/trap.h \
+  /usr/include/sys/ucontext.h /usr/include/machine/mcontext.h \
+  /usr/include/minix/u64.h /usr/include/minix/devio.h \
+  /usr/include/minix/safecopies.h /usr/include/minix/vm.h \
+  /usr/include/minix/endpoint.h /usr/include/minix/com.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/limits.h /usr/include/limits.h \
+  /usr/include/machine/limits.h /usr/include/sys/syslimits.h \
+  /usr/include/minix/sef.h /usr/include/stdio.h \
+  /usr/include/minix/sysutil.h /usr/include/minix/timers.h \
+  /usr/include/minix/minlib.h /usr/include/sys/mount.h \
+  /usr/include/sys/param.h /usr/include/sys/inttypes.h \
+  /usr/include/machine/int_fmtio.h /usr/include/machine/param.h \
+  /usr/include/sys/uio.h /usr/include/sys/ucred.h \
+  /usr/include/sys/fstypes.h /usr/include/sys/queue.h \
+  /usr/include/sys/rwlock.h /usr/include/machine/rwlock.h \
+  /usr/include/x86/rwlock.h /usr/include/sys/statvfs.h \
+  /usr/include/sys/specificdata.h /usr/include/sys/mutex.h \
+  /usr/include/machine/mutex.h /usr/include/x86/mutex.h \
+  /usr/include/sys/condvar.h /usr/include/minix/param.h \
+  /usr/include/errno.h /usr/include/sys/errno.h const.h type.h proto.h \
+  glo.h /usr/src/minix/include/minix/callnr.h /usr/include/signal.h \
+  mproc.h
+utility.ln utility.o: utility.c pm.h /usr/include/minix/config.h \
+  /usr/include/minix/sys_config.h /usr/include/sys/types.h \
+  /usr/include/sys/featuretest.h /usr/include/machine/types.h \
+  /usr/include/sys/cdefs.h /usr/include/machine/cdefs.h \
+  /usr/include/sys/cdefs_elf.h /usr/include/machine/int_types.h \
+  /usr/include/machine/ansi.h /usr/include/sys/ansi.h \
+  /usr/include/machine/endian.h /usr/include/sys/endian.h \
+  /usr/include/machine/endian_machdep.h /usr/include/machine/bswap.h \
+  /usr/include/machine/byte_swap.h /usr/include/sys/bswap.h \
+  /usr/include/sys/fd_set.h /usr/include/minix/const.h \
+  /usr/include/machine/archconst.h /usr/include/sys/null.h \
+  /usr/include/minix/type.h /usr/include/machine/multiboot.h \
+  /usr/include/sys/sigtypes.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/stdint.h /usr/include/stdint.h \
+  /usr/include/machine/int_mwgwtypes.h /usr/include/machine/int_limits.h \
+  /usr/include/machine/int_const.h /usr/include/machine/wchar_limits.h \
+  /usr/include/machine/interrupt.h /usr/include/fcntl.h \
+  /usr/include/sys/stat.h /usr/include/sys/time.h \
+  /usr/include/sys/select.h /usr/include/time.h /usr/include/unistd.h \
+  /usr/include/sys/unistd.h /usr/include/string.h /usr/include/strings.h \
+  /usr/include/minix/syslib.h /usr/include/minix/ipc.h \
+  /usr/include/minix/ipcconst.h /usr/include/machine/ipcconst.h \
+  /usr/include/sys/signal.h /usr/include/sys/siginfo.h \
+  /usr/include/machine/signal.h /usr/include/machine/fpu.h \
+  /usr/include/machine/trap.h /usr/include/x86/trap.h \
+  /usr/include/sys/ucontext.h /usr/include/machine/mcontext.h \
+  /usr/include/minix/u64.h /usr/include/minix/devio.h \
+  /usr/include/minix/safecopies.h /usr/include/minix/vm.h \
+  /usr/include/minix/endpoint.h /usr/include/minix/com.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/limits.h /usr/include/limits.h \
+  /usr/include/machine/limits.h /usr/include/sys/syslimits.h \
+  /usr/include/minix/sef.h /usr/include/stdio.h \
+  /usr/include/minix/sysutil.h /usr/include/minix/timers.h \
+  /usr/include/minix/minlib.h /usr/include/sys/mount.h \
+  /usr/include/sys/param.h /usr/include/sys/inttypes.h \
+  /usr/include/machine/int_fmtio.h /usr/include/machine/param.h \
+  /usr/include/sys/uio.h /usr/include/sys/ucred.h \
+  /usr/include/sys/fstypes.h /usr/include/sys/queue.h \
+  /usr/include/sys/rwlock.h /usr/include/machine/rwlock.h \
+  /usr/include/x86/rwlock.h /usr/include/sys/statvfs.h \
+  /usr/include/sys/specificdata.h /usr/include/sys/mutex.h \
+  /usr/include/machine/mutex.h /usr/include/x86/mutex.h \
+  /usr/include/sys/condvar.h /usr/include/minix/param.h \
+  /usr/include/errno.h /usr/include/sys/errno.h const.h type.h proto.h \
+  glo.h /usr/include/sys/resource.h /usr/include/minix/callnr.h \
+  /usr/include/signal.h mproc.h /usr/include/machine/archtypes.h \
+  /usr/include/machine/stackframe.h /usr/src/minix/kernel/const.h \
+  /usr/include/minix/bitmap.h /usr/src/minix/kernel/config.h \
+  /usr/src/minix/kernel/debug.h /usr/include/minix/debug.h \
+  /usr/src/minix/kernel/type.h /usr/src/minix/kernel/proc.h \
+  /usr/include/minix/portio.h /usr/src/minix/kernel/priv.h \
+  /usr/include/minix/priv.h
diff -ruNp srclimpio/minix/servers/syncvar/Makefile proj/minix/servers/syncvar/Makefile
--- srclimpio/minix/servers/syncvar/Makefile	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/Makefile	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,28 @@
+.include <bsd.own.mk>
+
+# Makefile for Process Manager (SYNC)
+PROG=	syncvar
+SRCS=	main.c \
+	utility.c table.c \
+        allocate.c \
+        attribute.c \
+        condition.c \
+        event.c \
+        key.c \
+        misc.c \
+        mutex.c \
+	pthread_compat.c \
+        queue.c \
+        rwlock.c \
+	scheduler.c \
+	syncvar.c \
+	
+DPADD+=	${LIBSYS} ${LIBTIMERS}
+LDADD+=	-lsys -ltimers
+
+CPPFLAGS.main.c+=	-I${NETBSDSRCDIR}/minix
+CPPFLAGS.syncvar.c+=	-I${NETBSDSRCDIR}/minix
+CPPFLAGS.utility.c+=	-I${NETBSDSRCDIR}/minix
+
+.include <minix.service.mk>
+
diff -ruNp srclimpio/minix/servers/syncvar/allocate.c proj/minix/servers/syncvar/allocate.c
--- srclimpio/minix/servers/syncvar/allocate.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/allocate.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,528 @@
+#define ALLOCATE
+#include <errno.h>
+#include <minix/mthread.h>
+#include <string.h>
+
+#include <machine/param.h>
+#include <machine/vmparam.h>
+
+#include <sys/mman.h>
+
+#include <uvm/uvm_param.h>
+
+#include "global.h"
+#include "proto.h"
+
+static int mthread_increase_thread_pool(void);
+static void mthread_thread_init(mthread_thread_t thread, mthread_attr_t
+	*tattr, void *(*proc)(void *), void *arg);
+
+static void mthread_thread_stop(mthread_thread_t thread);
+static void mthread_trampoline(void);
+
+static int initialized = 0;
+#define MTHREAD_GUARDSIZE 	(1 << PGSHIFT) 	/* 1 page */
+
+static struct __mthread_attr default_attr = {	MTHREAD_STACK_MIN,
+						NULL,
+						MTHREAD_CREATE_JOINABLE,
+						NULL, NULL };
+
+/*===========================================================================*
+ *				mthread_equal				     *
+ *===========================================================================*/
+int mthread_equal(l, r)
+mthread_thread_t l;
+mthread_thread_t r;
+{
+/* Compare two thread ids */
+
+  return(l == r);
+}
+
+
+/*===========================================================================*
+ *				mthread_create				     *
+ *===========================================================================*/
+int mthread_create(threadid, tattr, proc, arg)
+mthread_thread_t *threadid;
+mthread_attr_t *tattr;
+void *(*proc)(void *);
+void *arg;
+{
+/* Register procedure proc for execution in a thread. */
+  mthread_thread_t thread;
+
+  if (proc == NULL)
+	return(EINVAL);
+
+  if (!mthread_queue_isempty(&free_threads)) {
+  	thread = mthread_queue_remove(&free_threads);
+  	mthread_thread_init(thread, tattr, proc, arg);
+ 	used_threads++;
+ 	if(threadid != NULL) 
+ 		*threadid = (mthread_thread_t) thread;
+#ifdef MDEBUG
+ 	printf("Inited thread %d\n", thread);
+#endif
+ 	return(0);
+  } else  {
+  	if (mthread_increase_thread_pool() == -1) 
+  		return(EAGAIN);
+
+  	return mthread_create(threadid, tattr, proc, arg);
+  }
+}
+
+
+/*===========================================================================*
+ *				mthread_detach				     *
+ *===========================================================================*/
+int mthread_detach(detach)
+mthread_thread_t detach;
+{
+/* Mark a thread as detached. Consequently, upon exit, resources allocated for
+ * this thread are automatically freed.
+ */
+  mthread_tcb_t *tcb;
+
+  if (!isokthreadid(detach)) 
+  	return(ESRCH);
+
+  tcb = mthread_find_tcb(detach);
+  if (tcb->m_state == MS_DEAD) {
+  	return(ESRCH);
+  } else if (tcb->m_attr.ma_detachstate != MTHREAD_CREATE_DETACHED) {
+  	if (tcb->m_state == MS_EXITING) 
+  		mthread_thread_stop(detach);
+  	else 
+		tcb->m_attr.ma_detachstate = MTHREAD_CREATE_DETACHED;
+  }
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_exit				     *
+ *===========================================================================*/
+void mthread_exit(value)
+void *value;
+{
+/* Make a thread stop running and store the result value. */
+  mthread_tcb_t *tcb;
+
+  tcb = mthread_find_tcb(current_thread);
+
+  if (tcb->m_state == MS_EXITING)	/* Already stopping, nothing to do. */
+  	return;
+
+  mthread_cleanup_values();
+
+  tcb->m_result = value;
+  tcb->m_state = MS_EXITING;
+
+  if (tcb->m_attr.ma_detachstate == MTHREAD_CREATE_DETACHED) {
+	mthread_thread_stop(current_thread);
+  } else {
+  	/* Joinable thread; notify possibly waiting thread */
+	if (mthread_cond_signal(&(tcb->m_exited)) != 0) 
+		mthread_panic("Couldn't signal exit");
+
+	/* The thread that's actually doing the join will eventually clean
+	 * up this thread (i.e., call mthread_thread_stop).
+	 */
+  }
+
+  mthread_schedule();
+}
+
+/*===========================================================================*
+ *			mthread_find_tcb				     *
+ *===========================================================================*/
+mthread_tcb_t * mthread_find_tcb(thread)
+mthread_thread_t thread;
+{
+  mthread_tcb_t *rt = NULL;
+
+  if (!isokthreadid(thread)) mthread_panic("Invalid thread id");
+
+  if (thread == MAIN_THREAD)
+  	rt = &mainthread;
+  else
+  	rt = threads[thread];
+
+  return(rt);
+}
+
+
+/*===========================================================================*
+ *			mthread_increase_thread_pool			     *
+ *===========================================================================*/
+static int mthread_increase_thread_pool(void)
+{
+/* Increase thread pool. No fancy algorithms, just double the size. */
+  mthread_tcb_t **new_tcb;
+  int new_no_threads, old_no_threads, i;
+
+  old_no_threads = no_threads;
+
+  if (old_no_threads == 0)
+  	new_no_threads = NO_THREADS;
+  else
+	new_no_threads = 2 * old_no_threads;
+
+
+  if (new_no_threads >= MAX_THREAD_POOL) {
+  	mthread_debug("Reached max number of threads");
+  	return(-1);
+  }
+
+  /* Allocate space to store pointers to thread control blocks */
+  if (old_no_threads == 0)	/* No data yet: allocate space */
+  	new_tcb = calloc(new_no_threads, sizeof(mthread_tcb_t *));
+  else				/* Preserve existing data: reallocate space */
+	new_tcb = realloc(threads, new_no_threads * sizeof(mthread_tcb_t *));
+
+  if (new_tcb == NULL) {
+  	mthread_debug("Can't increase thread pool");
+  	return(-1);
+  }
+
+  /* Allocate space for thread control blocks itself */
+  for (i = old_no_threads; i < new_no_threads; i++) {
+  	new_tcb[i] = malloc(sizeof(mthread_tcb_t));
+  	if (new_tcb[i] == NULL) {
+  		mthread_debug("Can't allocate space for tcb");
+  		return(-1);
+  	}
+  	memset(new_tcb[i], '\0', sizeof(mthread_tcb_t)); /* Clear entry */
+  }
+
+  /* We can breath again, let's tell the others about the good news */
+  threads = new_tcb; 
+  no_threads = new_no_threads;
+
+  /* Add newly available threads to free_threads */
+  for (i = old_no_threads; i < new_no_threads; i++) {
+	mthread_queue_add(&free_threads, i);
+	mthread_thread_reset(i);
+  }
+
+#ifdef MDEBUG
+  printf("Increased thread pool from %d to %d threads\n", old_no_threads,
+  	 new_no_threads);
+#endif
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_init				     *
+ *===========================================================================*/
+static void __attribute__((__constructor__, __used__)) mthread_init(void)
+{
+/* Initialize thread system; allocate thread structures and start creating
+ * threads.
+ */
+
+  if (initialized) return;
+
+  no_threads = 0;
+  used_threads = 0;
+  need_reset = 0;
+  running_main_thread = 1;	/* mthread_init can only be called from the
+				 * main thread. Calling it from a thread will
+				 * not enter this clause.
+				 */
+
+  if (mthread_getcontext(&(mainthread.m_context)) == -1)
+	mthread_panic("Couldn't save state for main thread");
+  current_thread = MAIN_THREAD;
+
+  mthread_init_valid_mutexes();
+  mthread_init_valid_conditions();
+  mthread_init_valid_attributes();
+  mthread_init_keys();
+  mthread_init_scheduler();
+
+  initialized = 1;
+}
+
+
+/*===========================================================================*
+ *				mthread_join				     *
+ *===========================================================================*/
+int mthread_join(join, value)
+mthread_thread_t join;
+void **value;
+{
+/* Wait for a thread to stop running and copy the result. */
+
+  mthread_tcb_t *tcb;
+
+  if (!isokthreadid(join))
+  	return(ESRCH);
+  else if (join == current_thread) 
+	return(EDEADLK);
+
+  tcb = mthread_find_tcb(join);
+  if (tcb->m_state == MS_DEAD) 
+  	return(ESRCH);
+  else if (tcb->m_attr.ma_detachstate == MTHREAD_CREATE_DETACHED) 
+	return(EINVAL);
+
+  /* When the thread hasn't exited yet, we have to wait for that to happen */
+  if (tcb->m_state != MS_EXITING) {
+  	mthread_cond_t *c;
+  	mthread_mutex_t *m;
+
+  	c = &(tcb->m_exited);
+  	m = &(tcb->m_exitm);
+
+  	if (mthread_mutex_init(m, NULL) != 0)
+		mthread_panic("Couldn't initialize mutex to join\n");
+
+	if (mthread_mutex_lock(m) != 0)
+		mthread_panic("Couldn't lock mutex to join\n");
+
+	if (mthread_cond_wait(c, m) != 0) 
+		mthread_panic("Couldn't wait for join condition\n");
+		
+	if (mthread_mutex_unlock(m) != 0)
+		mthread_panic("Couldn't unlock mutex to join\n");
+
+	if (mthread_mutex_destroy(m) != 0)
+		mthread_panic("Couldn't destroy mutex to join\n");
+  }
+
+  /* Thread has exited; copy results */
+  if(value != NULL)
+	*value = tcb->m_result;
+
+  /* Deallocate resources */
+  mthread_thread_stop(join);
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_once				     *
+ *===========================================================================*/
+int mthread_once(once, proc)
+mthread_once_t *once;
+void (*proc)(void);
+{
+/* Run procedure proc just once */
+
+  if (once == NULL || proc == NULL) 
+  	return(EINVAL);
+
+  if (*once != 1) proc();
+  *once = 1;
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_self				     *
+ *===========================================================================*/
+mthread_thread_t mthread_self(void)
+{
+/* Return the thread id of the thread calling this function. */
+
+  return(current_thread);
+}
+
+
+/*===========================================================================*
+ *				mthread_thread_init			     *
+ *===========================================================================*/
+static void mthread_thread_init(thread, tattr, proc, arg)
+mthread_thread_t thread;
+mthread_attr_t *tattr;
+void *(*proc)(void *);
+void *arg;
+{
+/* Initialize a thread so that it, when unsuspended, will run the given
+ * procedure with the given parameter. The thread is marked as runnable.
+ */
+
+#define THIS_CTX (&(threads[thread]->m_context))
+  mthread_tcb_t *tcb;
+  size_t stacksize;
+  char *stackaddr;
+
+  tcb = mthread_find_tcb(thread);
+  tcb->m_next = NULL;
+  tcb->m_state = MS_DEAD;
+  tcb->m_proc = proc;
+  tcb->m_arg = arg;
+  /* Threads use a copy of the provided attributes. This way, if another
+   * thread modifies the attributes (such as detach state), already running
+   * threads are not affected.
+   */
+  if (tattr != NULL)
+  	tcb->m_attr = *((struct __mthread_attr *) *tattr);
+  else {
+  	tcb->m_attr = default_attr;
+  }
+
+  if (mthread_cond_init(&(tcb->m_exited), NULL) != 0)
+  	mthread_panic("Could not initialize thread");
+
+  tcb->m_context.uc_link = NULL;
+
+  /* Construct this thread's context to run procedure proc. */
+  if (mthread_getcontext(&(tcb->m_context)) == -1)
+  	mthread_panic("Failed to initialize context state");
+
+  stacksize = tcb->m_attr.ma_stacksize;
+  stackaddr = tcb->m_attr.ma_stackaddr;
+
+  if (stacksize == (size_t) 0) {
+	/* User provided too small a stack size. Forget about that stack and
+	 * allocate a new one ourselves.
+	 */
+	stacksize = (size_t) MTHREAD_STACK_MIN;
+	tcb->m_attr.ma_stackaddr = stackaddr = NULL;
+  }
+
+  if (stackaddr == NULL) {
+	/* Allocate stack space */
+	size_t guarded_stacksize;
+	char *guard_start, *guard_end;
+
+	stacksize = round_page(stacksize + MTHREAD_GUARDSIZE);
+	stackaddr = mmap(NULL, stacksize,
+			       PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE,
+			       -1, 0);
+	if (stackaddr == MAP_FAILED)
+  		mthread_panic("Failed to allocate stack to thread");
+
+#if defined(__i386__) || defined(__arm__)
+	guard_start = stackaddr;
+	guard_end = stackaddr + MTHREAD_GUARDSIZE;
+	guarded_stacksize = stackaddr + stacksize - guard_end;
+
+	/* The stack will be used from (stackaddr+stacksize) to stackaddr. That
+	 * is, growing downwards. So the "top" of the stack may not grow into
+	 * stackaddr+MTHREAD_GUARDSIZE.
+	 *
+	 * +-------+ stackaddr + stacksize
+	 * |       |
+	 * |   |   |
+	 * |  \|/  |
+	 * |       |
+	 * +-------+ stackaddr + MTHREAD_GUARDSIZE
+	 * | GUARD |
+	 * +-------+ stackaddr
+	 */
+#else
+# error "Unsupported platform"
+#endif
+	stacksize = guarded_stacksize;
+	if (munmap(guard_start, MTHREAD_GUARDSIZE) != 0)
+		mthread_panic("unable to unmap stack space for guard");
+	tcb->m_context.uc_stack.ss_sp = guard_end;
+  } else
+  	tcb->m_context.uc_stack.ss_sp = stackaddr;
+
+  tcb->m_context.uc_stack.ss_size = stacksize;
+  makecontext(&(tcb->m_context), mthread_trampoline, 0);
+
+  mthread_unsuspend(thread); /* Make thread runnable */
+}
+
+
+/*===========================================================================*
+ *				mthread_thread_reset			     *
+ *===========================================================================*/
+void mthread_thread_reset(thread)
+mthread_thread_t thread;
+{
+/* Reset the thread to its default values. Free the allocated stack space. */
+
+  mthread_tcb_t *rt;
+  if (!isokthreadid(thread)) mthread_panic("Invalid thread id"); 
+
+  rt = mthread_find_tcb(thread);
+  rt->m_tid = thread;
+  rt->m_next = NULL;
+  rt->m_state = MS_DEAD;
+  rt->m_proc = NULL;
+  rt->m_arg = NULL;
+  rt->m_result = NULL;
+  rt->m_cond = NULL;
+  if (rt->m_attr.ma_stackaddr == NULL) { /* We allocated stack space */
+	if (rt->m_context.uc_stack.ss_sp) {
+		if (munmap(rt->m_context.uc_stack.ss_sp,
+				 rt->m_context.uc_stack.ss_size) != 0) {
+			mthread_panic("unable to unmap memory");
+		}
+	}
+	rt->m_context.uc_stack.ss_sp = NULL;
+  }
+  rt->m_context.uc_stack.ss_size = 0;
+  rt->m_context.uc_link = NULL;
+}
+
+
+/*===========================================================================*
+ *				mthread_thread_stop			     *
+ *===========================================================================*/
+static void mthread_thread_stop(thread)
+mthread_thread_t thread;
+{
+/* Stop thread from running. Deallocate resources. */
+  mthread_tcb_t *stop_thread;
+
+  if (!isokthreadid(thread)) mthread_panic("Invalid thread id"); 
+
+  stop_thread = mthread_find_tcb(thread);
+
+  if (stop_thread->m_state == MS_DEAD) {
+  	/* Already dead, nothing to do */
+  	return;
+  }
+
+  if (mthread_cond_destroy(&(stop_thread->m_exited)) != 0)
+  	mthread_panic("Could not destroy condition at thread deallocation\n");
+
+  /* Can't deallocate ourselves (i.e., we're a detached thread) */
+  if (thread == current_thread) {
+	stop_thread->m_state = MS_NEEDRESET;
+	need_reset++;
+  } else {
+	mthread_thread_reset(thread);
+	used_threads--;
+	mthread_queue_add(&free_threads, thread);
+  }
+}
+
+
+/*===========================================================================*
+ *				mthread_trampoline			     *
+ *===========================================================================*/
+static void mthread_trampoline(void)
+{
+/* Execute the /current_thread's/ procedure. Store its result. */
+
+  mthread_tcb_t *tcb;
+  void *r;
+
+  tcb = mthread_find_tcb(current_thread);
+
+  r = (tcb->m_proc)(tcb->m_arg);
+  mthread_exit(r); 
+}
+
+/* pthread compatibility layer. */
+__weak_alias(pthread_create, mthread_create)
+__weak_alias(pthread_detach, mthread_detach)
+__weak_alias(pthread_equal, mthread_equal)
+__weak_alias(pthread_exit, mthread_exit)
+__weak_alias(pthread_join, mthread_join)
+__weak_alias(pthread_once, mthread_once)
+__weak_alias(pthread_self, mthread_self)
+
Binary files srclimpio/minix/servers/syncvar/allocate.o and proj/minix/servers/syncvar/allocate.o differ
diff -ruNp srclimpio/minix/servers/syncvar/attribute.c proj/minix/servers/syncvar/attribute.c
--- srclimpio/minix/servers/syncvar/attribute.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/attribute.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,312 @@
+#include <minix/mthread.h>
+#include "global.h"
+#include "proto.h"
+
+static struct __mthread_attr *va_front, *va_rear;
+static void mthread_attr_add(mthread_attr_t *a);
+static void mthread_attr_remove(mthread_attr_t *a);
+static int mthread_attr_valid(mthread_attr_t *a);
+
+/*===========================================================================*
+ *			mthread_init_valid_attributes			     *
+ *===========================================================================*/
+void mthread_init_valid_attributes(void)
+{
+/* Initialize list of valid attributs */
+  va_front = va_rear = NULL;
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_add			     *
+ *===========================================================================*/
+static void mthread_attr_add(a) 
+mthread_attr_t *a;
+{
+/* Add attribute to list of valid, initialized attributes */
+
+  if (va_front == NULL) {	/* Empty list */
+  	va_front = *a;
+  	(*a)->ma_prev = NULL;
+  } else {
+  	va_rear->ma_next = *a;
+  	(*a)->ma_prev = va_rear;
+  }
+
+  (*a)->ma_next = NULL;
+  va_rear = *a;
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_destroy			     *
+ *===========================================================================*/
+int mthread_attr_destroy(attr)
+mthread_attr_t *attr;
+{
+/* Invalidate attribute and deallocate resources. */
+
+  if (attr == NULL)
+  	return(EINVAL);
+
+  if (!mthread_attr_valid(attr)) 
+  	return(EINVAL);
+
+  /* Valide attribute; invalidate it */
+  mthread_attr_remove(attr);	
+  free(*attr);
+  *attr = NULL;
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_init			     *
+ *===========================================================================*/
+int mthread_attr_init(attr)
+mthread_attr_t *attr;	/* Attribute */
+{
+/* Initialize the attribute to a known state. */
+  struct __mthread_attr *a;
+
+  if (attr == NULL) 
+  	return(EAGAIN);
+  else if (mthread_attr_valid(attr)) 
+  	return(EBUSY);
+
+  if ((a = malloc(sizeof(struct __mthread_attr))) == NULL)
+  	return(-1);
+
+  a->ma_detachstate = MTHREAD_CREATE_JOINABLE;
+  a->ma_stackaddr = NULL;
+  a->ma_stacksize = (size_t) 0;
+
+  *attr = (mthread_attr_t) a;
+  mthread_attr_add(attr); /* Validate attribute: attribute now in use */
+
+  return(0);
+}
+
+/*===========================================================================*
+ *				mthread_attr_getdetachstate			     *
+ *===========================================================================*/
+int mthread_attr_getdetachstate(attr, detachstate)
+mthread_attr_t *attr;
+int *detachstate;
+{
+/* Get detachstate of a thread attribute */
+  struct __mthread_attr *a;
+
+  if (attr == NULL) 
+  	return(EINVAL);
+
+  a = (struct __mthread_attr *) *attr;
+  if (!mthread_attr_valid(attr)) 
+  	return(EINVAL);
+
+  *detachstate = a->ma_detachstate;
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_setdetachstate			     *
+ *===========================================================================*/
+int mthread_attr_setdetachstate(attr, detachstate)
+mthread_attr_t *attr;
+int detachstate;
+{
+/* Set detachstate of a thread attribute */
+  struct __mthread_attr *a;
+
+  if (attr == NULL) 
+  	return(EINVAL);
+
+  a = (struct __mthread_attr *) *attr;
+  if (!mthread_attr_valid(attr)) 
+  	return(EINVAL);
+  else if(detachstate != MTHREAD_CREATE_JOINABLE &&
+  	  detachstate != MTHREAD_CREATE_DETACHED) 
+	return(EINVAL);
+
+  a->ma_detachstate = detachstate;
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_getstack			     *
+ *===========================================================================*/
+int mthread_attr_getstack(attr, stackaddr, stacksize)
+mthread_attr_t *attr;
+void **stackaddr;
+size_t *stacksize;
+{
+/* Get stack attribute */
+  struct __mthread_attr *a;
+
+  if (attr == NULL) 
+  	return(EINVAL);
+
+  a = (struct __mthread_attr *) *attr;
+  if (!mthread_attr_valid(attr))
+  	return(EINVAL);
+
+  *stackaddr = a->ma_stackaddr;
+  *stacksize = a->ma_stacksize;
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_getstacksize		     *
+ *===========================================================================*/
+int mthread_attr_getstacksize(attr, stacksize)
+mthread_attr_t *attr;
+size_t *stacksize;
+{
+/* Get stack size attribute */
+  struct __mthread_attr *a;
+
+  if (attr == NULL)
+  	return(EINVAL);
+
+  a = (struct __mthread_attr *) *attr;
+  if (!mthread_attr_valid(attr))
+  	return(EINVAL);
+
+  *stacksize = a->ma_stacksize;
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_setstack			     *
+ *===========================================================================*/
+int mthread_attr_setstack(attr, stackaddr, stacksize)
+mthread_attr_t *attr;
+void *stackaddr;
+size_t stacksize;
+{
+/* Set stack attribute */
+  struct __mthread_attr *a;
+
+  if (attr == NULL) 
+  	return(EINVAL);
+
+  a = (struct __mthread_attr *) *attr;
+  if (!mthread_attr_valid(attr) || stacksize < MTHREAD_STACK_MIN) 
+  	return(EINVAL);
+ 
+  /* We don't care about address alignment (POSIX standard). The ucontext
+   * system calls will make sure that the provided stack will be aligned (at
+   * the cost of some memory if needed).
+   */
+
+  a->ma_stackaddr = stackaddr;
+  a->ma_stacksize = stacksize;
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_setstacksize			     *
+ *===========================================================================*/
+int mthread_attr_setstacksize(attr, stacksize)
+mthread_attr_t *attr;
+size_t stacksize;
+{
+/* Set stack size attribute */
+  struct __mthread_attr *a;
+
+  if (attr == NULL)
+  	return(EINVAL);
+
+  a = (struct __mthread_attr *) *attr;
+  if (!mthread_attr_valid(attr) || stacksize < MTHREAD_STACK_MIN) 
+	return(EINVAL);
+
+  a->ma_stacksize = stacksize;
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_remove			     *
+ *===========================================================================*/
+static void mthread_attr_remove(a)
+mthread_attr_t *a;
+{
+/* Remove attribute from list of valid, initialized attributes */
+
+  if ((*a)->ma_prev == NULL)
+  	va_front = (*a)->ma_next;
+  else
+  	(*a)->ma_prev->ma_next = (*a)->ma_next;
+
+  if ((*a)->ma_next == NULL)
+  	va_rear = (*a)->ma_prev;
+  else
+  	(*a)->ma_next->ma_prev = (*a)->ma_prev;
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_valid			     *
+ *===========================================================================*/
+static int mthread_attr_valid(a)
+mthread_attr_t *a;
+{
+/* Check to see if attribute is on the list of valid attributes */
+  struct __mthread_attr *loopitem;
+
+  loopitem = va_front;
+
+  while (loopitem != NULL) {
+  	if (loopitem == *a) 
+  		return(1);
+
+  	loopitem = loopitem->ma_next;
+  }
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_attr_verify			     *
+ *===========================================================================*/
+#ifdef MDEBUG
+int mthread_attr_verify(void)
+{
+/* Return true when no attributes are in use */
+  struct __mthread_attr *loopitem;
+
+  loopitem = va_front;
+
+  while (loopitem != NULL) {
+  	loopitem = loopitem->ma_next;
+  	return(0);
+  }
+
+  return(1);
+}
+#endif
+
+/* pthread compatibility layer. */
+__weak_alias(pthread_attr_destroy, mthread_attr_destroy)
+__weak_alias(pthread_attr_getdetachstate, mthread_attr_getdetachstate)
+__weak_alias(pthread_attr_getstack, mthread_attr_getstack)
+__weak_alias(pthread_attr_getstacksize, mthread_attr_getstacksize)
+__weak_alias(pthread_attr_init, mthread_attr_init)
+__weak_alias(pthread_attr_setdetachstate, mthread_attr_setdetachstate)
+__weak_alias(pthread_attr_setstack, mthread_attr_setstack)
+__weak_alias(pthread_attr_setstacksize, mthread_attr_setstacksize)
+
Binary files srclimpio/minix/servers/syncvar/attribute.o and proj/minix/servers/syncvar/attribute.o differ
diff -ruNp srclimpio/minix/servers/syncvar/condition.c proj/minix/servers/syncvar/condition.c
--- srclimpio/minix/servers/syncvar/condition.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/condition.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,275 @@
+#include <minix/mthread.h>
+#include "global.h"
+#include "proto.h"
+
+#ifdef MTHREAD_STRICT
+static struct __mthread_cond *vc_front, *vc_rear;
+static void mthread_cond_add(mthread_cond_t *c);
+static void mthread_cond_remove(mthread_cond_t *c);
+static int mthread_cond_valid(mthread_cond_t *c);
+#else
+# define mthread_cond_add(c)		((*c)->mc_magic = MTHREAD_INIT_MAGIC)
+# define mthread_cond_remove(c)		((*c)->mc_magic = MTHREAD_NOT_INUSE)
+# define mthread_cond_valid(c)		((*c)->mc_magic == MTHREAD_INIT_MAGIC)
+#endif
+#define MAIN_COND mainthread.m_cond
+
+/*===========================================================================*
+ *				mthread_init_valid_conditions		     *
+ *===========================================================================*/
+void mthread_init_valid_conditions(void)
+{
+#ifdef MTHREAD_STRICT
+/* Initialize condition variable list */
+  vc_front = vc_rear = NULL;
+#endif
+}
+
+
+/*===========================================================================*
+ *				mthread_cond_add			     *
+ *===========================================================================*/
+#ifdef MTHREAD_STRICT
+static void mthread_cond_add(c) 
+mthread_cond_t *c;
+{
+/* Add condition to list of valid, initialized conditions */
+
+  if (vc_front == NULL) {	/* Empty list */
+  	vc_front = *c;
+  	(*c)->mc_prev = NULL;
+  } else {
+  	vc_rear->mc_next = *c;
+  	(*c)->mc_prev = vc_rear;
+  }
+
+  (*c)->mc_next = NULL;
+  vc_rear = *c;
+}
+#endif
+
+/*===========================================================================*
+ *				mthread_cond_broadcast			     *
+ *===========================================================================*/
+int mthread_cond_broadcast(cond)
+mthread_cond_t *cond;
+{
+/* Signal all threads waiting for condition 'cond'. */
+  mthread_thread_t t;
+  mthread_tcb_t *tcb;
+
+  if (cond == NULL) 
+  	return(EINVAL);
+  else if (!mthread_cond_valid(cond))
+  	return(EINVAL);
+
+  tcb = mthread_find_tcb(MAIN_THREAD);
+  if (tcb->m_state == MS_CONDITION && tcb->m_cond == *cond)
+  	mthread_unsuspend(MAIN_THREAD);
+
+  for (t = (mthread_thread_t) 0; t < no_threads; t++) {
+  	tcb = mthread_find_tcb(t);
+	if (tcb->m_state == MS_CONDITION && tcb->m_cond == *cond) 
+		mthread_unsuspend(t);
+  }
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_cond_destroy			     *
+ *===========================================================================*/
+int mthread_cond_destroy(cond)
+mthread_cond_t *cond;
+{
+/* Destroy a condition variable. Make sure it's not in use */
+  mthread_thread_t t;
+  mthread_tcb_t *tcb;
+
+  if (cond == NULL)
+  	return(EINVAL);
+  else if (!mthread_cond_valid(cond))
+  	return(EINVAL);
+
+  /* Is another thread currently using this condition variable? */
+  tcb = mthread_find_tcb(MAIN_THREAD);
+  if (tcb->m_state == MS_CONDITION && tcb->m_cond == *cond)
+  	return(EBUSY);
+
+  for (t = (mthread_thread_t) 0; t < no_threads; t++) {
+  	tcb = mthread_find_tcb(t);
+	if (tcb->m_state == MS_CONDITION && tcb->m_cond == *cond)
+		return(EBUSY);
+  }
+
+  /* Not in use; invalidate it. */
+  mthread_cond_remove(cond);
+  free(*cond);
+  *cond = NULL;
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_cond_init			     *
+ *===========================================================================*/
+int mthread_cond_init(cond, cattr)
+mthread_cond_t *cond;
+mthread_condattr_t *cattr;
+{
+/* Initialize condition variable to a known state. cattr is ignored */
+  struct __mthread_cond *c;
+
+  if (cond == NULL) 
+	return(EINVAL);
+  else if (cattr != NULL) 
+  	return(ENOSYS);
+
+#ifdef MTHREAD_STRICT
+  else if (mthread_cond_valid(cond)) 
+	/* Already initialized */
+  	return(EBUSY);
+#endif
+  else if ((c = malloc(sizeof(struct __mthread_cond))) == NULL) 
+  	return(ENOMEM);
+
+  c->mc_mutex = NULL;
+  *cond = (mthread_cond_t) c;
+  mthread_cond_add(cond);
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_cond_remove			     *
+ *===========================================================================*/
+#ifdef MTHREAD_STRICT
+static void mthread_cond_remove(c)
+mthread_cond_t *c;
+{
+/* Remove condition from list of valid, initialized conditions */
+
+  if ((*c)->mc_prev == NULL)
+  	vc_front = (*c)->mc_next;
+  else
+  	(*c)->mc_prev->mc_next = (*c)->mc_next;
+
+  if ((*c)->mc_next == NULL)
+  	vc_rear = (*c)->mc_prev;
+  else
+  	(*c)->mc_next->mc_prev = (*c)->mc_prev;
+
+}
+#endif
+
+/*===========================================================================*
+ *				mthread_cond_signal			     *
+ *===========================================================================*/
+int mthread_cond_signal(cond)
+mthread_cond_t *cond;
+{
+/* Signal a thread that condition 'cond' was met. Just a single thread. */
+  mthread_thread_t t;
+  mthread_tcb_t *tcb;
+
+  if (cond == NULL)
+	return(EINVAL);
+  else if (!mthread_cond_valid(cond))
+	return(EINVAL);
+
+  tcb = mthread_find_tcb(MAIN_THREAD);
+  if (tcb->m_state == MS_CONDITION && tcb->m_cond == *cond)
+  	mthread_unsuspend(MAIN_THREAD);
+
+  for (t = (mthread_thread_t) 0; t < no_threads; t++) {
+  	tcb = mthread_find_tcb(t);
+	if (tcb->m_state == MS_CONDITION && tcb->m_cond == *cond){
+		mthread_unsuspend(t);
+		break;
+	}
+  }
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_cond_valid			     *
+ *===========================================================================*/
+#ifdef MTHREAD_STRICT
+static int mthread_cond_valid(c)
+mthread_cond_t *c;
+{
+/* Check to see if cond is on the list of valid conditions */
+  struct __mthread_cond *loopitem;
+
+  loopitem = vc_front;
+
+  while (loopitem != NULL) {
+  	if (loopitem == *c)
+  		return(1);
+
+  	loopitem = loopitem->mc_next;
+  }
+
+  return(0);
+}
+#endif
+
+/*===========================================================================*
+ *				mthread_cond_verify			     *
+ *===========================================================================*/
+#ifdef MDEBUG
+int mthread_cond_verify(void)
+{
+/* Return true in case no condition variables are in use. */
+
+  return(vc_front == NULL);
+}
+#endif
+
+
+/*===========================================================================*
+ *				mthread_cond_wait			     *
+ *===========================================================================*/
+int mthread_cond_wait(cond, mutex)
+mthread_cond_t *cond;
+mthread_mutex_t *mutex;
+{
+/* Wait for a condition to be signaled */
+  mthread_tcb_t *tcb;
+  struct __mthread_cond *c;
+  struct __mthread_mutex *m;
+
+  if (cond == NULL || mutex == NULL)
+	return(EINVAL);
+  
+  c = (struct __mthread_cond *) *cond;
+  m = (struct __mthread_mutex *) *mutex;
+
+  if (!mthread_cond_valid(cond) || !mthread_mutex_valid(mutex)) 
+	return(EINVAL);
+
+  c->mc_mutex = m;	/* Remember we're using this mutex in a cond_wait */
+  if (mthread_mutex_unlock(mutex) != 0) /* Fails when we're not the owner */
+  	return(-1);
+
+  tcb = mthread_find_tcb(current_thread);
+  tcb->m_cond = c; /* Register condition variable. */
+  mthread_suspend(MS_CONDITION);
+
+  /* When execution returns here, the condition was met. Lock mutex again. */
+  c->mc_mutex = NULL;				/* Forget about this mutex */
+  tcb->m_cond = NULL;				/* ... and condition var */
+  if (mthread_mutex_lock(mutex) != 0)
+  	return(-1);
+
+  return(0);
+}
+
+/* pthread compatibility layer. */
+__weak_alias(pthread_cond_init, mthread_cond_init)
+
Binary files srclimpio/minix/servers/syncvar/condition.o and proj/minix/servers/syncvar/condition.o differ
diff -ruNp srclimpio/minix/servers/syncvar/const.h proj/minix/servers/syncvar/const.h
--- srclimpio/minix/servers/syncvar/const.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/const.h	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,19 @@
+/* Constants used by the Process Manager. */
+
+#define NR_PIDS	       30000	/* process ids range from 0 to NR_PIDS-1.
+				 * (magic constant: some old applications use
+				 * a 'short' instead of pid_t.)
+				 */
+
+#define NO_PID	           0	/* pid value indicating no process */
+#define INIT_PID	   1	/* INIT's process id number */
+
+#define NO_TRACER	   0	/* process is not being traced */
+
+#define MAX_CLOCK_T	((unsigned long) 1 << ((sizeof(clock_t) * 8) - 1))
+#define MAX_SECS	( (clock_t) (MAX_CLOCK_T/system_hz) )
+				/* max.secs for setitimer() ((2^31-1)/HZ) */
+#define NR_ITIMERS	   3	/* number of supported interval timers */
+
+#define SEND_PRIORITY      1	/* send current priority queue to scheduler */
+#define SEND_TIME_SLICE    2    /* send current time slice to scheduler */
diff -ruNp srclimpio/minix/servers/syncvar/event.c proj/minix/servers/syncvar/event.c
--- srclimpio/minix/servers/syncvar/event.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/event.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,134 @@
+#include <minix/mthread.h>
+#include "global.h"
+
+/*===========================================================================*
+ *				mthread_event_init			     *
+ *===========================================================================*/
+int mthread_event_init(event)
+mthread_event_t *event; /* The event to be initialized */
+{
+/* Initialize an event object.
+ */
+  int r;
+
+  if (!event)
+	return EINVAL;
+
+  r = mthread_mutex_init(&event->mutex, NULL);
+  if (r != 0)
+	return r;
+
+  r = mthread_cond_init(&event->cond, NULL);
+  if (r != 0) 
+	mthread_mutex_destroy(&event->mutex);
+
+  return r;
+}
+
+
+/*===========================================================================*
+ *				mthread_event_destroy			     *
+ *===========================================================================*/
+int mthread_event_destroy(event)
+mthread_event_t *event; /* The event to be destroyed */
+{
+/* Destroy an event object.
+ */
+  int r;
+
+  if (!event)
+	return EINVAL;
+
+  r = mthread_cond_destroy(&event->cond);
+  if (r != 0)
+	return r;
+
+  return mthread_mutex_destroy(&event->mutex);
+}
+
+/*===========================================================================*
+ *				mthread_event_wait			     *
+ *===========================================================================*/
+int mthread_event_wait(event)
+mthread_event_t *event; /* The event to be waited on */
+{
+/* Wait for an event, blocking the current thread in the process.
+ */
+  int r;
+
+  if (!event)
+	return EINVAL;
+
+  r = mthread_mutex_lock(&event->mutex);
+  if (r != 0)
+	return r;
+
+  r = mthread_cond_wait(&event->cond, &event->mutex);
+  if (r != 0) {
+	mthread_mutex_unlock(&event->mutex);
+	return r;
+  }
+
+  return mthread_mutex_unlock(&event->mutex);
+}
+
+/*===========================================================================*
+ *				mthread_event_fire			     *
+ *===========================================================================*/
+int mthread_event_fire(event)
+mthread_event_t *event; /* The event to be fired */
+{
+/* Fire an event, waking up any thread blocked on it.
+*/
+  int r;
+
+  if (!event)
+	return EINVAL;
+
+  r = mthread_mutex_lock(&event->mutex);
+  if (r != 0)
+	return r;
+
+  r = mthread_cond_signal(&event->cond);
+  if (r != 0) {
+	mthread_mutex_unlock(&event->mutex);
+	return r;
+  }
+
+  return mthread_mutex_unlock(&event->mutex);
+}
+
+
+/*===========================================================================*
+ *				mthread_event_fire_all			     *
+ *===========================================================================*/
+int mthread_event_fire_all(event)
+mthread_event_t *event; /* The event to be fired */
+{
+/* Fire an event, waking up any thread blocked on it.
+*/
+  int r;
+
+  if (!event)
+	return EINVAL;
+
+  r = mthread_mutex_lock(&event->mutex);
+  if (r != 0)
+	return r;
+
+  r = mthread_cond_broadcast(&event->cond);
+  if (r != 0) {
+	mthread_mutex_unlock(&event->mutex);
+	return r;
+  }
+
+  return mthread_mutex_unlock(&event->mutex);
+}
+
+/* pthread compatibility layer. */
+__weak_alias(pthread_event_destroy, mthread_event_destroy)
+__weak_alias(pthread_event_init, mthread_event_init)
+__weak_alias(pthread_event_wait, mthread_event_wait)
+__weak_alias(pthread_event_fire, mthread_event_fire)
+__weak_alias(pthread_event_fire_all, mthread_event_fire_all)
+
Binary files srclimpio/minix/servers/syncvar/event.o and proj/minix/servers/syncvar/event.o differ
diff -ruNp srclimpio/minix/servers/syncvar/glo.h proj/minix/servers/syncvar/glo.h
--- srclimpio/minix/servers/syncvar/glo.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/glo.h	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,31 @@
+/* EXTERN should be extern except in table.c */
+#ifdef _TABLE
+#undef EXTERN
+#define EXTERN
+#endif
+
+/* Global variables. */
+EXTERN struct mproc *mp;	/* ptr to 'mproc' slot of current process */
+EXTERN int procs_in_use;	/* how many processes are marked as IN_USE */
+EXTERN char monitor_params[MULTIBOOT_PARAM_BUF_SIZE];
+
+/* Misc.c */
+extern struct utsname uts_val;	/* uname info */
+
+/* The parameters of the call are kept here. */
+EXTERN message m_in;		/* the incoming message itself is kept here. */
+EXTERN int who_p, who_e;	/* caller's proc number, endpoint */
+EXTERN int call_nr;		/* system call number */
+
+extern int (* const call_vec[])(void);
+EXTERN sigset_t core_sset;	/* which signals cause core images */
+EXTERN sigset_t ign_sset;	/* which signals are by default ignored */
+EXTERN sigset_t noign_sset;	/* which signals cannot be ignored */
+
+EXTERN u32_t system_hz;		/* System clock frequency. */
+EXTERN int abort_flag;
+
+EXTERN struct machine machine;		/* machine info */
+#ifdef CONFIG_SMP
+EXTERN int cpu_proc[CONFIG_MAX_CPUS];
+#endif
diff -ruNp srclimpio/minix/servers/syncvar/global.h proj/minix/servers/syncvar/global.h
--- srclimpio/minix/servers/syncvar/global.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/global.h	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,51 @@
+/* EXTERN should be extern, except for the allocate file */
+#ifdef ALLOCATE
+#undef EXTERN
+#define EXTERN
+#endif
+
+#include <assert.h>
+#include <sys/types.h>
+#include <sys/signal.h>
+
+#define MTHREAD_RND_SCHED	0	/* Enable/disable random scheduling */
+#define NO_THREADS 4 
+#define MAX_THREAD_POOL 1024
+#define STACKSZ 4096
+#define MAIN_THREAD (-1)
+#define NO_THREAD (-2)
+#define isokthreadid(i)	(i == MAIN_THREAD || (i >= 0 && i < no_threads))
+#define MTHREAD_INIT_MAGIC 0xca11ab1e
+#define MTHREAD_NOT_INUSE  0xdefec7
+
+typedef enum {
+  MS_CONDITION, MS_DEAD, MS_EXITING, MS_MUTEX, MS_RUNNABLE, MS_NEEDRESET
+} mthread_state_t;
+
+struct __mthread_tcb {
+  mthread_thread_t m_tid;		/* My own ID */
+  mthread_state_t m_state;		/* Thread state */
+  struct __mthread_attr m_attr;		/* Thread attributes */
+  struct __mthread_cond *m_cond;	/* Condition variable that this thread
+  					 * might be blocking on */
+  void *(*m_proc)(void *);		/* Procedure to run */
+  void *m_arg;				/* Argument passed to procedure */
+  void *m_result;			/* Result after procedure returns */
+  mthread_cond_t m_exited;		/* Condition variable signaling this
+  					 * thread has ended */
+  mthread_mutex_t m_exitm;		/* Mutex to accompany exit condition */
+  ucontext_t m_context;			/* Thread machine context */
+  struct __mthread_tcb *m_next;		/* Next thread in linked list */
+};
+typedef struct __mthread_tcb mthread_tcb_t;
+
+EXTERN mthread_thread_t current_thread;
+EXTERN mthread_queue_t free_threads;
+EXTERN mthread_queue_t run_queue;		/* FIFO of runnable threads */
+EXTERN mthread_tcb_t **threads;
+EXTERN mthread_tcb_t mainthread;
+EXTERN int no_threads;
+EXTERN int used_threads;
+EXTERN int need_reset;
+EXTERN int running_main_thread;
+
diff -ruNp srclimpio/minix/servers/syncvar/key.c proj/minix/servers/syncvar/key.c
--- srclimpio/minix/servers/syncvar/key.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/key.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,190 @@
+#include <minix/mthread.h>
+#include <string.h>
+#include "global.h"
+#include "proto.h"
+
+static int keys_used = 0;
+static struct {
+  int used;
+  int nvalues;
+  void *mvalue;
+  void **value;
+  void (*destr)(void *);
+} keys[MTHREAD_KEYS_MAX];
+
+/*===========================================================================*
+ *				mthread_init_keys			     *
+ *===========================================================================*/
+void mthread_init_keys(void)
+{
+/* Initialize the table of key entries.
+ */
+  mthread_key_t k;
+
+  for (k = 0; k < MTHREAD_KEYS_MAX; k++)
+	keys[k].used = FALSE;
+}
+
+/*===========================================================================*
+ *				mthread_key_create			     *
+ *===========================================================================*/
+int mthread_key_create(mthread_key_t *key, void (*destructor)(void *))
+{
+/* Allocate a key.
+ */
+  mthread_key_t k;
+
+  keys_used = 1;
+
+  /* We do not yet allocate storage space for the values here, because we can
+   * not estimate how many threads will be created in the common case that the
+   * application creates keys before spawning threads.
+   */
+  for (k = 0; k < MTHREAD_KEYS_MAX; k++) {
+	if (!keys[k].used) {
+		keys[k].used = TRUE;
+		keys[k].nvalues = 0;
+		keys[k].mvalue = NULL;
+		keys[k].value = NULL;
+		keys[k].destr = destructor;
+		*key = k;
+
+		return(0);
+	}
+  }
+
+  return(EAGAIN);
+}
+
+/*===========================================================================*
+ *				mthread_key_delete			     *
+ *===========================================================================*/
+int mthread_key_delete(mthread_key_t key)
+{
+/* Free up a key, as well as any associated storage space.
+ */
+
+  if (key < 0 || key >= MTHREAD_KEYS_MAX || !keys[key].used)
+	return(EINVAL);
+
+  free(keys[key].value);
+
+  keys[key].used = FALSE;
+
+  return(0);
+}
+
+/*===========================================================================*
+ *				mthread_getspecific			     *
+ *===========================================================================*/
+void *mthread_getspecific(mthread_key_t key)
+{
+/* Get this thread's local value for the given key. The default is NULL.
+ */
+
+  if (key < 0 || key >= MTHREAD_KEYS_MAX || !keys[key].used)
+	return(NULL);
+
+  if (current_thread == MAIN_THREAD)
+	return keys[key].mvalue;
+
+  if (current_thread < keys[key].nvalues)
+	return(keys[key].value[current_thread]);
+
+  return(NULL);
+}
+
+/*===========================================================================*
+ *				mthread_setspecific			     *
+ *===========================================================================*/
+int mthread_setspecific(mthread_key_t key, void *value)
+{
+/* Set this thread's value for the given key. Allocate more resources as
+ * necessary.
+ */
+  void **p;
+
+  if (key < 0 || key >= MTHREAD_KEYS_MAX || !keys[key].used)
+	return(EINVAL);
+
+  if (current_thread == MAIN_THREAD) {
+	keys[key].mvalue = value;
+
+	return(0);
+  }
+
+  if (current_thread >= keys[key].nvalues) {
+	if (current_thread >= no_threads)
+		mthread_panic("Library state corrupt");
+
+	if ((p = (void **) realloc(keys[key].value,
+			sizeof(void*) * no_threads)) == NULL)
+		return(ENOMEM);
+
+	memset(&p[keys[key].nvalues], 0,
+		sizeof(void*) * (no_threads - keys[key].nvalues));
+
+	keys[key].nvalues = no_threads;
+	keys[key].value = p;
+  }
+
+  keys[key].value[current_thread] = value;
+
+  return(0);
+}
+
+/*===========================================================================*
+ *				mthread_cleanup_values			     *
+ *===========================================================================*/
+void mthread_cleanup_values(void)
+{
+/* Clean up all the values associated with an exiting thread, calling keys'
+ * destruction procedures as appropriate.
+ */
+  mthread_key_t k;
+  void *value;
+  int found;
+
+  if (!keys_used) return;	/* Only clean up if we used any keys at all */
+
+  /* Any of the destructors may set a new value on any key, so we may have to
+   * loop over the table of keys multiple times. This implementation has no
+   * protection against infinite loops in this case.
+   */
+  do {
+	found = FALSE;
+
+	for (k = 0; k < MTHREAD_KEYS_MAX; k++) {
+		if (!keys[k].used) continue;
+		if (keys[k].destr == NULL) continue;
+
+		if (current_thread == MAIN_THREAD) {
+			value = keys[k].mvalue;
+
+			keys[k].mvalue = NULL;
+		} else {
+			if (current_thread >= keys[k].nvalues) continue;
+
+			value = keys[k].value[current_thread];
+
+			keys[k].value[current_thread] = NULL;
+		}
+
+		if (value != NULL) {
+			/* Note: calling mthread_exit() from a destructor
+			 * causes undefined behavior.
+			 */
+			keys[k].destr(value);
+
+			found = TRUE;
+		}
+	}
+  } while (found);
+}
+
+/* pthread compatibility layer. */
+__weak_alias(pthread_key_create, mthread_key_create)
+__weak_alias(pthread_key_delete, mthread_key_delete)
+__weak_alias(pthread_getspecific, mthread_getspecific)
+__weak_alias(pthread_setspecific, mthread_setspecific)
+
Binary files srclimpio/minix/servers/syncvar/key.o and proj/minix/servers/syncvar/key.o differ
diff -ruNp srclimpio/minix/servers/syncvar/main.c proj/minix/servers/syncvar/main.c
--- srclimpio/minix/servers/syncvar/main.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/main.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,145 @@
+/* This file contains the main program of the process manager and some related
+ * procedures.  When MINIX starts up, the kernel runs for a little while,
+ * initializing itself and its tasks, and then it runs PM and VFS.  Both PM
+ * and VFS initialize themselves as far as they can. PM asks the kernel for
+ * all free memory and starts serving requests.
+ *
+ * The entry points into this file are:
+ *   main:  starts PM running
+ *   reply: send a reply to a process making a PM system call
+ */
+
+#include "pm.h"
+#include <minix/callnr.h>
+#include <minix/com.h>
+#include <minix/ds.h>
+#include <minix/type.h>
+#include <minix/endpoint.h>
+#include <minix/minlib.h>
+#include <minix/type.h>
+#include <minix/vm.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <sys/wait.h>
+#include <machine/archtypes.h>
+#include <env.h>
+#include <assert.h>
+#include "mproc.h"
+
+#include "kernel/const.h"
+#include "kernel/config.h"
+#include "kernel/proc.h"
+
+#if ENABLE_SYSCALL_STATS
+EXTERN unsigned long calls_stats[NR_SYNC_CALLS];
+#endif
+
+static int get_nice_value(int queue);
+static void handle_vfs_reply(void);
+
+/* SEF functions and variables. */
+static void sef_local_startup(void);
+static int sef_cb_init_fresh(int type, sef_init_info_t *info);
+
+/*===========================================================================*
+ *        main               *
+ *===========================================================================*/
+int main()
+{
+/* Main routine of the process manager. */
+  unsigned int call_index;
+  int ipc_status, result;
+
+  /* SEF local startup. */
+    sef_startup();
+
+  /* This is PM's main loop-  get work and do it, forever and forever. */
+  while (TRUE) {
+  /* Wait for the next message. */
+  if (sef_receive_status(ANY, &m_in, &ipc_status) != OK)
+    panic("PM sef_receive_status error");
+
+  /* Check for system notifications first. Special cases. */
+  if (is_ipc_notify(ipc_status)) {
+    if (_ENDPOINT_P(m_in.m_source) == CLOCK)
+      expire_timers(m_in.m_notify.timestamp);
+
+    /* done, continue */
+    continue;
+  }
+
+  /* Extract useful information from the message. */
+  who_e = m_in.m_source;  /* who sent the message */
+
+  mp = &mproc[who_p]; /* process slot of caller */
+  call_nr = m_in.m_type;  /* system call number */
+
+  /* Drop delayed calls from exiting processes. */
+  if (mp->mp_flags & EXITING)
+    continue;
+
+  else if (IS_SYNC_CALL(call_nr)) {
+    /* If the system call number is valid, perform the call. */
+    call_index = (unsigned int) (call_nr - SYNC_BASE);
+
+    if (call_index < NR_SYNC_CALLS && call_vec[call_index] != NULL) {
+#if ENABLE_SYSCALL_STATS
+      calls_stats[call_index]++;
+#endif
+
+      result = (*call_vec[call_index])();
+    } else
+      result = ENOSYS;
+  } else
+    result = ENOSYS;
+
+  /* Send reply. */
+  if (result != SUSPEND) reply(who_p, result);
+  }
+  return(OK);
+}
+
+/*===========================================================================*
+ *        reply              *
+ *===========================================================================*/
+void reply(proc_nr, result)
+int proc_nr;      /* process to reply to */
+int result;     /* result of call (usually OK or error #) */
+{
+/* Send a reply to a user process.  System calls may occasionally fill in other
+ * fields, this is only for the main return value and for sending the reply.
+ */
+  struct mproc *rmp;
+  int r;
+
+  if(proc_nr < 0 || proc_nr >= NR_PROCS)
+      panic("reply arg out of range: %d", proc_nr);
+
+  rmp = &mproc[proc_nr];
+  rmp->mp_reply.m_type = result;
+
+  if ((r = ipc_sendnb(rmp->mp_endpoint, &rmp->mp_reply)) != OK)
+  printf("PM can't reply to %d (%s): %d\n", rmp->mp_endpoint,
+    rmp->mp_name, r);
+}
+
+/*===========================================================================*
+ *        get_nice_value             *
+ *===========================================================================*/
+static int get_nice_value(queue)
+int queue;        /* store mem chunks here */
+{
+/* Processes in the boot image have a priority assigned. The PM doesn't know
+ * about priorities, but uses 'nice' values instead. The priority is between 
+ * MIN_USER_Q and MAX_USER_Q. We have to scale between PRIO_MIN and PRIO_MAX.
+ */ 
+  int nice_val = (queue - USER_Q) * (PRIO_MAX-PRIO_MIN+1) / 
+      (MIN_USER_Q-MAX_USER_Q+1);
+  if (nice_val > PRIO_MAX) nice_val = PRIO_MAX; /* shouldn't happen */
+  if (nice_val < PRIO_MIN) nice_val = PRIO_MIN; /* shouldn't happen */
+  return nice_val;
+}
+
diff -ruNp srclimpio/minix/servers/syncvar/main.d proj/minix/servers/syncvar/main.d
--- srclimpio/minix/servers/syncvar/main.d	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/main.d	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,55 @@
+main.o: main.c pm.h /usr/include/minix/config.h \
+  /usr/include/minix/sys_config.h /usr/include/sys/types.h \
+  /usr/include/sys/featuretest.h /usr/include/machine/types.h \
+  /usr/include/sys/cdefs.h /usr/include/machine/cdefs.h \
+  /usr/include/sys/cdefs_elf.h /usr/include/machine/int_types.h \
+  /usr/include/machine/ansi.h /usr/include/sys/ansi.h \
+  /usr/include/machine/endian.h /usr/include/sys/endian.h \
+  /usr/include/machine/endian_machdep.h /usr/include/machine/bswap.h \
+  /usr/include/machine/byte_swap.h /usr/include/sys/bswap.h \
+  /usr/include/sys/fd_set.h /usr/include/minix/const.h \
+  /usr/include/machine/archconst.h /usr/include/sys/null.h \
+  /usr/include/minix/type.h /usr/include/machine/multiboot.h \
+  /usr/include/sys/sigtypes.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/stdint.h /usr/include/stdint.h \
+  /usr/include/machine/int_mwgwtypes.h /usr/include/machine/int_limits.h \
+  /usr/include/machine/int_const.h /usr/include/machine/wchar_limits.h \
+  /usr/include/machine/interrupt.h /usr/include/fcntl.h \
+  /usr/include/sys/stat.h /usr/include/sys/time.h \
+  /usr/include/sys/select.h /usr/include/time.h /usr/include/unistd.h \
+  /usr/include/sys/unistd.h /usr/include/string.h /usr/include/strings.h \
+  /usr/include/minix/syslib.h /usr/include/minix/ipc.h \
+  /usr/include/minix/ipcconst.h /usr/include/machine/ipcconst.h \
+  /usr/include/sys/signal.h /usr/include/sys/siginfo.h \
+  /usr/include/machine/signal.h /usr/include/machine/fpu.h \
+  /usr/include/machine/trap.h /usr/include/x86/trap.h \
+  /usr/include/sys/ucontext.h /usr/include/machine/mcontext.h \
+  /usr/include/minix/u64.h /usr/include/minix/devio.h \
+  /usr/include/minix/safecopies.h /usr/include/minix/vm.h \
+  /usr/include/minix/endpoint.h /usr/include/minix/com.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/limits.h /usr/include/limits.h \
+  /usr/include/machine/limits.h /usr/include/sys/syslimits.h \
+  /usr/include/minix/sef.h /usr/include/stdio.h \
+  /usr/include/minix/sysutil.h /usr/include/minix/timers.h \
+  /usr/include/minix/minlib.h /usr/include/sys/mount.h \
+  /usr/include/sys/param.h /usr/include/sys/inttypes.h \
+  /usr/include/machine/int_fmtio.h /usr/include/machine/param.h \
+  /usr/include/sys/uio.h /usr/include/sys/ucred.h \
+  /usr/include/sys/fstypes.h /usr/include/sys/queue.h \
+  /usr/include/sys/rwlock.h /usr/include/machine/rwlock.h \
+  /usr/include/x86/rwlock.h /usr/include/sys/statvfs.h \
+  /usr/include/sys/specificdata.h /usr/include/sys/mutex.h \
+  /usr/include/machine/mutex.h /usr/include/x86/mutex.h \
+  /usr/include/sys/condvar.h /usr/include/minix/param.h \
+  /usr/include/errno.h /usr/include/sys/errno.h const.h type.h proto.h \
+  glo.h /usr/include/minix/callnr.h /usr/include/minix/ds.h \
+  /usr/include/signal.h /usr/include/stdlib.h \
+  /usr/include/sys/resource.h /usr/include/sys/utsname.h \
+  /usr/include/sys/wait.h /usr/include/machine/archtypes.h \
+  /usr/include/machine/stackframe.h /usr/include/env.h \
+  /usr/include/assert.h mproc.h /usr/src/minix/kernel/const.h \
+  /usr/include/minix/bitmap.h /usr/src/minix/kernel/config.h \
+  /usr/src/minix/kernel/debug.h /usr/include/minix/debug.h \
+  /usr/src/minix/kernel/proc.h /usr/include/minix/portio.h \
+  /usr/src/minix/kernel/priv.h /usr/include/minix/priv.h \
+  /usr/src/minix/kernel/type.h
Binary files srclimpio/minix/servers/syncvar/main.o and proj/minix/servers/syncvar/main.o differ
diff -ruNp srclimpio/minix/servers/syncvar/misc.c proj/minix/servers/syncvar/misc.c
--- srclimpio/minix/servers/syncvar/misc.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/misc.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,163 @@
+#include <minix/mthread.h>
+#include <stdio.h>
+#include "global.h"
+#include "proto.h"
+
+/*===========================================================================*
+ *				mthread_debug_f				     *
+ *===========================================================================*/
+#ifdef MDEBUG
+void mthread_debug_f(const char *file, int line, const char *msg)
+{
+  /* Print debug message */
+  printf("MTH (%s:%d): %s\n", file, line, msg);
+}
+#endif
+
+/*===========================================================================*
+ *				mthread_panic_f				     *
+ *===========================================================================*/
+#ifdef MDEBUG
+void mthread_panic_f(const char *file, int line, const char *msg)
+{
+  /* Print panic message to stdout and exit */
+  volatile int *sf;
+
+  sf = NULL;
+
+  printf("mthread panic (%s:%d): ", file, line);
+  printf("%s", msg);
+  printf("\n");
+  fflush(stdout);	/* Force debug print to screen */
+  *((int *) sf ) = 1;	/* Cause segfault to generate trace */
+  exit(1);
+}
+#else
+void mthread_panic_s(void)
+{
+  /* Silent panic */
+  volatile int *sf;
+
+  sf = NULL;
+  *((volatile int *) sf ) = 1;	/* Cause segfault to generate trace */
+  exit(1);
+}
+#endif
+
+
+/*===========================================================================*
+ *				mthread_verify_f			     *
+ *===========================================================================*/
+#ifdef MDEBUG
+void mthread_verify_f(char *file, int line)
+{
+  /* Verify library state. It is assumed this function is never called from
+   * a spawned thread, but from the 'main' thread. The library should be 
+   * quiescent; no mutexes, conditions, or threads in use. All threads are to
+   * be in DEAD state.
+   */
+  mthread_thread_t t;
+  mthread_tcb_t *tcb;
+  int threads_ok = 1, conditions_ok = 1, mutexes_ok = 1, attributes_ok = 1;
+
+  for (t = (mthread_thread_t) 0; threads_ok && t < no_threads; t++) {
+  	tcb = mthread_find_tcb(t);
+  	if (tcb->m_state != MS_DEAD) threads_ok = 0;
+  }
+
+  conditions_ok = mthread_cond_verify();
+  mutexes_ok = mthread_mutex_verify();
+  attributes_ok = mthread_attr_verify();
+
+  printf("(%s:%d) VERIFY ", file, line);
+  printf("| threads: %s |", (threads_ok ? "ok": "NOT ok"));
+  printf("| cond: %s |", (conditions_ok ? "ok": "NOT ok"));
+  printf("| mutex: %s |", (mutexes_ok ? "ok": "NOT ok"));
+  printf("| attr: %s |", (attributes_ok ? "ok": "NOT ok"));
+  printf("\n");
+
+  if(!threads_ok || !conditions_ok || !mutexes_ok)
+	mthread_panic("Library state corrupt\n");
+}
+
+
+/*===========================================================================*
+ *				mthread_stats				     *
+ *===========================================================================*/
+void mthread_stats(void)
+{
+  mthread_thread_t t;
+  mthread_tcb_t *tcb;
+  int st_run, st_dead, st_cond, st_mutex, st_exit;
+  st_run = st_dead = st_cond = st_mutex = st_exit = 0;
+
+  for (t = (mthread_thread_t) 0; t < no_threads; t++) {
+  	tcb = mthread_find_tcb(t);
+  	switch(tcb->m_state) {
+  		case MS_RUNNABLE: st_run++; break;
+  		case MS_DEAD: st_dead++; break;
+  		case MS_MUTEX: st_mutex++; break;
+  		case MS_CONDITION: st_cond++; break;
+  		case MS_EXITING: st_exit++; break;
+  		default: mthread_panic("Unknown state");
+  	}
+  }
+
+  printf("Pool: %-5d In use: %-5d R: %-5d D: %-5d M: %-5d C: %-5d E: %-5d\n",
+  	 no_threads, used_threads, st_run, st_dead, st_mutex, st_cond,
+	 st_exit);
+}
+
+#endif
+
+
+/*===========================================================================*
+ *				mthread_stacktrace			     *
+ *===========================================================================*/
+void mthread_stacktrace(mthread_thread_t t)
+{
+#ifdef __i386__ /* stacktrace only implemented on x86 */
+  unsigned long bp, hbp, pc;
+  mthread_tcb_t *tcb;
+  ucontext_t *ctx;
+
+  tcb = mthread_find_tcb(t);
+  ctx = &tcb->m_context;
+
+  if (t != MAIN_THREAD && ctx->uc_stack.ss_size == 0)
+	return; /* no stack, no stacktrace */
+
+  printf("thread %d: ", t);
+
+  bp = _UC_MACHINE_EBP(ctx);
+
+  while (bp) {
+	pc = ((unsigned long *) bp)[1];
+	hbp = ((unsigned long *) bp)[0];
+
+	printf("0x%lx ", (unsigned long) pc);
+
+	if (hbp != 0 && hbp <= bp) {
+		pc = -1;
+		printf("0x%lx ", (unsigned long) pc);
+		break;
+	}
+	bp = hbp;
+  }
+
+  printf("\n");
+#endif
+}
+
+/*===========================================================================*
+ *				mthread_stacktraces			     *
+ *===========================================================================*/
+void mthread_stacktraces(void)
+{
+  mthread_thread_t t;
+
+  mthread_stacktrace(MAIN_THREAD);
+
+  for (t = (mthread_thread_t) 0; t < no_threads; t++)
+	mthread_stacktrace(t);
+}
diff -ruNp srclimpio/minix/servers/syncvar/misc.d proj/minix/servers/syncvar/misc.d
--- srclimpio/minix/servers/syncvar/misc.d	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/misc.d	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,56 @@
+misc.o: misc.c pm.h /usr/include/minix/config.h \
+  /usr/include/minix/sys_config.h /usr/include/sys/types.h \
+  /usr/include/sys/featuretest.h /usr/include/machine/types.h \
+  /usr/include/sys/cdefs.h /usr/include/machine/cdefs.h \
+  /usr/include/sys/cdefs_elf.h /usr/include/machine/int_types.h \
+  /usr/include/machine/ansi.h /usr/include/sys/ansi.h \
+  /usr/include/machine/endian.h /usr/include/sys/endian.h \
+  /usr/include/machine/endian_machdep.h /usr/include/machine/bswap.h \
+  /usr/include/machine/byte_swap.h /usr/include/sys/bswap.h \
+  /usr/include/sys/fd_set.h /usr/include/minix/const.h \
+  /usr/include/machine/archconst.h /usr/include/sys/null.h \
+  /usr/include/minix/type.h /usr/include/machine/multiboot.h \
+  /usr/include/sys/sigtypes.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/stdint.h /usr/include/stdint.h \
+  /usr/include/machine/int_mwgwtypes.h /usr/include/machine/int_limits.h \
+  /usr/include/machine/int_const.h /usr/include/machine/wchar_limits.h \
+  /usr/include/machine/interrupt.h /usr/include/fcntl.h \
+  /usr/include/sys/stat.h /usr/include/sys/time.h \
+  /usr/include/sys/select.h /usr/include/time.h /usr/include/unistd.h \
+  /usr/include/sys/unistd.h /usr/include/string.h /usr/include/strings.h \
+  /usr/include/minix/syslib.h /usr/include/minix/ipc.h \
+  /usr/include/minix/ipcconst.h /usr/include/machine/ipcconst.h \
+  /usr/include/sys/signal.h /usr/include/sys/siginfo.h \
+  /usr/include/machine/signal.h /usr/include/machine/fpu.h \
+  /usr/include/machine/trap.h /usr/include/x86/trap.h \
+  /usr/include/sys/ucontext.h /usr/include/machine/mcontext.h \
+  /usr/include/minix/u64.h /usr/include/minix/devio.h \
+  /usr/include/minix/safecopies.h /usr/include/minix/vm.h \
+  /usr/include/minix/endpoint.h /usr/include/minix/com.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/limits.h /usr/include/limits.h \
+  /usr/include/machine/limits.h /usr/include/sys/syslimits.h \
+  /usr/include/minix/sef.h /usr/include/stdio.h \
+  /usr/include/minix/sysutil.h /usr/include/minix/timers.h \
+  /usr/include/minix/minlib.h /usr/include/sys/mount.h \
+  /usr/include/sys/param.h /usr/include/sys/inttypes.h \
+  /usr/include/machine/int_fmtio.h /usr/include/machine/param.h \
+  /usr/include/sys/uio.h /usr/include/sys/ucred.h \
+  /usr/include/sys/fstypes.h /usr/include/sys/queue.h \
+  /usr/include/sys/rwlock.h /usr/include/machine/rwlock.h \
+  /usr/include/x86/rwlock.h /usr/include/sys/statvfs.h \
+  /usr/include/sys/specificdata.h /usr/include/sys/mutex.h \
+  /usr/include/machine/mutex.h /usr/include/x86/mutex.h \
+  /usr/include/sys/condvar.h /usr/include/minix/param.h \
+  /usr/include/errno.h /usr/include/sys/errno.h const.h type.h proto.h \
+  glo.h /usr/include/minix/callnr.h /usr/include/signal.h \
+  /usr/include/sys/svrctl.h /usr/include/minix/ioctl.h \
+  /usr/include/sys/ioccom.h /usr/include/sys/reboot.h \
+  /usr/include/sys/resource.h /usr/include/sys/utsname.h \
+  /usr/include/minix/sysinfo.h /usr/include/minix/ds.h \
+  /usr/include/machine/archtypes.h /usr/include/machine/stackframe.h \
+  /usr/include/lib.h /usr/include/assert.h mproc.h \
+  /usr/src/minix/kernel/proc.h /usr/include/minix/portio.h \
+  /usr/src/minix/kernel/const.h /usr/include/minix/bitmap.h \
+  /usr/src/minix/kernel/config.h /usr/src/minix/kernel/debug.h \
+  /usr/include/minix/debug.h /usr/src/minix/kernel/priv.h \
+  /usr/include/minix/priv.h /usr/src/minix/kernel/type.h
Binary files srclimpio/minix/servers/syncvar/misc.o and proj/minix/servers/syncvar/misc.o differ
diff -ruNp srclimpio/minix/servers/syncvar/mproc.h proj/minix/servers/syncvar/mproc.h
--- srclimpio/minix/servers/syncvar/mproc.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/mproc.h	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,95 @@
+/* This table has one slot per process.  It contains all the process management
+ * information for each process.  Among other things, it defines the text, data
+ * and stack segments, uids and gids, and various flags.  The kernel and file
+ * systems have tables that are also indexed by process, with the contents
+ * of corresponding slots referring to the same process in all three.
+ */
+#include <limits.h>
+#include <minix/timers.h>
+#include <signal.h>
+
+#include <sys/cdefs.h>
+
+/* Needs to be included here, for 'ps' etc */
+#include "const.h"
+
+EXTERN struct mproc {
+  char mp_exitstatus;		/* storage for status when process exits */
+  char mp_sigstatus;		/* storage for signal # for killed procs */
+  pid_t mp_pid;			/* process id */
+  endpoint_t mp_endpoint;	/* kernel endpoint id */
+  pid_t mp_procgrp;		/* pid of process group (used for signals) */
+  pid_t mp_wpid;		/* pid this process is waiting for */
+  int mp_parent;		/* index of parent process */
+  int mp_tracer;		/* index of tracer process, or NO_TRACER */
+
+  /* Child user and system times. Accounting done on child exit. */
+  clock_t mp_child_utime;	/* cumulative user time of children */
+  clock_t mp_child_stime;	/* cumulative sys time of children */
+
+  /* Real and effective uids and gids. */
+  uid_t mp_realuid;		/* process' real uid */
+  uid_t mp_effuid;		/* process' effective uid */
+  gid_t mp_realgid;		/* process' real gid */
+  gid_t mp_effgid;		/* process' effective gid */
+
+  /* Supplemental groups. */
+  int mp_ngroups;		/* number of supplemental groups */
+  gid_t mp_sgroups[NGROUPS_MAX];/* process' supplemental groups */
+
+  /* Signal handling information. */
+  sigset_t mp_ignore;		/* 1 means ignore the signal, 0 means don't */
+  sigset_t mp_catch;		/* 1 means catch the signal, 0 means don't */
+  sigset_t mp_sigmask;		/* signals to be blocked */
+  sigset_t mp_sigmask2;		/* saved copy of mp_sigmask */
+  sigset_t mp_sigpending;	/* pending signals to be handled */
+  sigset_t mp_ksigpending;	/* bitmap for pending signals from the kernel */
+  sigset_t mp_sigtrace;		/* signals to hand to tracer first */
+  struct sigaction mp_sigact[_NSIG]; /* as in sigaction(2) */
+#ifdef __ACK__
+  char mp_padding[60];		/* align structure with new libc */
+#endif
+  vir_bytes mp_sigreturn; 	/* address of C library __sigreturn function */
+  minix_timer_t mp_timer;	/* watchdog timer for alarm(2), setitimer(2) */
+  clock_t mp_interval[NR_ITIMERS];	/* setitimer(2) repetition intervals */
+
+  unsigned mp_flags;		/* flag bits */
+  unsigned mp_trace_flags;	/* trace options */
+  message mp_reply;		/* reply message to be sent to one */
+
+  /* Process execution frame. Both fields are used by procfs. */
+  vir_bytes mp_frame_addr;	/* ptr to proc's initial stack arguments */
+  size_t mp_frame_len;		/* size of proc's initial stack arguments */
+
+  /* Scheduling priority. */
+  signed int mp_nice;		/* nice is PRIO_MIN..PRIO_MAX, standard 0. */
+
+  /* User space scheduling */
+  endpoint_t mp_scheduler;	/* scheduler endpoint id */
+
+  char mp_name[PROC_NAME_LEN];	/* process name */
+
+  int mp_magic;			/* sanity check, MP_MAGIC */
+} mproc[NR_PROCS];
+
+/* Flag values */
+#define IN_USE		0x00001	/* set when 'mproc' slot in use */
+#define WAITING		0x00002	/* set by WAITPID system call */
+#define ZOMBIE		0x00004	/* waiting for parent to issue WAITPID call */
+#define PROC_STOPPED	0x00008	/* process is stopped in the kernel */
+#define ALARM_ON	0x00010	/* set when SIGALRM timer started */
+#define EXITING		0x00020	/* set by EXIT, process is now exiting */
+#define TOLD_PARENT	0x00040	/* parent wait() completed, ZOMBIE off */
+#define TRACE_STOPPED	0x00080	/* set if process stopped for tracing */
+#define SIGSUSPENDED	0x00100	/* set by SIGSUSPEND system call */
+#define VFS_CALL       	0x00400	/* set if waiting for VFS (normal calls) */
+#define NEW_PARENT	0x00800	/* process's parent changed during VFS call */
+#define UNPAUSED	0x01000	/* VFS has replied to unpause request */
+#define PRIV_PROC	0x02000	/* system process, special privileges */
+#define PARTIAL_EXEC	0x04000	/* process got a new map but no content */
+#define TRACE_EXIT	0x08000	/* tracer is forcing this process to exit */
+#define TRACE_ZOMBIE	0x10000	/* waiting for tracer to issue WAITPID call */
+#define DELAY_CALL	0x20000	/* waiting for call before sending signal */
+#define TAINTED		0x40000 /* process is 'tainted' */
+
+#define MP_MAGIC	0xC0FFEE0
diff -ruNp srclimpio/minix/servers/syncvar/mutex.c proj/minix/servers/syncvar/mutex.c
--- srclimpio/minix/servers/syncvar/mutex.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/mutex.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,265 @@
+#include <minix/mthread.h>
+#include "global.h"
+#include "proto.h"
+
+#ifdef MTHREAD_STRICT
+static struct __mthread_mutex *vm_front, *vm_rear;
+static void mthread_mutex_add(mthread_mutex_t *m);
+static void mthread_mutex_remove(mthread_mutex_t *m);
+#else
+# define mthread_mutex_add(m)		((*m)->mm_magic = MTHREAD_INIT_MAGIC)
+# define mthread_mutex_remove(m)	((*m)->mm_magic = MTHREAD_NOT_INUSE)
+#endif
+
+/*===========================================================================*
+ *				mthread_init_valid_mutexes		     *
+ *===========================================================================*/
+void mthread_init_valid_mutexes(void)
+{
+#ifdef MTHREAD_STRICT
+/* Initialize list of valid mutexes */
+  vm_front = vm_rear = NULL;
+#endif
+}
+
+
+/*===========================================================================*
+ *				mthread_mutex_add			     *
+ *===========================================================================*/
+#ifdef MTHREAD_STRICT
+static void mthread_mutex_add(m) 
+mthread_mutex_t *m;
+{
+/* Add mutex to list of valid, initialized mutexes */
+
+  if (vm_front == NULL) {	/* Empty list */
+  	vm_front = *m;
+  	(*m)->mm_prev = NULL;
+  } else {
+  	vm_rear->mm_next = *m;
+  	(*m)->mm_prev = vm_rear;
+  }
+
+  (*m)->mm_next = NULL;
+  vm_rear = *m;
+}
+#endif
+
+/*===========================================================================*
+ *				mthread_mutex_destroy			     *
+ *===========================================================================*/
+int mthread_mutex_destroy(mutex)
+mthread_mutex_t *mutex;
+{
+/* Invalidate mutex and deallocate resources. */
+
+  mthread_thread_t t;
+  mthread_tcb_t *tcb;
+
+  if (mutex == NULL)
+  	return(EINVAL);
+
+  if (!mthread_mutex_valid(mutex)) 
+  	return(EINVAL);
+  else if ((*mutex)->mm_owner != NO_THREAD)
+  	return(EBUSY);
+
+  /* Check if this mutex is not associated with a condition */
+  for (t = (mthread_thread_t) 0; t < no_threads; t++) {
+  	tcb = mthread_find_tcb(t);
+	if (tcb->m_state == MS_CONDITION) {
+		if (tcb->m_cond != NULL && tcb->m_cond->mc_mutex == *mutex) 
+			return(EBUSY);
+	}
+  }
+
+  /* Not in use; invalidate it */
+  mthread_mutex_remove(mutex);	
+  free(*mutex);
+  *mutex = NULL;
+
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_mutex_init			     *
+ *===========================================================================*/
+int mthread_mutex_init(mutex, mattr)
+mthread_mutex_t *mutex;	/* Mutex that is to be initialized */
+mthread_mutexattr_t *mattr;	/* Mutex attribute */
+{
+/* Initialize the mutex to a known state. Attributes are not supported */
+
+  struct __mthread_mutex *m;
+
+  if (mutex == NULL)
+  	return(EAGAIN);
+  else if (mattr != NULL)
+  	return(ENOSYS);
+#ifdef MTHREAD_STRICT
+  else if (mthread_mutex_valid(mutex))
+  	return(EBUSY);
+#endif
+  else if ((m = malloc(sizeof(struct __mthread_mutex))) == NULL) 
+  	return(ENOMEM);
+
+  mthread_queue_init(&m->mm_queue);
+  m->mm_owner = NO_THREAD;
+  *mutex = (mthread_mutex_t) m;
+  mthread_mutex_add(mutex); /* Validate mutex; mutex now in use */
+
+  return(0);
+}
+
+/*===========================================================================*
+ *				mthread_mutex_lock			     *
+ *===========================================================================*/
+int mthread_mutex_lock(mutex)
+mthread_mutex_t *mutex;	/* Mutex that is to be locked */
+{
+/* Try to lock this mutex. If already locked, append the current thread to
+ * FIFO queue associated with this mutex and suspend the thread. */
+
+  struct __mthread_mutex *m;
+
+  if (mutex == NULL)
+  	return(EINVAL);
+
+  m = (struct __mthread_mutex *) *mutex;
+  if (!mthread_mutex_valid(&m)) 
+  	return(EINVAL);
+  else if (m->mm_owner == NO_THREAD) { /* Not locked */
+	m->mm_owner = current_thread;
+  } else if (m->mm_owner == current_thread) {
+  	return(EDEADLK);
+  } else {
+	mthread_queue_add(&m->mm_queue, current_thread);
+	mthread_suspend(MS_MUTEX);
+  }
+
+  /* When we get here we acquired the lock. */
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_mutex_remove			     *
+ *===========================================================================*/
+#ifdef MTHREAD_STRICT
+static void mthread_mutex_remove(m)
+mthread_mutex_t *m;
+{
+/* Remove mutex from list of valid, initialized mutexes */
+
+  if ((*m)->mm_prev == NULL)
+  	vm_front = (*m)->mm_next;
+  else
+  	(*m)->mm_prev->mm_next = (*m)->mm_next;
+
+  if ((*m)->mm_next == NULL)
+  	vm_rear = (*m)->mm_prev;
+  else
+  	(*m)->mm_next->mm_prev = (*m)->mm_prev;
+}
+#endif
+
+/*===========================================================================*
+ *				mthread_mutex_trylock			     *
+ *===========================================================================*/
+int mthread_mutex_trylock(mutex)
+mthread_mutex_t *mutex;	/* Mutex that is to be locked */
+{
+/* Try to lock this mutex and return OK. If already locked, return error. */
+
+  struct __mthread_mutex *m;
+
+  if (mutex == NULL) 
+  	return(EINVAL);
+
+  m = (struct __mthread_mutex *) *mutex;
+  if (!mthread_mutex_valid(&m))
+  	return(EINVAL);
+  else if (m->mm_owner == current_thread)
+	return(EDEADLK);
+  else if (m->mm_owner == NO_THREAD) {
+	m->mm_owner = current_thread;
+	return(0);
+  } 
+
+  return(EBUSY);
+}
+
+
+/*===========================================================================*
+ *				mthread_mutex_unlock			     *
+ *===========================================================================*/
+int mthread_mutex_unlock(mutex)
+mthread_mutex_t *mutex;	/* Mutex that is to be unlocked */
+{
+/* Unlock a previously locked mutex. If there is a pending lock for this mutex 
+ * by another thread, mark that thread runnable. */
+
+  struct __mthread_mutex *m;
+
+  if (mutex == NULL) 
+	return(EINVAL);
+
+  m = (struct __mthread_mutex *) *mutex;
+  if (!mthread_mutex_valid(&m))
+	return(EINVAL);
+  else if (m->mm_owner != current_thread) 
+  	return(EPERM);	/* Can't unlock a mutex locked by another thread. */
+
+  m->mm_owner = mthread_queue_remove(&m->mm_queue);
+  if (m->mm_owner != NO_THREAD) mthread_unsuspend(m->mm_owner);
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_mutex_valid			     *
+ *===========================================================================*/
+#ifdef MTHREAD_STRICT
+int mthread_mutex_valid(m)
+mthread_mutex_t *m;
+{
+/* Check to see if mutex is on the list of valid mutexes */
+  struct __mthread_mutex *loopitem;
+
+  loopitem = vm_front;
+
+  while (loopitem != NULL) {
+	if (loopitem == *m)
+		return(1);
+
+	loopitem = loopitem->mm_next;
+  }
+
+  return(0);
+}
+#endif
+
+/*===========================================================================*
+ *				mthread_mutex_verify			     *
+ *===========================================================================*/
+#ifdef MDEBUG
+int mthread_mutex_verify(void)
+{
+  /* Return true when no mutexes are in use */
+  int r = 1;
+  struct __mthread_mutex *loopitem;
+
+#ifdef MTHREAD_STRICT
+  loopitem = vm_front;
+
+  while (loopitem != NULL) {
+  	printf("mutex corruption: owner: %d\n", loopitem->mm_owner);
+	loopitem = loopitem->mm_next;
+  	r = 0;
+  }
+#endif
+
+  return(r);
+}
+#endif
Binary files srclimpio/minix/servers/syncvar/mutex.o and proj/minix/servers/syncvar/mutex.o differ
Binary files srclimpio/minix/servers/syncvar/mutux.o and proj/minix/servers/syncvar/mutux.o differ
diff -ruNp srclimpio/minix/servers/syncvar/pm.h proj/minix/servers/syncvar/pm.h
--- srclimpio/minix/servers/syncvar/pm.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/pm.h	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,27 @@
+/* This is the master header for PM.  It includes some other files
+ * and defines the principal constants.
+ */
+#define _SYSTEM		1	/* tell headers that this is the kernel */
+
+/* The following are so basic, all the *.c files get them automatically. */
+#include <minix/config.h>	/* MUST be first */
+#include <sys/types.h>
+#include <minix/const.h>
+#include <minix/type.h>
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <minix/syslib.h>
+#include <minix/sysutil.h>
+#include <minix/timers.h>
+#include <minix/param.h>
+
+#include <limits.h>
+#include <errno.h>
+#include <sys/param.h>
+
+#include "const.h"
+#include "type.h"
+#include "pro.h"
+#include "glo.h"
diff -ruNp srclimpio/minix/servers/syncvar/pro.h proj/minix/servers/syncvar/pro.h
--- srclimpio/minix/servers/syncvar/pro.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/pro.h	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,29 @@
+/* Function prototypes. */
+
+struct mproc;
+
+#include <minix/timers.h>
+
+
+/* main.c */
+int main(void);
+void reply(int proc_nr, int result);
+
+/* misc.c */
+int do_mutex_init(void);
+int do_mutex_destroy(void);
+int do_mutex_lock(void);
+int do_mutex_unlock(void);
+int do_cv_init(void);
+int do_cv_destroy(void);
+int do_cv_wait(void);
+int do_cv_signal(void);
+int do_cv_broadcast(void);
+
+/* utility.c */
+pid_t get_free_pid(void);
+char *find_param(const char *key);
+struct mproc *find_proc(pid_t lpid);
+int nice_to_priority(int nice, unsigned *new_q);
+int pm_isokendpt(int ep, int *proc);
+void tell_vfs(struct mproc *rmp, message *m_ptr);
diff -ruNp srclimpio/minix/servers/syncvar/proto.h proj/minix/servers/syncvar/proto.h
--- srclimpio/minix/servers/syncvar/proto.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/proto.h	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,65 @@
+#ifndef __MTHREAD_PROTO_H__
+#define __MTHREAD_PROTO_H__
+
+/* allocate.c */
+mthread_tcb_t * mthread_find_tcb(mthread_thread_t thread);
+void mthread_thread_reset(mthread_thread_t thread);
+
+/* attribute.c */
+void mthread_init_valid_attributes(void);
+#ifdef MDEBUG
+int mthread_attr_verify(void);
+#endif
+
+/* cond.c */
+void mthread_init_valid_conditions(void);
+#ifdef MDEBUG
+int mthread_cond_verify(void);
+#endif
+
+/* key.c */
+void mthread_init_keys(void);
+void mthread_cleanup_values(void);
+
+/* misc.c */
+#ifdef MDEBUG
+#define mthread_panic(m) mthread_panic_f(__FILE__, __LINE__, (m))
+void mthread_panic_f(const char *file, int line, const char *msg);
+#define mthread_debug(m) mthread_debug_f(__FILE__, __LINE__, (m))
+void mthread_debug_f(const char *file, int line, const char *msg);
+#else
+__dead void mthread_panic_s(void);
+# define mthread_panic(m) mthread_panic_s()
+# define mthread_debug(m)
+#endif
+
+/* mutex.c */
+void mthread_init_valid_mutexes(void);
+
+#ifdef MTHREAD_STRICT
+int mthread_mutex_valid(mthread_mutex_t *mutex);
+#else
+# define mthread_mutex_valid(x) ((*x)->mm_magic == MTHREAD_INIT_MAGIC)
+#endif
+
+#ifdef MDEBUG
+int mthread_mutex_verify(void);
+#endif
+
+/* schedule.c */
+int mthread_getcontext(ucontext_t *ctxt);
+void mthread_init_scheduler(void);
+void mthread_schedule(void);
+void mthread_suspend(mthread_state_t state);
+void mthread_unsuspend(mthread_thread_t thread);
+
+/* queue.c */
+#ifdef MDEBUG
+void mthread_dump_queue(mthread_queue_t *queue);
+#endif
+void mthread_queue_init(mthread_queue_t *queue);
+void mthread_queue_add(mthread_queue_t *queue, mthread_thread_t thread);
+mthread_thread_t mthread_queue_remove(mthread_queue_t *queue);
+int mthread_queue_isempty(mthread_queue_t *queue);
+
+#endif
diff -ruNp srclimpio/minix/servers/syncvar/pthread_compat.c proj/minix/servers/syncvar/pthread_compat.c
--- srclimpio/minix/servers/syncvar/pthread_compat.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/pthread_compat.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,145 @@
+#define _MTHREADIFY_PTHREADS
+#include <minix/mthread.h>
+#include "global.h"
+#include "proto.h"
+
+/* WARNING:
+ * The following works under the hypothesis that we have only green threads,
+ * which implies that we have no preemption, unless explicit yield or possible
+ * calls done to mthread functions.
+ *
+ * This has impact on the fact we do not maintain a table of currently being
+ * initialized mutexes or condition variables, to prevent double initialization
+ * and/or TOCTU problems. TOCTU could appear between the test against the
+ * initializer value, and the actual initialization, which could lead to double
+ * initialization of the same mutex AND get two threads at the same time in the
+ * critical section as they both hold a (different) mutex.
+ */
+
+
+/*===========================================================================*
+ *				pthread_mutex_init			     *
+ *===========================================================================*/
+int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *mattr)
+{
+	return mthread_mutex_init(mutex, mattr);
+}
+
+/*===========================================================================*
+ *				pthread_mutex_destroy			     *
+ *===========================================================================*/
+int pthread_mutex_destroy(pthread_mutex_t *mutex)
+{
+	if (PTHREAD_MUTEX_INITIALIZER == *mutex) {
+		*mutex = NULL;
+		return 0;
+	}
+
+	return mthread_mutex_destroy(mutex);
+}
+
+/*===========================================================================*
+ *				pthread_mutex_lock			     *
+ *===========================================================================*/
+int pthread_mutex_lock(pthread_mutex_t *mutex)
+{
+	if (PTHREAD_MUTEX_INITIALIZER == *mutex) {
+		mthread_mutex_init(mutex, NULL);	
+	}
+
+	return mthread_mutex_lock(mutex);
+}
+
+/*===========================================================================*
+ *				pthread_mutex_trylock			     *
+ *===========================================================================*/
+int pthread_mutex_trylock(pthread_mutex_t *mutex)
+{
+	if (PTHREAD_MUTEX_INITIALIZER == *mutex) {
+		mthread_mutex_init(mutex, NULL);	
+	}
+
+	return pthread_mutex_trylock(mutex);
+}
+
+/*===========================================================================*
+ *				pthread_mutex_unlock			     *
+ *===========================================================================*/
+int pthread_mutex_unlock(pthread_mutex_t *mutex)
+{
+	if (PTHREAD_MUTEX_INITIALIZER == *mutex) {
+		mthread_mutex_init(mutex, NULL);	
+	}
+
+	return mthread_mutex_unlock(mutex);
+}
+
+/*===========================================================================*
+ *				pthread_cond_init			     *
+ *===========================================================================*/
+int pthread_cond_init(pthread_cond_t *cond, pthread_condattr_t *cattr)
+{
+	return mthread_cond_init(cond, cattr);
+}
+
+/*===========================================================================*
+ *				pthread_cond_broadcast			     *
+ *===========================================================================*/
+int pthread_cond_broadcast(pthread_cond_t *cond)
+{
+	if (PTHREAD_COND_INITIALIZER == *cond) {
+		mthread_cond_init(cond, NULL);
+	}
+
+	return mthread_cond_broadcast(cond);
+}
+
+/*===========================================================================*
+ *				pthread_cond_destroy			     *
+ *===========================================================================*/
+int pthread_cond_destroy(pthread_cond_t *cond)
+{
+	if (PTHREAD_COND_INITIALIZER == *cond) {
+		*cond = NULL;
+		return 0;
+	}
+
+	return mthread_cond_destroy(cond);
+}
+
+/*===========================================================================*
+ *				pthread_cond_signal			     *
+ *===========================================================================*/
+int pthread_cond_signal(pthread_cond_t *cond)
+{
+	if (PTHREAD_COND_INITIALIZER == *cond) {
+		mthread_cond_init(cond, NULL);
+	}
+
+	return mthread_cond_signal(cond);
+}
+
+/*===========================================================================*
+ *				pthread_cond_wait			     *
+ *===========================================================================*/
+int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
+{
+	if (PTHREAD_COND_INITIALIZER == *cond) {
+		mthread_cond_init(cond, NULL);
+	}
+
+	return mthread_cond_wait(cond, mutex);
+}
+
+/*===========================================================================*
+ *				pthread_rwlock_init			     *
+ *===========================================================================*/
+int pthread_rwlock_init(pthread_rwlock_t *rwlock, pthread_rwlockattr_t *UNUSED(attr))
+{
+	return mthread_rwlock_init(rwlock);
+}
+
+#if !defined(__weak_alias)
+#error __weak_alias is required to compile the pthread compat library
+#endif
+
Binary files srclimpio/minix/servers/syncvar/pthread_compat.o and proj/minix/servers/syncvar/pthread_compat.o differ
diff -ruNp srclimpio/minix/servers/syncvar/queue.c proj/minix/servers/syncvar/queue.c
--- srclimpio/minix/servers/syncvar/queue.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/queue.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,162 @@
+#include <minix/mthread.h>
+#include "global.h"
+#include "proto.h"
+
+/*===========================================================================*
+ *				mthread_queue_add			     *
+ *===========================================================================*/
+void mthread_queue_add(queue, thread)
+mthread_queue_t *queue;		/* Queue we want thread to append to */
+mthread_thread_t thread;
+{
+/* Append a thread to the tail of the queue. As a process can be present on
+ * only one queue at the same time, we can use the threads array's 'next'
+ * pointer to point to the next thread on the queue.
+ */
+  mthread_tcb_t *last;
+
+  if (!isokthreadid(thread))
+  	mthread_panic("Can't append invalid thread ID to a queue");
+
+  last = mthread_find_tcb(thread);
+
+  if (mthread_queue_isempty(queue)) {
+  	queue->mq_head = queue->mq_tail = last;
+  } else  {
+	queue->mq_tail->m_next = last;
+	queue->mq_tail = last;	/* 'last' is the new last in line */
+  }
+}
+
+
+/*===========================================================================*
+ *				mthread_queue_init			     *
+ *===========================================================================*/
+void mthread_queue_init(queue)
+mthread_queue_t *queue;		/* Queue that has to be initialized */
+{
+/* Initialize queue to a known state */
+
+  queue->mq_head = queue->mq_tail = NULL;
+}
+
+
+/*===========================================================================*
+ *				mthread_queue_isempty			     *
+ *===========================================================================*/
+int mthread_queue_isempty(queue)
+mthread_queue_t *queue;
+{
+  return(queue->mq_head == NULL);
+}
+
+
+/*===========================================================================*
+ *				mthread_dump_queue			     *
+ *===========================================================================*/
+#ifdef MDEBUG
+void mthread_dump_queue(queue)
+mthread_queue_t *queue;
+{
+  int threshold, count = 0;
+  mthread_tcb_t *t;
+  mthread_thread_t tid;
+  threshold = no_threads;
+  printf("Dumping queue: ");
+
+  if(queue->mq_head != NULL) {
+  	t = queue->mq_head;
+	if (t == &mainthread) tid = MAIN_THREAD;
+	else tid = t->m_tid;
+	printf("%d ", tid);
+	count++;
+	t = t->m_next; 
+	while (t != NULL) {
+		if (t == &mainthread) tid = MAIN_THREAD;
+		else tid = t->m_tid;
+		printf("%d ", tid);
+		t = t->m_next; 
+		count++;
+		if (count > threshold) break;
+	}
+  } else {
+  	printf("[empty]");
+  }
+
+  printf("\n");
+}
+#endif
+
+/*===========================================================================*
+ *				mthread_queue_remove			     *
+ *===========================================================================*/
+mthread_thread_t mthread_queue_remove(queue)
+mthread_queue_t *queue;		/* Queue we want a thread from */
+{
+/* Get the first thread in this queue, if there is one. */
+  mthread_thread_t thread;
+  mthread_tcb_t *tcb, *random_tcb, *prev;
+  int count = 0, offset_id = 0, picked_random = 0;
+
+  tcb = queue->mq_head;
+
+  if (MTHREAD_RND_SCHED) {
+	/* Count items on queue */
+	random_tcb = queue->mq_head;
+	if (random_tcb != NULL) {
+		do {
+			count++;
+			random_tcb = random_tcb->m_next;
+		} while (random_tcb != NULL);
+	}
+
+	if (count > 1) {
+		picked_random = 1;
+
+		/* Get random offset */
+		offset_id = random() % count;
+
+		/* Find offset in queue */
+		random_tcb = queue->mq_head;
+		prev = random_tcb;
+		while (--offset_id > 0) {
+			prev = random_tcb;
+			random_tcb = random_tcb->m_next;
+		}
+
+		/* Stitch head and tail together */
+		prev->m_next = random_tcb->m_next;
+
+		/* Fix head and tail */
+		if (queue->mq_head == random_tcb)
+			queue->mq_head = random_tcb->m_next;
+		if (queue->mq_tail == random_tcb)
+			queue->mq_tail = prev;
+
+		tcb = random_tcb;
+	}
+  }
+
+  /* Retrieve thread id from tcb */
+  if (tcb == NULL) thread = NO_THREAD;
+  else if (tcb == &mainthread) thread = MAIN_THREAD;
+  else thread = (tcb->m_tid);
+
+  /* If we didn't pick a random thread and queue is not empty... */
+  if (!picked_random && thread != NO_THREAD) {
+  	tcb = queue->mq_head;
+	if (queue->mq_head == queue->mq_tail) {
+		/* Queue holds only one thread */
+		queue->mq_head = queue->mq_tail = NULL; /* So mark thread empty */
+	} else {
+		/* Second thread in line is the new first */
+		queue->mq_head = queue->mq_head->m_next;
+	}
+  }
+
+  if (tcb != NULL)
+	tcb->m_next = NULL; /* This thread is no longer part of a queue */
+
+  return(thread);
+}
+
Binary files srclimpio/minix/servers/syncvar/queue.o and proj/minix/servers/syncvar/queue.o differ
diff -ruNp srclimpio/minix/servers/syncvar/rwlock.c proj/minix/servers/syncvar/rwlock.c
--- srclimpio/minix/servers/syncvar/rwlock.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/rwlock.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,137 @@
+#include <minix/mthread.h>
+#include "global.h"
+
+/*===========================================================================*
+ *				mthread_rwlock_init			     *
+ *===========================================================================*/
+int mthread_rwlock_init(rwlock)
+mthread_rwlock_t *rwlock; /* The rwlock to be initialized */
+{
+  /* Initialize a readers/writer lock. */
+  int r;
+
+  if (!rwlock)
+	return EINVAL;
+
+  rwlock->writer = NO_THREAD;
+  rwlock->readers = 0;
+
+  r = mthread_mutex_init(&rwlock->queue, NULL);
+  if (r != 0)
+	return r;
+
+  r = mthread_event_init(&rwlock->drain);
+  if (r != 0)
+	mthread_mutex_destroy(&rwlock->queue);
+
+  return r;
+}
+
+/*===========================================================================*
+ *				mthread_rwlock_destroy			     *
+ *===========================================================================*/
+int mthread_rwlock_destroy(rwlock)
+mthread_rwlock_t *rwlock; /* The rwlock to be destroyed */
+{
+  /* Destroy a readers/writer lock. */
+  int r;
+
+  if (!rwlock)
+	return EINVAL;
+
+  assert(rwlock->writer == NO_THREAD);
+  assert(rwlock->readers == 0);
+
+  r = mthread_event_destroy(&rwlock->drain);
+  if (r != 0)
+	return r;
+
+  return mthread_mutex_destroy(&rwlock->queue);
+}
+
+/*===========================================================================*
+ *				mthread_rwlock_rdlock			     *
+ *===========================================================================*/
+int mthread_rwlock_rdlock(rwlock)
+mthread_rwlock_t *rwlock; /* The rwlock to be read locked */
+{
+  /* Acquire a reader lock. */
+  int r;
+
+  if (!rwlock)
+	return EINVAL;
+
+  r = mthread_mutex_lock(&rwlock->queue);
+  if (r != 0)
+	return r;
+
+  r = mthread_mutex_unlock(&rwlock->queue);
+  if (r != 0)
+	return r;
+
+  rwlock->readers++;
+
+  return 0;
+}
+
+/*===========================================================================*
+ *				mthread_rwlock_wrlock			     *
+ *===========================================================================*/
+int mthread_rwlock_wrlock(rwlock)
+mthread_rwlock_t *rwlock; /* The rwlock to be write locked */
+{
+  /* Acquire a writer lock. */
+  int r;
+
+  if (!rwlock)
+	  return EINVAL;
+
+  r = mthread_mutex_lock(&rwlock->queue);
+  if (r != 0)
+	return r;
+
+  rwlock->writer = current_thread;
+
+  if (rwlock->readers > 0)
+	r = mthread_event_wait(&rwlock->drain);
+
+  if (r == 0)
+	assert(rwlock->readers == 0);
+
+  return r;
+}
+
+/*===========================================================================*
+ *				mthread_rwlock_unlock				*
+ *===========================================================================*/
+int mthread_rwlock_unlock(rwlock)
+mthread_rwlock_t *rwlock; /* The rwlock to be unlocked */
+{
+  /* Release a lock. */
+  int r;
+
+  r = 0;
+  if (!rwlock)
+	  return EINVAL;
+
+  if (rwlock->writer == current_thread) {
+	rwlock->writer = NO_THREAD;
+	r = mthread_mutex_unlock(&rwlock->queue);
+  } else {
+	assert(rwlock->readers > 0);
+
+	rwlock->readers--;
+
+	if (rwlock->readers == 0 && rwlock->writer != NO_THREAD)
+		r = mthread_event_fire(&rwlock->drain);
+  }
+
+  return r;
+}
+
+/* pthread compatibility layer. */
+__weak_alias(pthread_rwlock_destroy, mthread_rwlock_destroy)
+__weak_alias(pthread_rwlock_rdlock, mthread_rwlock_rdlock)
+__weak_alias(pthread_rwlock_wrlock, mthread_rwlock_wrlock)
+__weak_alias(pthread_rwlock_unlock, mthread_rwlock_unlock)
+
Binary files srclimpio/minix/servers/syncvar/rwlock.o and proj/minix/servers/syncvar/rwlock.o differ
diff -ruNp srclimpio/minix/servers/syncvar/scheduler.c proj/minix/servers/syncvar/scheduler.c
--- srclimpio/minix/servers/syncvar/scheduler.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/scheduler.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,215 @@
+#include <minix/mthread.h>
+#include "global.h"
+#include "proto.h"
+
+#define MAIN_CTX	&(mainthread.m_context)
+#define MAIN_STATE	mainthread.m_state
+#define OLD_CTX		&(threads[old_thread]->m_context)
+#define CURRENT_CTX	&(threads[current_thread]->m_context)
+#define CURRENT_STATE	threads[current_thread]->m_state
+static int yield_all;
+
+/*===========================================================================*
+ *				mthread_getcontext			     *
+ *===========================================================================*/
+int mthread_getcontext(ctx)
+ucontext_t *ctx;
+{
+/* Retrieve this process' current state.*/
+
+  /* We're not interested in FPU state nor signals, so ignore them. 
+   * Coincidentally, this significantly speeds up performance.
+   */
+  ctx->uc_flags |= _UC_IGNSIGM | _UC_IGNFPU;
+  return getcontext(ctx);
+}
+
+
+/*===========================================================================*
+ *				mthread_schedule			     *
+ *===========================================================================*/
+void mthread_schedule(void)
+{
+/* Pick a new thread to run and run it. In practice, this involves taking the 
+ * first thread off the (FIFO) run queue and resuming that thread. 
+ */
+
+  mthread_thread_t old_thread;
+  mthread_tcb_t *new_tcb, *old_tcb;
+  ucontext_t *new_ctx, *old_ctx;
+
+  old_thread = current_thread;
+
+  if (mthread_queue_isempty(&run_queue)) {
+	/* No runnable threads. Let main thread run. */
+
+	/* We keep track whether we're running the program's 'main' thread or
+	 * a spawned thread. In case we're already running the main thread and
+	 * there are no runnable threads, we can't jump back to its context. 
+	 * Instead, we simply return.
+	 */
+	if (running_main_thread) return;
+
+	/* We're running the last runnable spawned thread. Return to main
+	 * thread as there is no work left.
+	 */
+	current_thread = MAIN_THREAD;
+  } else {
+	current_thread = mthread_queue_remove(&run_queue);
+  }
+
+  /* Find thread entries in tcb... */
+  new_tcb = mthread_find_tcb(current_thread);
+  old_tcb = mthread_find_tcb(old_thread);
+
+  /* ...and subsequently their contexts */
+  new_ctx = &(new_tcb->m_context);
+  old_ctx = &(old_tcb->m_context);
+
+  /* Are we running the 'main' thread after swap? */
+  running_main_thread = (current_thread == MAIN_THREAD);
+
+  if (swapcontext(old_ctx, new_ctx) == -1)
+	mthread_panic("Could not swap context");
+  
+}
+
+
+/*===========================================================================*
+ *				mthread_init_scheduler			     *
+ *===========================================================================*/
+void mthread_init_scheduler(void)
+{
+/* Initialize the scheduler */
+  mthread_queue_init(&run_queue);
+  yield_all = 0;
+
+}
+
+
+/*===========================================================================*
+ *				mthread_suspend				     *
+ *===========================================================================*/
+void mthread_suspend(state)
+mthread_state_t state;
+{
+/* Stop the current thread from running. There can be multiple reasons for
+ * this; the process tries to lock a locked mutex (i.e., has to wait for it to
+ * become unlocked), the process has to wait for a condition, the thread
+ * volunteered to let another thread to run (i.e., it called yield and remains
+ * runnable itself), or the thread is dead.
+ */
+
+  int continue_thread = 0;
+  mthread_tcb_t *tcb;
+  ucontext_t *ctx;
+
+  if (state == MS_DEAD) mthread_panic("Shouldn't suspend with MS_DEAD state");
+  tcb = mthread_find_tcb(current_thread);
+  tcb->m_state = state;
+  ctx = &(tcb->m_context);
+
+  /* Save current thread's context */
+  if (mthread_getcontext(ctx) != 0)
+	mthread_panic("Couldn't save current thread's context");
+  
+  /* We return execution here with setcontext/swapcontext, but also when we
+   * simply return from the getcontext call. If continue_thread is non-zero, we
+   * are continuing the execution of this thread after a call from setcontext 
+   * or swapcontext.
+   */
+
+  if(!continue_thread) {
+  	continue_thread = 1;
+	mthread_schedule(); /* Let other thread run. */
+  }
+}
+
+
+/*===========================================================================*
+ *				mthread_unsuspend			     *
+ *===========================================================================*/
+void mthread_unsuspend(thread)
+mthread_thread_t thread; /* Thread to make runnable */
+{
+/* Mark the state of a thread runnable and add it to the run queue */
+  mthread_tcb_t *tcb;
+
+  if (!isokthreadid(thread)) mthread_panic("Invalid thread id");
+  
+  tcb = mthread_find_tcb(thread);
+  tcb->m_state = MS_RUNNABLE;
+  mthread_queue_add(&run_queue, thread);
+}
+
+
+/*===========================================================================*
+ *				mthread_yield				     *
+ *===========================================================================*/
+int mthread_yield(void)
+{
+/* Defer further execution of the current thread and let another thread run. */
+  mthread_tcb_t *tcb;
+  mthread_thread_t t;
+
+  /* Detached threads cannot clean themselves up. This is a perfect moment to
+   * do it */
+  for (t = (mthread_thread_t) 0; need_reset > 0 && t < no_threads; t++) {
+	tcb = mthread_find_tcb(t);
+	if (tcb->m_state == MS_NEEDRESET) {
+		mthread_thread_reset(t);
+		used_threads--;
+		need_reset--;
+		mthread_queue_add(&free_threads, t);
+	}
+  }
+
+  if (mthread_queue_isempty(&run_queue)) {	/* No point in yielding. */
+  	return(-1);
+  } else if (current_thread == NO_THREAD) {
+  	/* Can't yield this thread */
+  	return(-1);
+  }
+
+  mthread_queue_add(&run_queue, current_thread);
+  mthread_suspend(MS_RUNNABLE);	/* We're still runnable, but we're just kind
+				 * enough to let someone else run.
+				 */
+  return(0);
+}
+
+
+/*===========================================================================*
+ *				mthread_yield_all			     *
+ *===========================================================================*/
+void mthread_yield_all(void)
+{
+/* Yield until there are no more runnable threads left. Two threads calling
+ * this function will lead to a deadlock.
+ */
+
+  if (yield_all) mthread_panic("Deadlock: two threads trying to yield_all");
+  yield_all = 1;
+
+  /* This works as follows. Thread A is running and threads B, C, and D are
+   * runnable. As A is running, it is NOT on the run_queue (see
+   * mthread_schedule). It calls mthread_yield and will be added to the run
+   * queue, allowing B to run. B runs and suspends eventually, possibly still
+   * in a runnable state. Then C and D run. Eventually A will run again (and is
+   * thus not on the list). If B, C, and D are dead, waiting for a condition,
+   * or waiting for a lock, they are not on the run queue either. At that
+   * point A is the only runnable thread left.
+   */
+  while (!mthread_queue_isempty(&run_queue)) {
+	(void) mthread_yield();
+  }
+
+  /* Done yielding all threads. */
+  yield_all = 0;
+}
+
+/* pthread compatibility layer. */
+__weak_alias(pthread_yield, mthread_yield)
+__weak_alias(sched_yield, mthread_yield)
+__weak_alias(pthread_yield_all, mthread_yield_all)
+
Binary files srclimpio/minix/servers/syncvar/scheduler.o and proj/minix/servers/syncvar/scheduler.o differ
Binary files srclimpio/minix/servers/syncvar/syncvar and proj/minix/servers/syncvar/syncvar differ
diff -ruNp srclimpio/minix/servers/syncvar/syncvar.c proj/minix/servers/syncvar/syncvar.c
--- srclimpio/minix/servers/syncvar/syncvar.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/syncvar.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,273 @@
+/* Miscellaneous system calls.				Author: Kees J. Bot
+ *								31 Mar 2000
+ * The entry points into this file are:
+ *   do_reboot: kill all processes, then reboot system
+ *   do_getsysinfo: request copy of PM data structure  (Jorrit N. Herder)
+ *   do_getprocnr: lookup endpoint by process ID
+ *   do_getepinfo: get the pid/uid/gid of a process given its endpoint
+ *   do_getsetpriority: get/set process priority
+ *   do_svrctl: process manager control
+ */
+
+#include "pm.h"
+#include <minix/callnr.h>
+#include <signal.h>
+#include <sys/svrctl.h>
+#include <sys/reboot.h>
+#include <sys/resource.h>
+#include <sys/utsname.h>
+#include <minix/com.h>
+#include <minix/config.h>
+#include <minix/sysinfo.h>
+#include <minix/type.h>
+#include <minix/ds.h>
+#include <machine/archtypes.h>
+#include <lib.h>
+#include <assert.h>
+#include "mproc.h"
+#include "kernel/proc.h"
+#include <minix/mthread.h>
+#include "global.h"
+#include "proto.h"
+
+struct utsname uts_val = {
+  OS_NAME,		/* system name */
+  "noname",		/* node/network name */
+  OS_RELEASE,		/* O.S. release (e.g. 3.3.0) */
+  OS_VERSION,		/* O.S. version (e.g. Minix 3.3.0 (GENERIC)) */
+#if defined(__i386__)
+  "i386",		/* machine (cpu) type */
+  "i386",		/* architecture */
+#elif defined(__arm__)
+  "arm",		/* machine (cpu) type */
+  "arm",		/* architecture */
+#else
+#error			/* oops, no 'uname -mk' */
+#endif
+};
+
+struct mutex {
+  int mutex_num;
+  mthread_queue_t mm_queue; 
+  mthread_thread_t mm_owner;
+  struct mutex *prev;
+  struct mutex *next;
+};
+
+struct var_cond {
+  struct mutex *mc_mutex; 
+  struct var_cond *prev;
+  struct var_cond *next;
+  int cond_num;
+};
+
+
+static struct mutex *mrear=NULL;
+static struct mutex *mfront=NULL;
+static int m_num=0;
+
+static struct var_cond *vcfront=NULL;
+static struct var_cond *vcrear=NULL;
+static int vc_num=0;
+
+static char *uts_tbl[] = {
+  uts_val.arch,
+  NULL,			/* No kernel architecture */
+  uts_val.machine,
+  NULL,			/* No hostname */
+  uts_val.nodename,
+  uts_val.release,
+  uts_val.version,
+  uts_val.sysname,
+  NULL,			/* No bus */			/* No bus */
+};
+
+#if ENABLE_SYSCALL_STATS
+unsigned long calls_stats[NR_SYNC_CALLS];
+#endif
+
+
+/*===========================================================================*
+ *				do_mutex_init                                   			             *
+ *===========================================================================*/
+int do_mutex_init(void)
+{
+  struct mutex *m;
+
+  if ((m = malloc(sizeof(struct mutex))) == NULL) 
+    return(ENOMEM);
+
+  m->mutex_num=++m_num;
+  if (mfront == NULL) { /* Empty list */
+    mfront = m;
+    m->prev = NULL;
+  } else {
+    mrear->next = m;
+    m->prev = mrear;
+  }
+
+  m->next = NULL;
+   mrear = m;
+   m->mm_owner = NO_THREAD;
+
+  mthread_queue_init(&m->mm_queue);
+  return(m->mutex_num);
+}
+
+/*=====================*
+*    do_mutex_destroy *
+*=====================*/
+int do_mutex_destroy(void)
+{
+ int  mutex_num = m_in.m1_i1;
+  struct mutex *aux;
+  int ex=0;
+
+  aux = mfront;
+
+  while (aux != NULL) {
+    if (aux->mutex_num == mutex_num){
+      ex=1;
+      break;
+    }
+
+    aux = aux->next;
+  }
+
+  if (ex==0) 
+    return(EINVAL);
+  else if (aux->mm_owner != NO_THREAD)
+    return(EBUSY);
+
+  if (aux->prev == NULL)
+    mfront = aux->next;
+  else
+    aux->prev->next = aux->next;
+
+  if (aux->next == NULL)
+    mrear = aux->prev;
+  else
+    aux->next->prev = aux->prev;
+  free(aux);
+  aux = NULL;
+
+  return(0);
+}
+
+/*=====================*
+*    do_mutex_lock *
+*=====================*/
+int do_mutex_lock(void)
+{
+   int mutex_num = m_in.m1_i1;
+   struct mutex *aux;
+  int ex=0;
+
+  aux = mfront;
+
+  while (aux != NULL) {
+    if (aux->mutex_num == mutex_num){
+      ex=1;
+      break;
+    }
+
+    aux = aux->next;
+  }
+
+  if (ex==0) 
+    return(EINVAL);
+
+
+   if (aux->mm_owner == NO_THREAD) 
+  aux->mm_owner = current_thread;
+ 
+   else {
+  mthread_queue_add(&aux->mm_queue, current_thread);
+  mthread_suspend(MS_MUTEX);
+  }
+
+  return(0);
+}
+
+/*=====================*
+*    do_mutex_unlock *
+*=====================*/
+int do_mutex_unlock(void)
+{
+     int mutex_num = m_in.m1_i1;
+     struct mutex *aux;
+  int ex=0;
+
+  aux = mfront;
+
+  while (aux != NULL) {
+    if (aux->mutex_num == mutex_num){
+      ex=1;
+      break;
+    }
+
+    aux = aux->next;
+  }
+
+  if (ex==0) 
+    return(EINVAL);
+
+  else if (aux->mm_owner != current_thread) 
+    return(ENOLCK);  
+
+  aux->mm_owner = mthread_queue_remove(&aux->mm_queue);
+  if (aux->mm_owner != NO_THREAD) mthread_unsuspend(aux->mm_owner);
+  return(0);
+}
+
+/*===========================================================================*
+ *                              do_cv_init                                                                        *
+ *===========================================================================*/
+int do_cv_init(void)
+{
+  int b = 5;
+  return(b);
+}
+
+/*=====================*
+*    do_cv_destroy *
+*=====================*/
+int do_cv_destroy()
+{
+        int cv_num = m_in.m1_i1;
+        printf("cv destruido %d \n",cv_num);
+        return (OK);
+}
+
+/*=====================*
+*    do_cv_wait *
+*=====================*/
+int do_cv_wait()
+{
+        int cv_num = m_in.m1_i1;
+        printf("cv esperando %d \n",cv_num);
+        return (OK);
+}
+
+/*=====================*
+*    do_cv_signal *
+*=====================*/
+int do_cv_signal()
+{
+        int cv_num = m_in.m1_i1;
+        printf("cv signal %d \n",cv_num);
+        return (OK);
+}
+
+/*=====================*
+*    do_cv_broadcast *
+*=====================*/
+int do_cv_broadcast()
+{
+        int cv_num = m_in.m1_i1;
+        printf("cv broadcast %d \n",cv_num);
+        return (OK);
+}
+
+
+
Binary files srclimpio/minix/servers/syncvar/syncvar.o and proj/minix/servers/syncvar/syncvar.o differ
diff -ruNp srclimpio/minix/servers/syncvar/table.c proj/minix/servers/syncvar/table.c
--- srclimpio/minix/servers/syncvar/table.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/table.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,25 @@
+/* This file contains the table used to map system call numbers onto the
+ * routines that perform them.
+ */
+
+#define _TABLE
+
+#include "pm.h"
+#include </usr/src/minix/include/minix/callnr.h>
+#include <signal.h>
+#include "mproc.h"
+
+#define CALL(n) [((n) - SYNC_BASE)]
+
+int (* const call_vec[NR_SYNC_CALLS])(void) = { 
+  CALL(SYNC_MUTEX_INIT)      = do_mutex_init,       /* mutex_init */
+  CALL(SYNC_MUTEX_DESTROY)   = do_mutex_destroy,    /* mutex_destroy */
+  CALL(SYNC_MUTEX_LOCK)      = do_mutex_lock,       /* mutex_lock */
+  CALL(SYNC_MUTEX_UNLOCK)    = do_mutex_unlock,     /* mutex_unlock */
+  CALL(SYNC_CV_INIT)         = do_cv_init,     	    /* cv_init */
+  CALL(SYNC_CV_DESTROY)      = do_cv_destroy,       /* cv_destroy */
+  CALL(SYNC_CV_WAIT)         = do_cv_wait,     	    /* cv_wait */
+  CALL(SYNC_CV_SIGNAL)       = do_cv_signal,        /* cv_signal */
+  CALL(SYNC_CV_BROADCAST)    = do_cv_broadcast      /* cv_broadcast */
+
+};
diff -ruNp srclimpio/minix/servers/syncvar/table.d proj/minix/servers/syncvar/table.d
--- srclimpio/minix/servers/syncvar/table.d	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/table.d	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,46 @@
+table.o: table.c pm.h /usr/include/minix/config.h \
+  /usr/include/minix/sys_config.h /usr/include/sys/types.h \
+  /usr/include/sys/featuretest.h /usr/include/machine/types.h \
+  /usr/include/sys/cdefs.h /usr/include/machine/cdefs.h \
+  /usr/include/sys/cdefs_elf.h /usr/include/machine/int_types.h \
+  /usr/include/machine/ansi.h /usr/include/sys/ansi.h \
+  /usr/include/machine/endian.h /usr/include/sys/endian.h \
+  /usr/include/machine/endian_machdep.h /usr/include/machine/bswap.h \
+  /usr/include/machine/byte_swap.h /usr/include/sys/bswap.h \
+  /usr/include/sys/fd_set.h /usr/include/minix/const.h \
+  /usr/include/machine/archconst.h /usr/include/sys/null.h \
+  /usr/include/minix/type.h /usr/include/machine/multiboot.h \
+  /usr/include/sys/sigtypes.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/stdint.h /usr/include/stdint.h \
+  /usr/include/machine/int_mwgwtypes.h /usr/include/machine/int_limits.h \
+  /usr/include/machine/int_const.h /usr/include/machine/wchar_limits.h \
+  /usr/include/machine/interrupt.h /usr/include/fcntl.h \
+  /usr/include/sys/stat.h /usr/include/sys/time.h \
+  /usr/include/sys/select.h /usr/include/time.h /usr/include/unistd.h \
+  /usr/include/sys/unistd.h /usr/include/string.h /usr/include/strings.h \
+  /usr/include/minix/syslib.h /usr/include/minix/ipc.h \
+  /usr/include/minix/ipcconst.h /usr/include/machine/ipcconst.h \
+  /usr/include/sys/signal.h /usr/include/sys/siginfo.h \
+  /usr/include/machine/signal.h /usr/include/machine/fpu.h \
+  /usr/include/machine/trap.h /usr/include/x86/trap.h \
+  /usr/include/sys/ucontext.h /usr/include/machine/mcontext.h \
+  /usr/include/minix/u64.h /usr/include/minix/devio.h \
+  /usr/include/minix/safecopies.h /usr/include/minix/vm.h \
+  /usr/include/minix/endpoint.h /usr/include/minix/com.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/limits.h /usr/include/limits.h \
+  /usr/include/machine/limits.h /usr/include/sys/syslimits.h \
+  /usr/include/minix/sef.h /usr/include/stdio.h \
+  /usr/include/minix/sysutil.h /usr/include/minix/timers.h \
+  /usr/include/minix/minlib.h /usr/include/sys/mount.h \
+  /usr/include/sys/param.h /usr/include/sys/inttypes.h \
+  /usr/include/machine/int_fmtio.h /usr/include/machine/param.h \
+  /usr/include/sys/uio.h /usr/include/sys/ucred.h \
+  /usr/include/sys/fstypes.h /usr/include/sys/queue.h \
+  /usr/include/sys/rwlock.h /usr/include/machine/rwlock.h \
+  /usr/include/x86/rwlock.h /usr/include/sys/statvfs.h \
+  /usr/include/sys/specificdata.h /usr/include/sys/mutex.h \
+  /usr/include/machine/mutex.h /usr/include/x86/mutex.h \
+  /usr/include/sys/condvar.h /usr/include/minix/param.h \
+  /usr/include/errno.h /usr/include/sys/errno.h const.h type.h proto.h \
+  glo.h /usr/src/minix/include/minix/callnr.h /usr/include/signal.h \
+  mproc.h
Binary files srclimpio/minix/servers/syncvar/table.o and proj/minix/servers/syncvar/table.o differ
diff -ruNp srclimpio/minix/servers/syncvar/type.h proj/minix/servers/syncvar/type.h
--- srclimpio/minix/servers/syncvar/type.h	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/type.h	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,5 @@
+/* If there were any type definitions local to the Process Manager, they would
+ * be here.  This file is included only for symmetry with the kernel and File
+ * System, which do have some local type definitions.
+ */
+
diff -ruNp srclimpio/minix/servers/syncvar/utility.c proj/minix/servers/syncvar/utility.c
--- srclimpio/minix/servers/syncvar/utility.c	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/utility.c	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,138 @@
+/* This file contains some utility routines for PM.
+ *
+ * The entry points are:
+ *   get_free_pid:	get a free process or group id
+ *   find_param:	look up a boot monitor parameter
+ *   find_proc:		return process pointer from pid number
+ *   nice_to_priority	convert nice level to priority queue
+ *   pm_isokendpt:	check the validity of an endpoint
+ *   tell_vfs:		send a request to VFS on behalf of a process
+ */
+
+#include "pm.h"
+#include <sys/resource.h>
+#include <sys/stat.h>
+#include <minix/callnr.h>
+#include <minix/com.h>
+#include <minix/endpoint.h>
+#include <fcntl.h>
+#include <signal.h>		/* needed only because mproc.h needs it */
+#include "mproc.h"
+
+#include <minix/config.h>
+#include <minix/timers.h>
+#include <machine/archtypes.h>
+#include "kernel/const.h"
+#include "kernel/config.h"
+#include "kernel/type.h"
+#include "kernel/proc.h"
+
+/*===========================================================================*
+ *				get_free_pid				     *
+ *===========================================================================*/
+pid_t get_free_pid()
+{
+  static pid_t next_pid = INIT_PID + 1;		/* next pid to be assigned */
+  register struct mproc *rmp;			/* check process table */
+  int t;					/* zero if pid still free */
+
+  /* Find a free pid for the child and put it in the table. */
+  do {
+	t = 0;			
+	next_pid = (next_pid < NR_PIDS ? next_pid + 1 : INIT_PID + 1);
+	for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++)
+		if (rmp->mp_pid == next_pid || rmp->mp_procgrp == next_pid) {
+			t = 1;
+			break;
+		}
+  } while (t);					/* 't' = 0 means pid free */
+  return(next_pid);
+}
+
+/*===========================================================================*
+ *				find_param				     *
+ *===========================================================================*/
+char *find_param(name)
+const char *name;
+{
+  register const char *namep;
+  register char *envp;
+
+  for (envp = (char *) monitor_params; *envp != 0;) {
+	for (namep = name; *namep != 0 && *namep == *envp; namep++, envp++)
+		;
+	if (*namep == '\0' && *envp == '=') 
+		return(envp + 1);
+	while (*envp++ != 0)
+		;
+  }
+  return(NULL);
+}
+
+/*===========================================================================*
+ *				find_proc  				     *
+ *===========================================================================*/
+struct mproc *find_proc(lpid)
+pid_t lpid;
+{
+  register struct mproc *rmp;
+
+  for (rmp = &mproc[0]; rmp < &mproc[NR_PROCS]; rmp++)
+	if ((rmp->mp_flags & IN_USE) && rmp->mp_pid == lpid)
+		return(rmp);
+
+  return(NULL);
+}
+
+/*===========================================================================*
+ *				nice_to_priority			     *
+ *===========================================================================*/
+int nice_to_priority(int nice, unsigned* new_q)
+{
+	if (nice < PRIO_MIN || nice > PRIO_MAX) return(EINVAL);
+
+	*new_q = MAX_USER_Q + (nice-PRIO_MIN) * (MIN_USER_Q-MAX_USER_Q+1) /
+	    (PRIO_MAX-PRIO_MIN+1);
+
+	/* Neither of these should ever happen. */
+	if ((signed) *new_q < MAX_USER_Q) *new_q = MAX_USER_Q;
+	if (*new_q > MIN_USER_Q) *new_q = MIN_USER_Q;
+
+	return (OK);
+}
+
+/*===========================================================================*
+ *				pm_isokendpt			 	     *
+ *===========================================================================*/
+int pm_isokendpt(int endpoint, int *proc)
+{
+	*proc = _ENDPOINT_P(endpoint);
+	if (*proc < 0 || *proc >= NR_PROCS)
+		return EINVAL;
+	if (endpoint != mproc[*proc].mp_endpoint)
+		return EDEADEPT;
+	if (!(mproc[*proc].mp_flags & IN_USE))
+		return EDEADEPT;
+	return OK;
+}
+
+/*===========================================================================*
+ *				tell_vfs			 	     *
+ *===========================================================================*/
+void tell_vfs(rmp, m_ptr)
+struct mproc *rmp;
+message *m_ptr;
+{
+/* Send a request to VFS, without blocking.
+ */
+  int r;
+
+  if (rmp->mp_flags & VFS_CALL)
+	panic("tell_vfs: not idle: %d", m_ptr->m_type);
+
+  r = asynsend3(VFS_PROC_NR, m_ptr, AMF_NOREPLY);
+  if (r != OK)
+  	panic("unable to send to VFS: %d", r);
+
+  rmp->mp_flags |= VFS_CALL;
+}
diff -ruNp srclimpio/minix/servers/syncvar/utility.d proj/minix/servers/syncvar/utility.d
--- srclimpio/minix/servers/syncvar/utility.d	Thu Jan  1 00:00:00 1970
+++ proj/minix/servers/syncvar/utility.d	Fri Oct 30 14:23:59 2015
@@ -0,0 +1,52 @@
+utility.o: utility.c pm.h /usr/include/minix/config.h \
+  /usr/include/minix/sys_config.h /usr/include/sys/types.h \
+  /usr/include/sys/featuretest.h /usr/include/machine/types.h \
+  /usr/include/sys/cdefs.h /usr/include/machine/cdefs.h \
+  /usr/include/sys/cdefs_elf.h /usr/include/machine/int_types.h \
+  /usr/include/machine/ansi.h /usr/include/sys/ansi.h \
+  /usr/include/machine/endian.h /usr/include/sys/endian.h \
+  /usr/include/machine/endian_machdep.h /usr/include/machine/bswap.h \
+  /usr/include/machine/byte_swap.h /usr/include/sys/bswap.h \
+  /usr/include/sys/fd_set.h /usr/include/minix/const.h \
+  /usr/include/machine/archconst.h /usr/include/sys/null.h \
+  /usr/include/minix/type.h /usr/include/machine/multiboot.h \
+  /usr/include/sys/sigtypes.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/stdint.h /usr/include/stdint.h \
+  /usr/include/machine/int_mwgwtypes.h /usr/include/machine/int_limits.h \
+  /usr/include/machine/int_const.h /usr/include/machine/wchar_limits.h \
+  /usr/include/machine/interrupt.h /usr/include/fcntl.h \
+  /usr/include/sys/stat.h /usr/include/sys/time.h \
+  /usr/include/sys/select.h /usr/include/time.h /usr/include/unistd.h \
+  /usr/include/sys/unistd.h /usr/include/string.h /usr/include/strings.h \
+  /usr/include/minix/syslib.h /usr/include/minix/ipc.h \
+  /usr/include/minix/ipcconst.h /usr/include/machine/ipcconst.h \
+  /usr/include/sys/signal.h /usr/include/sys/siginfo.h \
+  /usr/include/machine/signal.h /usr/include/machine/fpu.h \
+  /usr/include/machine/trap.h /usr/include/x86/trap.h \
+  /usr/include/sys/ucontext.h /usr/include/machine/mcontext.h \
+  /usr/include/minix/u64.h /usr/include/minix/devio.h \
+  /usr/include/minix/safecopies.h /usr/include/minix/vm.h \
+  /usr/include/minix/endpoint.h /usr/include/minix/com.h \
+  /usr/pkg/bin/../lib/clang/3.4/include/limits.h /usr/include/limits.h \
+  /usr/include/machine/limits.h /usr/include/sys/syslimits.h \
+  /usr/include/minix/sef.h /usr/include/stdio.h \
+  /usr/include/minix/sysutil.h /usr/include/minix/timers.h \
+  /usr/include/minix/minlib.h /usr/include/sys/mount.h \
+  /usr/include/sys/param.h /usr/include/sys/inttypes.h \
+  /usr/include/machine/int_fmtio.h /usr/include/machine/param.h \
+  /usr/include/sys/uio.h /usr/include/sys/ucred.h \
+  /usr/include/sys/fstypes.h /usr/include/sys/queue.h \
+  /usr/include/sys/rwlock.h /usr/include/machine/rwlock.h \
+  /usr/include/x86/rwlock.h /usr/include/sys/statvfs.h \
+  /usr/include/sys/specificdata.h /usr/include/sys/mutex.h \
+  /usr/include/machine/mutex.h /usr/include/x86/mutex.h \
+  /usr/include/sys/condvar.h /usr/include/minix/param.h \
+  /usr/include/errno.h /usr/include/sys/errno.h const.h type.h proto.h \
+  glo.h /usr/include/sys/resource.h /usr/include/minix/callnr.h \
+  /usr/include/signal.h mproc.h /usr/include/machine/archtypes.h \
+  /usr/include/machine/stackframe.h /usr/src/minix/kernel/const.h \
+  /usr/include/minix/bitmap.h /usr/src/minix/kernel/config.h \
+  /usr/src/minix/kernel/debug.h /usr/include/minix/debug.h \
+  /usr/src/minix/kernel/type.h /usr/src/minix/kernel/proc.h \
+  /usr/include/minix/portio.h /usr/src/minix/kernel/priv.h \
+  /usr/include/minix/priv.h
Binary files srclimpio/minix/servers/syncvar/utility.o and proj/minix/servers/syncvar/utility.o differ
diff -ruNp srclimpio/releasetools/Makefile proj/releasetools/Makefile
--- srclimpio/releasetools/Makefile	Thu Oct 29 20:46:54 2015
+++ proj/releasetools/Makefile	Fri Oct 30 11:20:11 2015
@@ -24,6 +24,7 @@ PROGRAMS+= ${PROGROOT}/minix/fs/mfs/mfs
 PROGRAMS+= ${PROGROOT}/minix/servers/vm/vm
 PROGRAMS+= ${PROGROOT}/minix/fs/pfs/pfs
 PROGRAMS+= ${PROGROOT}/sbin/init/init
+PROGRAMS+= ${PROGROOT}/minix/servers/syncvar/syncvar
 
 all usage help:
 	@echo " " >&2
